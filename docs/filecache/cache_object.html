<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ocean_science_utilities.filecache.cache_object API documentation</title>
<meta name="description" content="Contents: Simple file caching routines that automatically
cache remote files locally for use â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocean_science_utilities.filecache.cache_object</code></h1>
</header>
<section id="section-intro">
<p>Contents: Simple file caching routines that automatically
cache remote files locally for use.</p>
<p>Copyright (C) 2022
Sofar Ocean Technologies</p>
<h1 id="authors-pieter-bart-smit">Authors: Pieter Bart Smit</h1>
<p>Classes:
- <code><a title="ocean_science_utilities.filecache.cache_object.FileCache" href="#ocean_science_utilities.filecache.cache_object.FileCache">FileCache</a></code>, main class implementing the Caching structure. Should not
directly be invoked. Instead, fetching/cache creation is controlled by a
set of function defined below</p>
<p>Functions:</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contents: Simple file caching routines that automatically \
    cache remote files locally for use.

Copyright (C) 2022
Sofar Ocean Technologies

Authors: Pieter Bart Smit
======================

Classes:
- `FileCache`, main class implementing the Caching structure. Should not
   directly be invoked. Instead, fetching/cache creation is controlled by a
   set of function defined below

Functions:

&#34;&#34;&#34;
import hashlib
import json
import os

from dataclasses import dataclass
from pathlib import Path
from multiprocessing.pool import ThreadPool
from typing import Callable, Dict, List, Optional, Tuple, Union
from tqdm import tqdm
from warnings import warn

from ocean_science_utilities.tools.log import logger
from ocean_science_utilities.filecache.remote_resources import (
    _RemoteResourceUriNotFound,
    RemoteResourceHTTPS,
    RemoteResource,
    RemoteResourceLocal,
)

TEMPORARY_DIRECTORY = &#34;~/temporary_roguewave_files/filecache/&#34;
CACHE_SIZE_GB = 5
MAXIMUM_NUMBER_OF_WORKERS = 10
KILOBYTE = 1000
MEGABYTE = 1000 * KILOBYTE
GIGABYTE = 1000 * MEGABYTE


def do_nothing(*arg, **kwargs) -&gt; Optional[bool]:
    &#34;&#34;&#34;
    Null function for convenience.

    :param arg:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    return None


@dataclass()
class CacheMiss:
    &#34;&#34;&#34;
    Data class for Cache miss.
    &#34;&#34;&#34;
    uri: str
    filepath: str
    filename: str
    allow_for_missing_files: bool
    post_process_function: Callable[[str], Optional[bool]]
    download_function: Callable[[str, str], Optional[bool]] = do_nothing


class FileCacheConfig:
    def __init__(
        self,
        size_gb: Union[float, int] = CACHE_SIZE_GB,
        parallel: bool = True,
        allow_for_missing_files: bool = True,
        path: str = TEMPORARY_DIRECTORY,
    ):
        self.path = path
        self.size_gb = size_gb
        self.parallel = parallel
        self.allow_for_missing_files = allow_for_missing_files

        if self.config_exists():
            self.load_config()
        else:
            self._write_config()

    @property
    def name(self) -&gt; str:
        return os.path.join(self.path, &#34;file_cache_config.json&#34;)

    def config_exists(self) -&gt; bool:
        return os.path.exists(self.name)

    def load_config(self) -&gt; None:
        with open(self.name, &#34;rb&#34;) as fp:
            config = json.load(fp)
            self.size_gb = config[&#34;size_gb&#34;]
            self.parallel = config[&#34;parallel&#34;]
            self.allow_for_missing_files = config[&#34;allow_for_missing_files&#34;]

    def _update_config(self, key, value, write=True):
        self[key] = value
        if write:
            self._write_config()

    def _write_config(self):
        with open(os.path.join(self.path, &#34;file_cache_config.json&#34;), &#34;wt&#34;) as fp:
            fp.write(
                json.dumps(
                    {
                        &#34;size_gb&#34;: self.size_gb,
                        &#34;parallel&#34;: self.parallel,
                        &#34;allow_for_missing_files&#34;: self.allow_for_missing_files,
                    },
                    indent=4,
                )
            )

    @property
    def max_size(self) -&gt; Union[float, int]:
        return self.size_gb

    @max_size.setter
    def max_size(self, size_gb: float):
        self._update_config(&#34;size_gb&#34;, size_gb)

    @property
    def max_size_bytes(self) -&gt; int:
        return int(self.size_gb * GIGABYTE)

    @max_size_bytes.setter
    def max_size_bytes(self, size_bytes: int):
        self._update_config(&#34;size_gb&#34;, size_bytes / GIGABYTE)

    @property
    def parallel(self) -&gt; bool:
        return self.parallel

    @parallel.setter
    def parallel(self, parallel: bool):
        self._update_config(&#34;parallel&#34;, parallel)

    @property
    def allow_for_missing_files(self) -&gt; bool:
        return self.allow_for_missing_files

    @allow_for_missing_files.setter
    def allow_for_missing_files(self, allow_for_missing_files: bool):
        self._update_config(&#34;allow_for_missing_files&#34;, allow_for_missing_files)


class FileCache:
    &#34;&#34;&#34;
    Simple file caching class that when given an URI locally stores the
    file in the cache directory and returns the path to the file. The file
    remains in storage until the cache directory exceeds a prescribed size,
    in which case files with oldest access/modified dates get deleted first
    until everything fits in the cache again. Any time a file is accessed it&#39;s
    modified date gets updated so that often used files automaticall remain in
    cache.

    The files are stored locally in the directory specified on class
    initialization, as:

        [path]/CACHE_PREFIX + md5_hash_of_URI + CACHE_POSTFIX

    The pre- and post fix are added so we have an easy pattern to distinguish
    cache files from other files.

    Methods
      * __getitem__(keys) : accept a simgle uri_key or a list of URI&#39;s and
        returns filepaths to local copies thereof. You would typically use the
            cache[keys] notation instead of the dunder method.
      * purge() clear all contents of the cache (destructive, deletes all local
        files).

    Usage:

        cache = FileCache()
        list_of_local_file_names = cache[ [list of URI&#39;s ] ]

    # do stuff with file
    ...
    &#34;&#34;&#34;

    CACHE_FILE_PREFIX = &#34;cachefile_&#34;
    CACHE_FILE_POSTFIX = &#34;_cachefile&#34;

    def __init__(
        self,
        path: str = TEMPORARY_DIRECTORY,
        size_GB: Union[float, int] = CACHE_SIZE_GB,
        do_cache_eviction_on_startup: bool = False,
        resources: Optional[List[RemoteResource]] = None,
        parallel: bool = True,
        allow_for_missing_files: bool = True,
    ):
        &#34;&#34;&#34;
        Initialize Cache
        :param path: path to store cache. If path does not exist it will be
            created.
        :param size_GB: Maximum size of the cache in GiB. If cache exceeds
            the size, then files with oldest access/modified dates get deleted
            until everthing fits in the cache again. Fractional values (floats)
            are allowed.
        :param do_cache_eviction_on_startup: whether we ensure the cache size
            conforms to the given size on startup. If set to true, a cache
            directory that exceeds the maximum size will be reduced to max
            size. Set to False by default in which case an error occurs. The
            latter to prevent eroneously evicting files from a cache that was
            previously created on purpose with a larger size that the limit.


        &#34;&#34;&#34;
        self.path = os.path.expanduser(path)
        # create the path if it does not exist
        if not os.path.exists(path):
            os.makedirs(path, exist_ok=True)

        self.config = FileCacheConfig(size_GB, parallel, allow_for_missing_files, path)

        # Some counters to keep track of total cache misses, hits and
        # evictions. No downstream use right now/
        self._cache_misses = 0
        self._cache_hits = 0
        self._cache_evictions = 0
        self.disable_progress_bar = False

        # initialize the cache.
        self._entries: Dict[str, str] = {}  # the key/value pair cache
        self._initialize_cache(do_cache_eviction_on_startup)

        # Post processing and validation functions
        self.directives: Dict[str, Dict[str, Callable[[str], Optional[bool]]]] = {
            &#34;validate&#34;: {},
            &#34;postprocess&#34;: {},
        }

        # message to display on progress bar
        self.description = &#34;Caching&#34;

        # download resources
        if resources is None:
            self.resources = [
                RemoteResourceHTTPS(),
                RemoteResourceLocal(),
            ]
        else:
            self.resources = resources

    def set_directive_function(
        self,
        directive,
        name,
        function: Callable[[str], Optional[bool]],
    ):
        &#34;&#34;&#34;
        AI is creating summary for set_directive_function

        Args:
            directive ([type]): [description]
            name ([type]): [description]
            function (Callable[[str], Optional[bool]]): [description]

        Raises:
            KeyError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        if directive not in self.directives:
            raise KeyError(f&#34;{directive} is not a valid cache directive.&#34;)

        if name in self.directives[directive]:
            raise ValueError(f&#34;Function  for {name} already exists&#34;)
        else:
            self.directives[directive][name] = function

    def remove_directive_function(self, directive: str, name: str):
        if directive not in self.directives:
            raise KeyError(f&#34;{directive} is not a valid cache directive.&#34;)

        if name not in self.directives[directive]:
            raise ValueError(f&#34;Function  for {name} does not exist&#34;)
        else:
            self.directives[directive].pop(name)

    def _cache_file_name(self, uri: str) -&gt; str:
        &#34;&#34;&#34;
        Return the filename that corresponds to the given uri. We construct
        the file name using a simple md5 hash of the uri string prefixed
        with a cache file prefix. THe later is introduced to seperate cache
        files in a path from user files (and avoid including/deleting those).

        :param uri: valid uri stripped from directives
        :return: valid cache file
        &#34;&#34;&#34;
        return self.CACHE_FILE_PREFIX + _hashname(uri) + self.CACHE_FILE_POSTFIX

    def _cache_file_path(self, uri: str) -&gt; str:
        &#34;&#34;&#34;
        Construct the path where the given uri is stored locally.

        :param uri: valid uri stripped from directives.
        :return: valid cache file
        &#34;&#34;&#34;
        return os.path.join(self.path, self._cache_file_name(uri))

    def _get_cache_files(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Find all files that are currently a member of the cache.
        :return:
        &#34;&#34;&#34;
        for path, dirs, files in os.walk(self.path):
            # Return all files that are &#34;cache&#34; objects. This is a safety if
            # other user files are present, so that these don&#39;t accidentally
            # evicted from the cache (aka deleted).
            return [
                file
                for file in files
                if file.startswith(self.CACHE_FILE_PREFIX)
                and file.endswith(self.CACHE_FILE_POSTFIX)
            ]
        else:
            return []

    def _initialize_cache(self, do_cache_eviction_on_startup: bool) -&gt; None:
        &#34;&#34;&#34;
        Initialize the file cache. Look on disk for files in the cache path
        that have the required prefix and load these into the cache. Once
        loaded, we do a check whether or not the cache is full and if we need
        to remove files.
        :param do_cache_eviction_on_startup: see description under __init__
        :return:
        &#34;&#34;&#34;
        self._entries = {}
        for file in self._get_cache_files():
            filepath = os.path.join(self.path, file)
            self._entries[file] = filepath

        # See if cache is still &lt; size
        if do_cache_eviction_on_startup:
            self._cache_eviction()
        else:
            if self._size() &gt; self.config.max_size_bytes:
                raise ValueError(
                    &#34;The cache currently existing on disk &#34;
                    &#34;exceeds the maximum cache size of the &#34;
                    f&#34;current cache ({self.config.max_size} gb).&#34;
                    f&#34;\n The cache size can be increased by&#34;
                    f&#34; editting the cache config file: &#34;
                    f&#34;{self.config.name}&#34;
                )

    def in_cache(self, unparsed_uris) -&gt; List[bool]:
        # make sure input is a list
        if isinstance(unparsed_uris, str):
            unparsed_uris = [unparsed_uris]

        uris, _ = parse_directives(unparsed_uris)

        # Create the hashes from the URI&#39;s
        hashes = [self._cache_file_name(uri) for uri in uris]
        return [self._is_in_cache(_hash) for _hash in hashes]

    def _is_in_cache(self, _hash: str) -&gt; bool:
        &#34;&#34;&#34;
        Check if a _hash is in the cache
        :param _hash: hash to check
        :return: True if in Cache, False if not.
        &#34;&#34;&#34;
        cache_hit = _hash in self._entries
        return cache_hit

    def _add_to_cache(self, _hash: str, filepath: str) -&gt; None:
        # add entry to the cache.
        self._entries[_hash] = filepath

    def remove(self, unparsed_uri: str) -&gt; None:
        &#34;&#34;&#34;
        Remove an entry from the cache
        :param unparsed_uri: uri
        :return: None
        &#34;&#34;&#34;
        uri, _ = parse_directive(unparsed_uri)

        if not self.in_cache(uri):
            raise ValueError(f&#34;Key {uri} not in Cache&#34;)

        _hash = self._cache_file_name(uri)
        return self._remove_item_from_cache(_hash)

    def _remove_item_from_cache(self, _hash: str) -&gt; None:
        &#34;&#34;&#34;
        Remove a hash key from the cache. Here it is assumed that the _hash is
        a valid entry. We do allow for non existance of corresponding files as
        the cache can get out of sync if something external deleted the file.
        Since the endstate is valid (no entry in cache, no entry on disk) this
        is considered OK.

        :param _hash: hash key
        :return: None
        &#34;&#34;&#34;

        if _hash not in self._entries:
            return None

        file_to_delete = self._entries.pop(_hash)

        if os.path.exists(file_to_delete):
            logger.debug(f&#34; - removing {_hash}&#34;)

            # And delete file.
            os.remove(file_to_delete)
        else:
            logger.debug(f&#34; - file {_hash} did not exist on disk&#34;)

        return None

    def _get_from_cache(self, _hash: str) -&gt; str:
        &#34;&#34;&#34;
        Get entry from cache and touch the file to indicate it has been used
        recently (last to be evicted)
        :param _hash: file_hash corresponding to uri
        :return: file path
        &#34;&#34;&#34;
        filepath = self._entries[_hash]

        if not os.path.exists(filepath):
            raise FileNotFoundError(
                &#34;The filepath in the cache log does not&#34; &#34;exist on disk.&#34;
            )

        # Touch the file to indicate we recently used it.
        Path(filepath).touch()

        return filepath

    def get_cache_misses(
        self, uris: List[str], directives: List[Dict[str, str]]
    ) -&gt; List[CacheMiss]:
        &#34;&#34;&#34;
        Function to get all cache misses and return a list of CacheMiss objects
        needed to download the misses from remote resources.

        This function also perform validates on potential cache hits if a
        relevant validation function is set *and* validation is requested
        through a directive.

        :param uris: list of uris stripped of directives
        :param directives: list of directives per uri (empty dict if none)
        :return: list of cache misses
        &#34;&#34;&#34;

        cache_misses = []
        for uri, directive in zip(uris, directives):
            # what is the hashkey/filename
            hashkey = self._cache_file_name(uri)
            filepath = self._cache_file_path(uri)

            # is the key in cache?
            valid_entry: Optional[bool] = False
            if self._is_in_cache(hashkey):
                # If so is it a valid entry
                if &#34;validate&#34; in directive:
                    # Call the user supplied validation function with the
                    # filepath as argument
                    validation_function = self.directives[&#34;validate&#34;][
                        directive[&#34;validate&#34;]
                    ]

                    try:
                        valid_entry = validation_function(filepath)
                    except IOError:
                        valid_entry = False

                    if not valid_entry:
                        # remove the locally stored entry if not valid
                        os.remove(filepath)
                    else:
                        valid_entry = True
                else:
                    # Defaults to True if no validation directive is given
                    valid_entry = True

            if not valid_entry:
                # If not a valid entry (either missing or invalid)
                #
                if &#34;postprocess&#34; in directive:
                    # Add the postprocess function to use if requested.
                    post_process_function = self.directives[&#34;postprocess&#34;][
                        directive[&#34;postprocess&#34;]
                    ]

                else:
                    # otherwise set a null function as postprocessor
                    post_process_function = do_nothing

                # Remove any comments to the URI used to make it unique
                uri_to_download = uri.split(&#34;&lt;&lt;&#34;)[0]

                cache_misses.append(
                    CacheMiss(
                        uri=uri_to_download,
                        filepath=filepath,
                        filename=hashkey,
                        allow_for_missing_files=self.config.allow_for_missing_files,
                        post_process_function=post_process_function,
                    )
                )
        return cache_misses

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        :return: Number of entries in the cache.
        &#34;&#34;&#34;
        return len(self._entries)

    def __getitem__(self, unparsed_uris: Union[List, str]) -&gt; List[str]:
        &#34;&#34;&#34;
        Get filenames corresponding to locally stored versions of the objects
        the URI points to. Note that the unparsed_uris take the form:

        [ directive=option ; ... directive=option ] &#34;:&#34;
        [scheme] &#34;://&#34; [path] &#34;&gt;&gt;&#34; [comment]

        e.g for amazon s3 where we want to perform validation and post
            processing on entries:

            validate=grib;postprocess=grib:s3://bucket/key

        or without cache directives

            s3://bucket/key

        Cache directives are optional, but if specified the corresponding
        user defined handling function must have been set. By default no
        validation or postprocessing functions are set.

        In addition, we can add a &#34;comment&#34; to the uri by appending
        &#34;&gt;&gt;[comment]&#34;, e.g.

            s3://bucket/key&gt;&gt;THISISTHECOMMENT

        The comment (including &#34;&gt;&gt;&#34;) is stripped prior to downloading from
        the remote resource. However, the comment part *is* included in
        generation of the hash. This allows us to cache the same resource with
        different names. This is primarily useful if we potentially apply
        different postprocessing functions to the same remote resource.

        :param unparsed_uris: URI&#39;s that may still include directives.
        :return:
        &#34;&#34;&#34;
        # make sure input is a list
        if isinstance(unparsed_uris, str):
            unparsed_uris = [unparsed_uris]

        # Remove cache directives from uris (if included)
        uris, directives = parse_directives(unparsed_uris)
        filepaths = [self._cache_file_path(uri) for uri in uris]

        # for all URI&#39;s not in cache
        if cache_misses := self.get_cache_misses(uris, directives):
            was_succesfully_downloaded = _download_from_resources(
                cache_misses,
                self.resources,
                parallel_download=self.config.parallel,
                disable_progress_bar=self.disable_progress_bar,
                desc=self.description,
            )

            for cache_miss, success in zip(cache_misses, was_succesfully_downloaded):
                if success:
                    self._add_to_cache(cache_miss.filename, cache_miss.filepath)
                else:
                    index = filepaths.index(cache_miss.filepath)
                    filepaths.pop(index)

        size_of_requested_data = _get_total_size_of_files_in_bytes(filepaths)
        if size_of_requested_data &gt; self.config.max_size_bytes:
            warning = (
                f&#34;The requested data does not fit into the cache.&#34;
                f&#34;To avoid issues the cache is enlarged to ensure&#34;
                f&#34;the current set of files fits in the cache. \n&#34;
                f&#34;old size: {self.config.max_size_bytes} bytes; &#34;
                f&#34;new size {size_of_requested_data + MEGABYTE}&#34;
            )
            warn(warning)
            logger.warning(warning)
            self.config.max_size_bytes = size_of_requested_data + MEGABYTE

        self._cache_misses += len(cache_misses)
        self._cache_hits += len(uris) - len(cache_misses)

        # See if we need to do any cache eviction because the cache has become
        # to big.
        if not len(cache_misses) == 0:
            self._cache_eviction()

        return filepaths

    def _cache_eviction(self) -&gt; bool:
        &#34;&#34;&#34;
        Simple cache eviction policy. If the cache exceeds the maximum size
        remove data from the cache based on whichever file was interacted with
        the longest time ago. Evict files until we are below the acceptable
        cache size.

        :return: True if eviction occured, False otherwise.
        &#34;&#34;&#34;

        # check if we exceed the size, if not return
        if not self._size() &gt; self.config.max_size_bytes:
            return False

        # Get access/modified times for all the files in cache
        modified = []
        for _hash, fp in self._entries.items():
            # From my brief reading, access time is not always reliable,
            # hence I use whatever the latest time set is for modified or
            # access time as an indicator of when we last interacted with
            # the file.
            access_time = os.path.getatime(fp)
            modified_time = os.path.getmtime(fp)

            # pick whichever is most recent.
            time_to_check = (
                access_time if access_time &gt; modified_time else modified_time
            )
            modified.append((time_to_check, _hash))

        # Sort files in reversed chronological order.
        files_in_cache = [
            x[1] for x in sorted(modified, key=lambda x: x[0], reverse=True)
        ]

        # Delete files one by one as long as the cache_size exceeds the max
        # size.
        while (_size := self._size()) &gt; self.config.max_size_bytes:
            self._cache_evictions += 1
            logger.debug(
                f&#34;Cache exceeds limits: {_size} bytes, max size: &#34;
                f&#34;{self.config.max_size_bytes} bytes&#34;
            )

            # Get the hash and path of the oldest file and remove
            self._remove_item_from_cache(files_in_cache.pop())

        return True

    def _size(self) -&gt; int:
        &#34;&#34;&#34;
        Return size on disk of the cache in bytes.
        :return: cache size in bytes.
        &#34;&#34;&#34;
        return _get_total_size_of_files_in_bytes(
            list(self._entries.values()), self.path
        )

    def purge(self) -&gt; None:
        &#34;&#34;&#34;
        Delete all the files in the cache.
        :return: None
        &#34;&#34;&#34;
        logger.debug(&#34;Purging cache&#34;)
        keys = list(self._entries.keys())
        for key in keys:
            filepath = self._entries.pop(key)
            logger.debug(&#34; - deleting {filepath}&#34;)
            os.remove(filepath)
        logger.debug(&#34;Purging cache done&#34;)


def _download_from_resources(
    cache_misses: List[CacheMiss],
    resources: List[RemoteResource],
    parallel_download=False,
    disable_progress_bar=False,
    desc=&#34;&#34;,
) -&gt; List[bool]:
    &#34;&#34;&#34;
    Wrapper function to download multiple uris from the resource(s).
    :param cache_misses: List containing cache misses to download
    :param parallel_download: If true, downloading is performed in parallel.
    :return: List of boolean indicating if the download was a success.
    &#34;&#34;&#34;

    def _worker(cache_miss: CacheMiss) -&gt; bool:
        try:
            cache_miss.download_function(cache_miss.uri, cache_miss.filepath)
            cache_miss.post_process_function(cache_miss.filepath)
            return True
        except _RemoteResourceUriNotFound as e:
            if cache_miss.allow_for_missing_files:
                warning = f&#34;Uri not retrieved: {str(e)}&#34;
                warn(warning)
                logger.warning(warning)
            else:
                raise e
            return False

    # construct the arguments to be used for parallel downloading of files.
    # Specifically, we need to match the right resource for downloading to the
    # right URI.
    for cache_miss in cache_misses:
        # Loop over all resources until we find one that can interpret the URI
        # (this is pretty naive approach and should probably be refactored to
        #  some direct mapping if the number of resources ever gets very long)
        for resource in resources:
            # For each resource check if the resource can interpret the URI
            if resource.valid_uri(cache_miss.uri):
                # If so, get the download function, and other arguments and
                # break
                cache_miss.download_function = resource.download()
                break
        else:
            # If we didn&#39;t break the loop no valid resource was found, raise
            # error
            raise ValueError(f&#34;No resource available for URI: &#34; f&#34;{cache_miss.uri}&#34;)

    # Download the requested objects.
    if parallel_download and len(cache_misses) &gt; 1:
        with ThreadPool(processes=MAXIMUM_NUMBER_OF_WORKERS) as pool:
            output = list(
                tqdm(
                    pool.imap(_worker, cache_misses, chunksize=5),
                    desc=desc,
                    total=len(cache_misses),
                )
            )
    else:
        if len(cache_misses) == 1:
            disable_progress_bar = True

        output = list(
            tqdm(
                map(_worker, cache_misses),
                total=len(cache_misses),
                disable=disable_progress_bar,
                desc=desc,
            )
        )
    return output


def _get_total_size_of_files_in_bytes(filenames: List[str], path=None) -&gt; int:
    &#34;&#34;&#34;
    Simple function to calculate the size of a list of files on disk.
    :param filenames: list of filenames or filepaths
    :param path: if filenames are provided, this lists the path, otherwise set
        to None

    :return: Total size in bytes
    &#34;&#34;&#34;
    size = 0
    for filename in filenames:
        if path is None:
            filepath = filename
        else:
            filepath = os.path.join(path, filename)

        if os.path.exists(filepath):
            size += os.path.getsize(filepath)
    return size


def _hashname(string: str) -&gt; str:
    &#34;&#34;&#34;
    Returns a md5 hash of a given string.
    :param string: input string
    :return: hexdigest of md5 hash.
    &#34;&#34;&#34;
    return hashlib.md5(string.encode(), usedforsecurity=False).hexdigest()


def parse_directives(raw_uris: List[str]) -&gt; Tuple[List[str], List[dict]]:
    uris = []
    directives = []
    for raw_uri in raw_uris:
        uri, directive = parse_directive(raw_uri)
        uris.append(uri)
        directives.append(directive)
    return uris, directives


def parse_directive(unparsed_uri: str) -&gt; Tuple[str, dict]:
    &#34;&#34;&#34;
    unparsed_uris take the form:

        [ directive=option ; ... directive=option ] &#34;:&#34; [scheme] &#34;://&#34; [path]

        e.g for amazon s3 where we want to perform validation and post
            processing on entries:

            validate=grib;postprocess=grib:s3://bucket/key

        or without cache directives

            s3://bucket/key

    This function seperates the directive/option pairs into a directove
    dictionary, and a valid uri, i.e.

                validate=grib;postprocess=grib:s3://bucket/key

    becomes

        directive = { &#34;validate&#34;:&#34;grib&#34;, &#34;postprocess&#34;:&#34;grib}
        uri = s3://bucket/key

    The parsing is really simple.

    :param unparsed_uri: uri possibly containing cache directives
    :return:
    &#34;&#34;&#34;

    # split in directives_scheme part and a path.
    directives_and_scheme, path = unparsed_uri.split(&#34;://&#34;)

    parsed_directives = {}
    # if a colon is present then directives are provided.
    if &#34;:&#34; in directives_and_scheme:
        # split directives from the scheme
        directive_str, scheme = directives_and_scheme.split(&#34;:&#34;)

        # split multiple directives (if present)
        directives = directive_str.split(&#34;;&#34;)

        # for each directive store in the dict.
        for directive in directives:
            directive_name, directive_parameter = directive.split(&#34;=&#34;)
            parsed_directives[directive_name] = directive_parameter
    else:
        # no directives
        scheme = directives_and_scheme

    uri = scheme + &#34;://&#34; + path
    return uri, parsed_directives</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.do_nothing"><code class="name flex">
<span>def <span class="ident">do_nothing</span></span>(<span>*arg, **kwargs) â€‘>Â Optional[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Null function for convenience.</p>
<p>:param arg:
:param kwargs:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_nothing(*arg, **kwargs) -&gt; Optional[bool]:
    &#34;&#34;&#34;
    Null function for convenience.

    :param arg:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.parse_directive"><code class="name flex">
<span>def <span class="ident">parse_directive</span></span>(<span>unparsed_uri:Â str) â€‘>Â Tuple[str,Â dict]</span>
</code></dt>
<dd>
<div class="desc"><p>unparsed_uris take the form:</p>
<pre><code>[ directive=option ; ... directive=option ] ":" [scheme] "://" [path]

e.g for amazon s3 where we want to perform validation and post
    processing on entries:

    validate=grib;postprocess=grib:s3://bucket/key

or without cache directives

    s3://bucket/key
</code></pre>
<p>This function seperates the directive/option pairs into a directove
dictionary, and a valid uri, i.e.</p>
<pre><code>        validate=grib;postprocess=grib:s3://bucket/key
</code></pre>
<p>becomes</p>
<pre><code>directive = { "validate":"grib", "postprocess":"grib}
uri = s3://bucket/key
</code></pre>
<p>The parsing is really simple.</p>
<p>:param unparsed_uri: uri possibly containing cache directives
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_directive(unparsed_uri: str) -&gt; Tuple[str, dict]:
    &#34;&#34;&#34;
    unparsed_uris take the form:

        [ directive=option ; ... directive=option ] &#34;:&#34; [scheme] &#34;://&#34; [path]

        e.g for amazon s3 where we want to perform validation and post
            processing on entries:

            validate=grib;postprocess=grib:s3://bucket/key

        or without cache directives

            s3://bucket/key

    This function seperates the directive/option pairs into a directove
    dictionary, and a valid uri, i.e.

                validate=grib;postprocess=grib:s3://bucket/key

    becomes

        directive = { &#34;validate&#34;:&#34;grib&#34;, &#34;postprocess&#34;:&#34;grib}
        uri = s3://bucket/key

    The parsing is really simple.

    :param unparsed_uri: uri possibly containing cache directives
    :return:
    &#34;&#34;&#34;

    # split in directives_scheme part and a path.
    directives_and_scheme, path = unparsed_uri.split(&#34;://&#34;)

    parsed_directives = {}
    # if a colon is present then directives are provided.
    if &#34;:&#34; in directives_and_scheme:
        # split directives from the scheme
        directive_str, scheme = directives_and_scheme.split(&#34;:&#34;)

        # split multiple directives (if present)
        directives = directive_str.split(&#34;;&#34;)

        # for each directive store in the dict.
        for directive in directives:
            directive_name, directive_parameter = directive.split(&#34;=&#34;)
            parsed_directives[directive_name] = directive_parameter
    else:
        # no directives
        scheme = directives_and_scheme

    uri = scheme + &#34;://&#34; + path
    return uri, parsed_directives</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.parse_directives"><code class="name flex">
<span>def <span class="ident">parse_directives</span></span>(<span>raw_uris:Â List[str]) â€‘>Â Tuple[List[str],Â List[dict]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_directives(raw_uris: List[str]) -&gt; Tuple[List[str], List[dict]]:
    uris = []
    directives = []
    for raw_uri in raw_uris:
        uri, directive = parse_directive(raw_uri)
        uris.append(uri)
        directives.append(directive)
    return uris, directives</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.CacheMiss"><code class="flex name class">
<span>class <span class="ident">CacheMiss</span></span>
<span>(</span><span>uri:Â str, filepath:Â str, filename:Â str, allow_for_missing_files:Â bool, post_process_function:Â Callable[[str],Â Optional[bool]], download_function:Â Callable[[str,Â str],Â Optional[bool]]Â =Â &lt;function do_nothing&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Data class for Cache miss.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass()
class CacheMiss:
    &#34;&#34;&#34;
    Data class for Cache miss.
    &#34;&#34;&#34;
    uri: str
    filepath: str
    filename: str
    allow_for_missing_files: bool
    post_process_function: Callable[[str], Optional[bool]]
    download_function: Callable[[str, str], Optional[bool]] = do_nothing</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.CacheMiss.allow_for_missing_files"><code class="name">var <span class="ident">allow_for_missing_files</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.CacheMiss.filename"><code class="name">var <span class="ident">filename</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.CacheMiss.filepath"><code class="name">var <span class="ident">filepath</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.CacheMiss.post_process_function"><code class="name">var <span class="ident">post_process_function</span> :Â Callable[[str],Â Optional[bool]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.CacheMiss.uri"><code class="name">var <span class="ident">uri</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.CacheMiss.download_function"><code class="name flex">
<span>def <span class="ident">download_function</span></span>(<span>*arg, **kwargs) â€‘>Â Optional[bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Null function for convenience.</p>
<p>:param arg:
:param kwargs:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_nothing(*arg, **kwargs) -&gt; Optional[bool]:
    &#34;&#34;&#34;
    Null function for convenience.

    :param arg:
    :param kwargs:
    :return:
    &#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache"><code class="flex name class">
<span>class <span class="ident">FileCache</span></span>
<span>(</span><span>path:Â strÂ =Â '~/temporary_roguewave_files/filecache/', size_GB:Â Union[float,Â int]Â =Â 5, do_cache_eviction_on_startup:Â boolÂ =Â False, resources:Â Optional[List[<a title="ocean_science_utilities.filecache.remote_resources.RemoteResource" href="remote_resources.html#ocean_science_utilities.filecache.remote_resources.RemoteResource">RemoteResource</a>]]Â =Â None, parallel:Â boolÂ =Â True, allow_for_missing_files:Â boolÂ =Â True)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple file caching class that when given an URI locally stores the
file in the cache directory and returns the path to the file. The file
remains in storage until the cache directory exceeds a prescribed size,
in which case files with oldest access/modified dates get deleted first
until everything fits in the cache again. Any time a file is accessed it's
modified date gets updated so that often used files automaticall remain in
cache.</p>
<p>The files are stored locally in the directory specified on class
initialization, as:</p>
<pre><code>[path]/CACHE_PREFIX + md5_hash_of_URI + CACHE_POSTFIX
</code></pre>
<p>The pre- and post fix are added so we have an easy pattern to distinguish
cache files from other files.</p>
<p>Methods
* <strong>getitem</strong>(keys) : accept a simgle uri_key or a list of URI's and
returns filepaths to local copies thereof. You would typically use the
cache[keys] notation instead of the dunder method.
* purge() clear all contents of the cache (destructive, deletes all local
files).</p>
<h2 id="usage">Usage</h2>
<p>cache = FileCache()
list_of_local_file_names = cache[ [list of URI's ] ]</p>
<h1 id="do-stuff-with-file">do stuff with file</h1>
<p>&hellip;</p>
<p>Initialize Cache
:param path: path to store cache. If path does not exist it will be
created.
:param size_GB: Maximum size of the cache in GiB. If cache exceeds
the size, then files with oldest access/modified dates get deleted
until everthing fits in the cache again. Fractional values (floats)
are allowed.
:param do_cache_eviction_on_startup: whether we ensure the cache size
conforms to the given size on startup. If set to true, a cache
directory that exceeds the maximum size will be reduced to max
size. Set to False by default in which case an error occurs. The
latter to prevent eroneously evicting files from a cache that was
previously created on purpose with a larger size that the limit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileCache:
    &#34;&#34;&#34;
    Simple file caching class that when given an URI locally stores the
    file in the cache directory and returns the path to the file. The file
    remains in storage until the cache directory exceeds a prescribed size,
    in which case files with oldest access/modified dates get deleted first
    until everything fits in the cache again. Any time a file is accessed it&#39;s
    modified date gets updated so that often used files automaticall remain in
    cache.

    The files are stored locally in the directory specified on class
    initialization, as:

        [path]/CACHE_PREFIX + md5_hash_of_URI + CACHE_POSTFIX

    The pre- and post fix are added so we have an easy pattern to distinguish
    cache files from other files.

    Methods
      * __getitem__(keys) : accept a simgle uri_key or a list of URI&#39;s and
        returns filepaths to local copies thereof. You would typically use the
            cache[keys] notation instead of the dunder method.
      * purge() clear all contents of the cache (destructive, deletes all local
        files).

    Usage:

        cache = FileCache()
        list_of_local_file_names = cache[ [list of URI&#39;s ] ]

    # do stuff with file
    ...
    &#34;&#34;&#34;

    CACHE_FILE_PREFIX = &#34;cachefile_&#34;
    CACHE_FILE_POSTFIX = &#34;_cachefile&#34;

    def __init__(
        self,
        path: str = TEMPORARY_DIRECTORY,
        size_GB: Union[float, int] = CACHE_SIZE_GB,
        do_cache_eviction_on_startup: bool = False,
        resources: Optional[List[RemoteResource]] = None,
        parallel: bool = True,
        allow_for_missing_files: bool = True,
    ):
        &#34;&#34;&#34;
        Initialize Cache
        :param path: path to store cache. If path does not exist it will be
            created.
        :param size_GB: Maximum size of the cache in GiB. If cache exceeds
            the size, then files with oldest access/modified dates get deleted
            until everthing fits in the cache again. Fractional values (floats)
            are allowed.
        :param do_cache_eviction_on_startup: whether we ensure the cache size
            conforms to the given size on startup. If set to true, a cache
            directory that exceeds the maximum size will be reduced to max
            size. Set to False by default in which case an error occurs. The
            latter to prevent eroneously evicting files from a cache that was
            previously created on purpose with a larger size that the limit.


        &#34;&#34;&#34;
        self.path = os.path.expanduser(path)
        # create the path if it does not exist
        if not os.path.exists(path):
            os.makedirs(path, exist_ok=True)

        self.config = FileCacheConfig(size_GB, parallel, allow_for_missing_files, path)

        # Some counters to keep track of total cache misses, hits and
        # evictions. No downstream use right now/
        self._cache_misses = 0
        self._cache_hits = 0
        self._cache_evictions = 0
        self.disable_progress_bar = False

        # initialize the cache.
        self._entries: Dict[str, str] = {}  # the key/value pair cache
        self._initialize_cache(do_cache_eviction_on_startup)

        # Post processing and validation functions
        self.directives: Dict[str, Dict[str, Callable[[str], Optional[bool]]]] = {
            &#34;validate&#34;: {},
            &#34;postprocess&#34;: {},
        }

        # message to display on progress bar
        self.description = &#34;Caching&#34;

        # download resources
        if resources is None:
            self.resources = [
                RemoteResourceHTTPS(),
                RemoteResourceLocal(),
            ]
        else:
            self.resources = resources

    def set_directive_function(
        self,
        directive,
        name,
        function: Callable[[str], Optional[bool]],
    ):
        &#34;&#34;&#34;
        AI is creating summary for set_directive_function

        Args:
            directive ([type]): [description]
            name ([type]): [description]
            function (Callable[[str], Optional[bool]]): [description]

        Raises:
            KeyError: [description]
            ValueError: [description]
        &#34;&#34;&#34;
        if directive not in self.directives:
            raise KeyError(f&#34;{directive} is not a valid cache directive.&#34;)

        if name in self.directives[directive]:
            raise ValueError(f&#34;Function  for {name} already exists&#34;)
        else:
            self.directives[directive][name] = function

    def remove_directive_function(self, directive: str, name: str):
        if directive not in self.directives:
            raise KeyError(f&#34;{directive} is not a valid cache directive.&#34;)

        if name not in self.directives[directive]:
            raise ValueError(f&#34;Function  for {name} does not exist&#34;)
        else:
            self.directives[directive].pop(name)

    def _cache_file_name(self, uri: str) -&gt; str:
        &#34;&#34;&#34;
        Return the filename that corresponds to the given uri. We construct
        the file name using a simple md5 hash of the uri string prefixed
        with a cache file prefix. THe later is introduced to seperate cache
        files in a path from user files (and avoid including/deleting those).

        :param uri: valid uri stripped from directives
        :return: valid cache file
        &#34;&#34;&#34;
        return self.CACHE_FILE_PREFIX + _hashname(uri) + self.CACHE_FILE_POSTFIX

    def _cache_file_path(self, uri: str) -&gt; str:
        &#34;&#34;&#34;
        Construct the path where the given uri is stored locally.

        :param uri: valid uri stripped from directives.
        :return: valid cache file
        &#34;&#34;&#34;
        return os.path.join(self.path, self._cache_file_name(uri))

    def _get_cache_files(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Find all files that are currently a member of the cache.
        :return:
        &#34;&#34;&#34;
        for path, dirs, files in os.walk(self.path):
            # Return all files that are &#34;cache&#34; objects. This is a safety if
            # other user files are present, so that these don&#39;t accidentally
            # evicted from the cache (aka deleted).
            return [
                file
                for file in files
                if file.startswith(self.CACHE_FILE_PREFIX)
                and file.endswith(self.CACHE_FILE_POSTFIX)
            ]
        else:
            return []

    def _initialize_cache(self, do_cache_eviction_on_startup: bool) -&gt; None:
        &#34;&#34;&#34;
        Initialize the file cache. Look on disk for files in the cache path
        that have the required prefix and load these into the cache. Once
        loaded, we do a check whether or not the cache is full and if we need
        to remove files.
        :param do_cache_eviction_on_startup: see description under __init__
        :return:
        &#34;&#34;&#34;
        self._entries = {}
        for file in self._get_cache_files():
            filepath = os.path.join(self.path, file)
            self._entries[file] = filepath

        # See if cache is still &lt; size
        if do_cache_eviction_on_startup:
            self._cache_eviction()
        else:
            if self._size() &gt; self.config.max_size_bytes:
                raise ValueError(
                    &#34;The cache currently existing on disk &#34;
                    &#34;exceeds the maximum cache size of the &#34;
                    f&#34;current cache ({self.config.max_size} gb).&#34;
                    f&#34;\n The cache size can be increased by&#34;
                    f&#34; editting the cache config file: &#34;
                    f&#34;{self.config.name}&#34;
                )

    def in_cache(self, unparsed_uris) -&gt; List[bool]:
        # make sure input is a list
        if isinstance(unparsed_uris, str):
            unparsed_uris = [unparsed_uris]

        uris, _ = parse_directives(unparsed_uris)

        # Create the hashes from the URI&#39;s
        hashes = [self._cache_file_name(uri) for uri in uris]
        return [self._is_in_cache(_hash) for _hash in hashes]

    def _is_in_cache(self, _hash: str) -&gt; bool:
        &#34;&#34;&#34;
        Check if a _hash is in the cache
        :param _hash: hash to check
        :return: True if in Cache, False if not.
        &#34;&#34;&#34;
        cache_hit = _hash in self._entries
        return cache_hit

    def _add_to_cache(self, _hash: str, filepath: str) -&gt; None:
        # add entry to the cache.
        self._entries[_hash] = filepath

    def remove(self, unparsed_uri: str) -&gt; None:
        &#34;&#34;&#34;
        Remove an entry from the cache
        :param unparsed_uri: uri
        :return: None
        &#34;&#34;&#34;
        uri, _ = parse_directive(unparsed_uri)

        if not self.in_cache(uri):
            raise ValueError(f&#34;Key {uri} not in Cache&#34;)

        _hash = self._cache_file_name(uri)
        return self._remove_item_from_cache(_hash)

    def _remove_item_from_cache(self, _hash: str) -&gt; None:
        &#34;&#34;&#34;
        Remove a hash key from the cache. Here it is assumed that the _hash is
        a valid entry. We do allow for non existance of corresponding files as
        the cache can get out of sync if something external deleted the file.
        Since the endstate is valid (no entry in cache, no entry on disk) this
        is considered OK.

        :param _hash: hash key
        :return: None
        &#34;&#34;&#34;

        if _hash not in self._entries:
            return None

        file_to_delete = self._entries.pop(_hash)

        if os.path.exists(file_to_delete):
            logger.debug(f&#34; - removing {_hash}&#34;)

            # And delete file.
            os.remove(file_to_delete)
        else:
            logger.debug(f&#34; - file {_hash} did not exist on disk&#34;)

        return None

    def _get_from_cache(self, _hash: str) -&gt; str:
        &#34;&#34;&#34;
        Get entry from cache and touch the file to indicate it has been used
        recently (last to be evicted)
        :param _hash: file_hash corresponding to uri
        :return: file path
        &#34;&#34;&#34;
        filepath = self._entries[_hash]

        if not os.path.exists(filepath):
            raise FileNotFoundError(
                &#34;The filepath in the cache log does not&#34; &#34;exist on disk.&#34;
            )

        # Touch the file to indicate we recently used it.
        Path(filepath).touch()

        return filepath

    def get_cache_misses(
        self, uris: List[str], directives: List[Dict[str, str]]
    ) -&gt; List[CacheMiss]:
        &#34;&#34;&#34;
        Function to get all cache misses and return a list of CacheMiss objects
        needed to download the misses from remote resources.

        This function also perform validates on potential cache hits if a
        relevant validation function is set *and* validation is requested
        through a directive.

        :param uris: list of uris stripped of directives
        :param directives: list of directives per uri (empty dict if none)
        :return: list of cache misses
        &#34;&#34;&#34;

        cache_misses = []
        for uri, directive in zip(uris, directives):
            # what is the hashkey/filename
            hashkey = self._cache_file_name(uri)
            filepath = self._cache_file_path(uri)

            # is the key in cache?
            valid_entry: Optional[bool] = False
            if self._is_in_cache(hashkey):
                # If so is it a valid entry
                if &#34;validate&#34; in directive:
                    # Call the user supplied validation function with the
                    # filepath as argument
                    validation_function = self.directives[&#34;validate&#34;][
                        directive[&#34;validate&#34;]
                    ]

                    try:
                        valid_entry = validation_function(filepath)
                    except IOError:
                        valid_entry = False

                    if not valid_entry:
                        # remove the locally stored entry if not valid
                        os.remove(filepath)
                    else:
                        valid_entry = True
                else:
                    # Defaults to True if no validation directive is given
                    valid_entry = True

            if not valid_entry:
                # If not a valid entry (either missing or invalid)
                #
                if &#34;postprocess&#34; in directive:
                    # Add the postprocess function to use if requested.
                    post_process_function = self.directives[&#34;postprocess&#34;][
                        directive[&#34;postprocess&#34;]
                    ]

                else:
                    # otherwise set a null function as postprocessor
                    post_process_function = do_nothing

                # Remove any comments to the URI used to make it unique
                uri_to_download = uri.split(&#34;&lt;&lt;&#34;)[0]

                cache_misses.append(
                    CacheMiss(
                        uri=uri_to_download,
                        filepath=filepath,
                        filename=hashkey,
                        allow_for_missing_files=self.config.allow_for_missing_files,
                        post_process_function=post_process_function,
                    )
                )
        return cache_misses

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        :return: Number of entries in the cache.
        &#34;&#34;&#34;
        return len(self._entries)

    def __getitem__(self, unparsed_uris: Union[List, str]) -&gt; List[str]:
        &#34;&#34;&#34;
        Get filenames corresponding to locally stored versions of the objects
        the URI points to. Note that the unparsed_uris take the form:

        [ directive=option ; ... directive=option ] &#34;:&#34;
        [scheme] &#34;://&#34; [path] &#34;&gt;&gt;&#34; [comment]

        e.g for amazon s3 where we want to perform validation and post
            processing on entries:

            validate=grib;postprocess=grib:s3://bucket/key

        or without cache directives

            s3://bucket/key

        Cache directives are optional, but if specified the corresponding
        user defined handling function must have been set. By default no
        validation or postprocessing functions are set.

        In addition, we can add a &#34;comment&#34; to the uri by appending
        &#34;&gt;&gt;[comment]&#34;, e.g.

            s3://bucket/key&gt;&gt;THISISTHECOMMENT

        The comment (including &#34;&gt;&gt;&#34;) is stripped prior to downloading from
        the remote resource. However, the comment part *is* included in
        generation of the hash. This allows us to cache the same resource with
        different names. This is primarily useful if we potentially apply
        different postprocessing functions to the same remote resource.

        :param unparsed_uris: URI&#39;s that may still include directives.
        :return:
        &#34;&#34;&#34;
        # make sure input is a list
        if isinstance(unparsed_uris, str):
            unparsed_uris = [unparsed_uris]

        # Remove cache directives from uris (if included)
        uris, directives = parse_directives(unparsed_uris)
        filepaths = [self._cache_file_path(uri) for uri in uris]

        # for all URI&#39;s not in cache
        if cache_misses := self.get_cache_misses(uris, directives):
            was_succesfully_downloaded = _download_from_resources(
                cache_misses,
                self.resources,
                parallel_download=self.config.parallel,
                disable_progress_bar=self.disable_progress_bar,
                desc=self.description,
            )

            for cache_miss, success in zip(cache_misses, was_succesfully_downloaded):
                if success:
                    self._add_to_cache(cache_miss.filename, cache_miss.filepath)
                else:
                    index = filepaths.index(cache_miss.filepath)
                    filepaths.pop(index)

        size_of_requested_data = _get_total_size_of_files_in_bytes(filepaths)
        if size_of_requested_data &gt; self.config.max_size_bytes:
            warning = (
                f&#34;The requested data does not fit into the cache.&#34;
                f&#34;To avoid issues the cache is enlarged to ensure&#34;
                f&#34;the current set of files fits in the cache. \n&#34;
                f&#34;old size: {self.config.max_size_bytes} bytes; &#34;
                f&#34;new size {size_of_requested_data + MEGABYTE}&#34;
            )
            warn(warning)
            logger.warning(warning)
            self.config.max_size_bytes = size_of_requested_data + MEGABYTE

        self._cache_misses += len(cache_misses)
        self._cache_hits += len(uris) - len(cache_misses)

        # See if we need to do any cache eviction because the cache has become
        # to big.
        if not len(cache_misses) == 0:
            self._cache_eviction()

        return filepaths

    def _cache_eviction(self) -&gt; bool:
        &#34;&#34;&#34;
        Simple cache eviction policy. If the cache exceeds the maximum size
        remove data from the cache based on whichever file was interacted with
        the longest time ago. Evict files until we are below the acceptable
        cache size.

        :return: True if eviction occured, False otherwise.
        &#34;&#34;&#34;

        # check if we exceed the size, if not return
        if not self._size() &gt; self.config.max_size_bytes:
            return False

        # Get access/modified times for all the files in cache
        modified = []
        for _hash, fp in self._entries.items():
            # From my brief reading, access time is not always reliable,
            # hence I use whatever the latest time set is for modified or
            # access time as an indicator of when we last interacted with
            # the file.
            access_time = os.path.getatime(fp)
            modified_time = os.path.getmtime(fp)

            # pick whichever is most recent.
            time_to_check = (
                access_time if access_time &gt; modified_time else modified_time
            )
            modified.append((time_to_check, _hash))

        # Sort files in reversed chronological order.
        files_in_cache = [
            x[1] for x in sorted(modified, key=lambda x: x[0], reverse=True)
        ]

        # Delete files one by one as long as the cache_size exceeds the max
        # size.
        while (_size := self._size()) &gt; self.config.max_size_bytes:
            self._cache_evictions += 1
            logger.debug(
                f&#34;Cache exceeds limits: {_size} bytes, max size: &#34;
                f&#34;{self.config.max_size_bytes} bytes&#34;
            )

            # Get the hash and path of the oldest file and remove
            self._remove_item_from_cache(files_in_cache.pop())

        return True

    def _size(self) -&gt; int:
        &#34;&#34;&#34;
        Return size on disk of the cache in bytes.
        :return: cache size in bytes.
        &#34;&#34;&#34;
        return _get_total_size_of_files_in_bytes(
            list(self._entries.values()), self.path
        )

    def purge(self) -&gt; None:
        &#34;&#34;&#34;
        Delete all the files in the cache.
        :return: None
        &#34;&#34;&#34;
        logger.debug(&#34;Purging cache&#34;)
        keys = list(self._entries.keys())
        for key in keys:
            filepath = self._entries.pop(key)
            logger.debug(&#34; - deleting {filepath}&#34;)
            os.remove(filepath)
        logger.debug(&#34;Purging cache done&#34;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.CACHE_FILE_POSTFIX"><code class="name">var <span class="ident">CACHE_FILE_POSTFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.CACHE_FILE_PREFIX"><code class="name">var <span class="ident">CACHE_FILE_PREFIX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.get_cache_misses"><code class="name flex">
<span>def <span class="ident">get_cache_misses</span></span>(<span>self, uris:Â List[str], directives:Â List[Dict[str,Â str]]) â€‘>Â List[<a title="ocean_science_utilities.filecache.cache_object.CacheMiss" href="#ocean_science_utilities.filecache.cache_object.CacheMiss">CacheMiss</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all cache misses and return a list of CacheMiss objects
needed to download the misses from remote resources.</p>
<p>This function also perform validates on potential cache hits if a
relevant validation function is set <em>and</em> validation is requested
through a directive.</p>
<p>:param uris: list of uris stripped of directives
:param directives: list of directives per uri (empty dict if none)
:return: list of cache misses</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cache_misses(
    self, uris: List[str], directives: List[Dict[str, str]]
) -&gt; List[CacheMiss]:
    &#34;&#34;&#34;
    Function to get all cache misses and return a list of CacheMiss objects
    needed to download the misses from remote resources.

    This function also perform validates on potential cache hits if a
    relevant validation function is set *and* validation is requested
    through a directive.

    :param uris: list of uris stripped of directives
    :param directives: list of directives per uri (empty dict if none)
    :return: list of cache misses
    &#34;&#34;&#34;

    cache_misses = []
    for uri, directive in zip(uris, directives):
        # what is the hashkey/filename
        hashkey = self._cache_file_name(uri)
        filepath = self._cache_file_path(uri)

        # is the key in cache?
        valid_entry: Optional[bool] = False
        if self._is_in_cache(hashkey):
            # If so is it a valid entry
            if &#34;validate&#34; in directive:
                # Call the user supplied validation function with the
                # filepath as argument
                validation_function = self.directives[&#34;validate&#34;][
                    directive[&#34;validate&#34;]
                ]

                try:
                    valid_entry = validation_function(filepath)
                except IOError:
                    valid_entry = False

                if not valid_entry:
                    # remove the locally stored entry if not valid
                    os.remove(filepath)
                else:
                    valid_entry = True
            else:
                # Defaults to True if no validation directive is given
                valid_entry = True

        if not valid_entry:
            # If not a valid entry (either missing or invalid)
            #
            if &#34;postprocess&#34; in directive:
                # Add the postprocess function to use if requested.
                post_process_function = self.directives[&#34;postprocess&#34;][
                    directive[&#34;postprocess&#34;]
                ]

            else:
                # otherwise set a null function as postprocessor
                post_process_function = do_nothing

            # Remove any comments to the URI used to make it unique
            uri_to_download = uri.split(&#34;&lt;&lt;&#34;)[0]

            cache_misses.append(
                CacheMiss(
                    uri=uri_to_download,
                    filepath=filepath,
                    filename=hashkey,
                    allow_for_missing_files=self.config.allow_for_missing_files,
                    post_process_function=post_process_function,
                )
            )
    return cache_misses</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.in_cache"><code class="name flex">
<span>def <span class="ident">in_cache</span></span>(<span>self, unparsed_uris) â€‘>Â List[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_cache(self, unparsed_uris) -&gt; List[bool]:
    # make sure input is a list
    if isinstance(unparsed_uris, str):
        unparsed_uris = [unparsed_uris]

    uris, _ = parse_directives(unparsed_uris)

    # Create the hashes from the URI&#39;s
    hashes = [self._cache_file_name(uri) for uri in uris]
    return [self._is_in_cache(_hash) for _hash in hashes]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.purge"><code class="name flex">
<span>def <span class="ident">purge</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Delete all the files in the cache.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purge(self) -&gt; None:
    &#34;&#34;&#34;
    Delete all the files in the cache.
    :return: None
    &#34;&#34;&#34;
    logger.debug(&#34;Purging cache&#34;)
    keys = list(self._entries.keys())
    for key in keys:
        filepath = self._entries.pop(key)
        logger.debug(&#34; - deleting {filepath}&#34;)
        os.remove(filepath)
    logger.debug(&#34;Purging cache done&#34;)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, unparsed_uri:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an entry from the cache
:param unparsed_uri: uri
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove(self, unparsed_uri: str) -&gt; None:
    &#34;&#34;&#34;
    Remove an entry from the cache
    :param unparsed_uri: uri
    :return: None
    &#34;&#34;&#34;
    uri, _ = parse_directive(unparsed_uri)

    if not self.in_cache(uri):
        raise ValueError(f&#34;Key {uri} not in Cache&#34;)

    _hash = self._cache_file_name(uri)
    return self._remove_item_from_cache(_hash)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.remove_directive_function"><code class="name flex">
<span>def <span class="ident">remove_directive_function</span></span>(<span>self, directive:Â str, name:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_directive_function(self, directive: str, name: str):
    if directive not in self.directives:
        raise KeyError(f&#34;{directive} is not a valid cache directive.&#34;)

    if name not in self.directives[directive]:
        raise ValueError(f&#34;Function  for {name} does not exist&#34;)
    else:
        self.directives[directive].pop(name)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCache.set_directive_function"><code class="name flex">
<span>def <span class="ident">set_directive_function</span></span>(<span>self, directive, name, function:Â Callable[[str],Â Optional[bool]])</span>
</code></dt>
<dd>
<div class="desc"><p>AI is creating summary for set_directive_function</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directive</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
<dt><strong><code>function</code></strong> :&ensp;<code>Callable[[str], Optional[bool]]</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>KeyError</code></dt>
<dd>[description]</dd>
<dt><code>ValueError</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_directive_function(
    self,
    directive,
    name,
    function: Callable[[str], Optional[bool]],
):
    &#34;&#34;&#34;
    AI is creating summary for set_directive_function

    Args:
        directive ([type]): [description]
        name ([type]): [description]
        function (Callable[[str], Optional[bool]]): [description]

    Raises:
        KeyError: [description]
        ValueError: [description]
    &#34;&#34;&#34;
    if directive not in self.directives:
        raise KeyError(f&#34;{directive} is not a valid cache directive.&#34;)

    if name in self.directives[directive]:
        raise ValueError(f&#34;Function  for {name} already exists&#34;)
    else:
        self.directives[directive][name] = function</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig"><code class="flex name class">
<span>class <span class="ident">FileCacheConfig</span></span>
<span>(</span><span>size_gb:Â Union[float,Â int]Â =Â 5, parallel:Â boolÂ =Â True, allow_for_missing_files:Â boolÂ =Â True, path:Â strÂ =Â '~/temporary_roguewave_files/filecache/')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileCacheConfig:
    def __init__(
        self,
        size_gb: Union[float, int] = CACHE_SIZE_GB,
        parallel: bool = True,
        allow_for_missing_files: bool = True,
        path: str = TEMPORARY_DIRECTORY,
    ):
        self.path = path
        self.size_gb = size_gb
        self.parallel = parallel
        self.allow_for_missing_files = allow_for_missing_files

        if self.config_exists():
            self.load_config()
        else:
            self._write_config()

    @property
    def name(self) -&gt; str:
        return os.path.join(self.path, &#34;file_cache_config.json&#34;)

    def config_exists(self) -&gt; bool:
        return os.path.exists(self.name)

    def load_config(self) -&gt; None:
        with open(self.name, &#34;rb&#34;) as fp:
            config = json.load(fp)
            self.size_gb = config[&#34;size_gb&#34;]
            self.parallel = config[&#34;parallel&#34;]
            self.allow_for_missing_files = config[&#34;allow_for_missing_files&#34;]

    def _update_config(self, key, value, write=True):
        self[key] = value
        if write:
            self._write_config()

    def _write_config(self):
        with open(os.path.join(self.path, &#34;file_cache_config.json&#34;), &#34;wt&#34;) as fp:
            fp.write(
                json.dumps(
                    {
                        &#34;size_gb&#34;: self.size_gb,
                        &#34;parallel&#34;: self.parallel,
                        &#34;allow_for_missing_files&#34;: self.allow_for_missing_files,
                    },
                    indent=4,
                )
            )

    @property
    def max_size(self) -&gt; Union[float, int]:
        return self.size_gb

    @max_size.setter
    def max_size(self, size_gb: float):
        self._update_config(&#34;size_gb&#34;, size_gb)

    @property
    def max_size_bytes(self) -&gt; int:
        return int(self.size_gb * GIGABYTE)

    @max_size_bytes.setter
    def max_size_bytes(self, size_bytes: int):
        self._update_config(&#34;size_gb&#34;, size_bytes / GIGABYTE)

    @property
    def parallel(self) -&gt; bool:
        return self.parallel

    @parallel.setter
    def parallel(self, parallel: bool):
        self._update_config(&#34;parallel&#34;, parallel)

    @property
    def allow_for_missing_files(self) -&gt; bool:
        return self.allow_for_missing_files

    @allow_for_missing_files.setter
    def allow_for_missing_files(self, allow_for_missing_files: bool):
        self._update_config(&#34;allow_for_missing_files&#34;, allow_for_missing_files)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig.allow_for_missing_files"><code class="name">var <span class="ident">allow_for_missing_files</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def allow_for_missing_files(self) -&gt; bool:
    return self.allow_for_missing_files</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig.max_size"><code class="name">var <span class="ident">max_size</span> :Â Union[float,Â int]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_size(self) -&gt; Union[float, int]:
    return self.size_gb</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig.max_size_bytes"><code class="name">var <span class="ident">max_size_bytes</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def max_size_bytes(self) -&gt; int:
    return int(self.size_gb * GIGABYTE)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return os.path.join(self.path, &#34;file_cache_config.json&#34;)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig.parallel"><code class="name">var <span class="ident">parallel</span> :Â bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parallel(self) -&gt; bool:
    return self.parallel</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig.config_exists"><code class="name flex">
<span>def <span class="ident">config_exists</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_exists(self) -&gt; bool:
    return os.path.exists(self.name)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.cache_object.FileCacheConfig.load_config"><code class="name flex">
<span>def <span class="ident">load_config</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_config(self) -&gt; None:
    with open(self.name, &#34;rb&#34;) as fp:
        config = json.load(fp)
        self.size_gb = config[&#34;size_gb&#34;]
        self.parallel = config[&#34;parallel&#34;]
        self.allow_for_missing_files = config[&#34;allow_for_missing_files&#34;]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#authors-pieter-bart-smit">Authors: Pieter Bart Smit</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocean_science_utilities.filecache" href="index.html">ocean_science_utilities.filecache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ocean_science_utilities.filecache.cache_object.do_nothing" href="#ocean_science_utilities.filecache.cache_object.do_nothing">do_nothing</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.parse_directive" href="#ocean_science_utilities.filecache.cache_object.parse_directive">parse_directive</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.parse_directives" href="#ocean_science_utilities.filecache.cache_object.parse_directives">parse_directives</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ocean_science_utilities.filecache.cache_object.CacheMiss" href="#ocean_science_utilities.filecache.cache_object.CacheMiss">CacheMiss</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.filecache.cache_object.CacheMiss.allow_for_missing_files" href="#ocean_science_utilities.filecache.cache_object.CacheMiss.allow_for_missing_files">allow_for_missing_files</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.CacheMiss.download_function" href="#ocean_science_utilities.filecache.cache_object.CacheMiss.download_function">download_function</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.CacheMiss.filename" href="#ocean_science_utilities.filecache.cache_object.CacheMiss.filename">filename</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.CacheMiss.filepath" href="#ocean_science_utilities.filecache.cache_object.CacheMiss.filepath">filepath</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.CacheMiss.post_process_function" href="#ocean_science_utilities.filecache.cache_object.CacheMiss.post_process_function">post_process_function</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.CacheMiss.uri" href="#ocean_science_utilities.filecache.cache_object.CacheMiss.uri">uri</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocean_science_utilities.filecache.cache_object.FileCache" href="#ocean_science_utilities.filecache.cache_object.FileCache">FileCache</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.CACHE_FILE_POSTFIX" href="#ocean_science_utilities.filecache.cache_object.FileCache.CACHE_FILE_POSTFIX">CACHE_FILE_POSTFIX</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.CACHE_FILE_PREFIX" href="#ocean_science_utilities.filecache.cache_object.FileCache.CACHE_FILE_PREFIX">CACHE_FILE_PREFIX</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.get_cache_misses" href="#ocean_science_utilities.filecache.cache_object.FileCache.get_cache_misses">get_cache_misses</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.in_cache" href="#ocean_science_utilities.filecache.cache_object.FileCache.in_cache">in_cache</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.purge" href="#ocean_science_utilities.filecache.cache_object.FileCache.purge">purge</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.remove" href="#ocean_science_utilities.filecache.cache_object.FileCache.remove">remove</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.remove_directive_function" href="#ocean_science_utilities.filecache.cache_object.FileCache.remove_directive_function">remove_directive_function</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCache.set_directive_function" href="#ocean_science_utilities.filecache.cache_object.FileCache.set_directive_function">set_directive_function</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig">FileCacheConfig</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig.allow_for_missing_files" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig.allow_for_missing_files">allow_for_missing_files</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig.config_exists" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig.config_exists">config_exists</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig.load_config" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig.load_config">load_config</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig.max_size" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig.max_size">max_size</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig.max_size_bytes" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig.max_size_bytes">max_size_bytes</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig.name" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig.name">name</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.cache_object.FileCacheConfig.parallel" href="#ocean_science_utilities.filecache.cache_object.FileCacheConfig.parallel">parallel</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
