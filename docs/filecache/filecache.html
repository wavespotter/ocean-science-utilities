<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ocean_science_utilities.filecache.filecache API documentation</title>
<meta name="description" content="Contents: Simple file caching routines to interact with a file cache …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocean_science_utilities.filecache.filecache</code></h1>
</header>
<section id="section-intro">
<p>Contents: Simple file caching routines to interact with a file cache.</p>
<p>Copyright (C) 2022
Sofar Ocean Technologies</p>
<h1 id="authors-pieter-bart-smit">Authors: Pieter Bart Smit</h1>
<p>Functions:
- <code><a title="ocean_science_utilities.filecache.filecache.filepaths" href="#ocean_science_utilities.filecache.filecache.filepaths">filepaths()</a></code>, given URI's return a filepath to the locally stored
version
- <code><a title="ocean_science_utilities.filecache.filecache.exists" href="#ocean_science_utilities.filecache.filecache.exists">exists()</a></code>, does a cache with a given name exists
- <code><a title="ocean_science_utilities.filecache.filecache.create_cache" href="#ocean_science_utilities.filecache.filecache.create_cache">create_cache()</a></code>, create a cache with a given name and custom properties.
- <code><a title="ocean_science_utilities.filecache.filecache.delete_cache" href="#ocean_science_utilities.filecache.filecache.delete_cache">delete_cache()</a></code>, delete files associated with the cache.
- <code><a title="ocean_science_utilities.filecache.filecache.delete_default" href="#ocean_science_utilities.filecache.filecache.delete_default">delete_default()</a></code>, delete files associated with the default cache.
- <code><a title="ocean_science_utilities.filecache.filecache.delete_files" href="#ocean_science_utilities.filecache.filecache.delete_files">delete_files()</a></code>, remove entries from a given cache.
- <code>_get_cache</code>, get Cache object corresponding to the name (for internal use
only)</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Contents: Simple file caching routines to interact with a file cache.

Copyright (C) 2022
Sofar Ocean Technologies

Authors: Pieter Bart Smit
======================

Functions:
- `filepaths`, given URI&#39;s return a filepath to the locally stored
   version
- `exists`, does a cache with a given name exists
- `create_cache`, create a cache with a given name and custom properties.
- `delete_cache`, delete files associated with the cache.
- `delete_default`, delete files associated with the default cache.
- `delete_files`, remove entries from a given cache.
- `_get_cache`, get Cache object corresponding to the name (for internal use
   only)
&#34;&#34;&#34;

# Import
# =============================================================================
import os

from typing import Callable, Dict, Iterable, List, Optional, Tuple, Union

from ocean_science_utilities.filecache.cache_object import (
    TEMPORARY_DIRECTORY,
    CACHE_SIZE_GB,
    FileCache,
)
from ocean_science_utilities.filecache.remote_resources import RemoteResource

# Constants
# =============================================================================


DEFAULT_CACHE_NAME = &#34;__default__&#34;

# Private Module Variables
# =============================================================================


# This dictionary contains all instantiated FileCache objects as values and
# the object name as key.
_ACTIVE_FILE_CACHES = {}  # type: Dict[str,FileCache]


# Main public function.
# =============================================================================
def set(name, value, cache_name: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Set cache value.

    :name:
    :value:
    :param cache_name:

    :return: None
    &#34;&#34;&#34;
    cache = get_cache(cache_name)
    setattr(cache, name, value)


def filepaths(
    uris: Union[List[str], str],
    cache_name: Optional[str] = None,
) -&gt; Union[List[str], Tuple[List[str], List[bool]]]:
    &#34;&#34;&#34;
    Return the full file path to locally stored objects corresponding to the given URI.

    :param uris: List of uris, or a single uri
    :param cache_name: name of the cache to use. If None, a default cache will
    be initialized automatically (if not initialized) and used.
    :param return_cache_hits: return whether or not the files were already in
        cache or downloaded from the remote source (cache hit or miss).

    :return: List Absolute paths to the locally stored versions corresponding
        to the list of URI&#39;s. IF return_cache_hits=True, additionally return
        a list of cache hits as the second entry of the return tuple.
    &#34;&#34;&#34;
    return get_cache(cache_name)[uris]


def remove_directive_function(directive: str, name: str, cache_name=None) -&gt; None:
    &#34;&#34;&#34;
    EMPTY Doc String.

    :directive:
    :name:
    :cache_name:

    :return: None
    &#34;&#34;&#34;
    _ = get_cache(cache_name).remove_directive_function(directive, name)


def set_directive_function(
    directive: str,
    name: str,
    post_process_function: Union[Callable[[str], None], Callable[[str], bool]],
    cache_name=None,
) -&gt; None:
    &#34;&#34;&#34;
    EMPTY Doc String.

    :directive:
    :name:
    :post_process_function:
    :cache_name:

    :return: None
    &#34;&#34;&#34;
    _ = get_cache(cache_name).set_directive_function(
        directive, name, post_process_function
    )


def exists(cache_name: str) -&gt; bool:
    &#34;&#34;&#34;
    Check if the cache name already exists.

    :param cache_name: name for the cache to be created. This name is used
            to retrieve files from the cache.
    :return: True if exists, False otherwise
    &#34;&#34;&#34;
    return cache_name in _ACTIVE_FILE_CACHES


def create_cache(
    cache_name: str,
    cache_path: str = TEMPORARY_DIRECTORY,
    cache_size_GB: Union[int, float] = CACHE_SIZE_GB,
    do_cache_eviction_on_startup: bool = False,
    download_in_parallel=True,
    resources: Optional[List[RemoteResource]] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Create a file cache. Created caches *must* have unique names and cache_paths.

    :param cache_name: name for the cache to be created. This name is used
            to retrieve files from the cache.
    :param cache_path: path to store cache. If path does not exist it will be
            created.
    :param cache_size_GB:  Maximum size of the cache in GiB. If cache exceeds
            the size, then files with oldest access/modified dates get deleted
            until everthing fits in the cache again. Fractional values (floats)
            are allowed.
    :param do_cache_eviction_on_startup: do_cache_eviction_on_startup: whether
            we ensure the cache size conforms to the given size on startup.
            If set to true, a cache directory that exceeds the maximum size
            will be reduced to max size. Set to False by default in which case
            an error occurs. The latter to prevent eroneously evicting files
            from a cache that was previously created on purpose with a larger
            size that the limit.
    :param download_in_parallel: Download in paralel from resource. Per default 10
            worker threads are created.

    :return:
    &#34;&#34;&#34;
    cache_path = os.path.abspath(os.path.expanduser(cache_path))

    if cache_name in _ACTIVE_FILE_CACHES:
        raise ValueError(f&#34;Cache with name {cache_name} is already initialized&#34;)

    for key, cache in _ACTIVE_FILE_CACHES.items():
        if cache.path == cache_path:
            raise ValueError(
                f&#34;Error when creating cache with name: &#34;
                f&#39;&#34;{cache_name}&#34;. \n A cache named: &#34;{key}&#34; &#39;
                f&#34;already uses the path {cache_path} &#34;
                f&#34;for caching.\n &#34;
                f&#34;Multiple caches cannot share the same path.&#34;
            )

    _ACTIVE_FILE_CACHES[cache_name] = FileCache(
        cache_path,
        size_GB=cache_size_GB,
        do_cache_eviction_on_startup=do_cache_eviction_on_startup,
        parallel=download_in_parallel,
        resources=resources,
    )
    return


def delete_cache(cache_name):
    &#34;&#34;&#34;
    Delete all files associated with a cache and remove cache from available caches.

    To note: all files are deleted, but the folder itself is not.

    :param cache_name: Name of the cache to be deleted
    :return:
    &#34;&#34;&#34;
    if not exists(cache_name):
        raise ValueError(f&#34;Cache with name {cache_name} does not exist&#34;)

    cache = _ACTIVE_FILE_CACHES.pop(cache_name)
    cache.purge()


def delete_default():
    &#34;&#34;&#34;
    Clean up the default cache.

    :return:
    &#34;&#34;&#34;
    if exists(DEFAULT_CACHE_NAME):
        delete_cache(DEFAULT_CACHE_NAME)


def delete_files(
    uris: Union[str, Iterable[str]],
    cache_name: Optional[str] = None,
    error_if_not_in_cache: bool = True,
) -&gt; None:
    &#34;&#34;&#34;
    Remove given key(s) from the cache.

    :param uris: list of keys to remove
    :param cache_name: name of initialized cache.
    :return:
    &#34;&#34;&#34;
    if not isinstance(uris, Iterable) or isinstance(uris, str):
        uris = [uris]

    cache = get_cache(cache_name)

    for key in uris:
        try:
            cache.remove(key)

        except ValueError as e:
            if error_if_not_in_cache:
                raise e


def get_cache(cache_name: Optional[str]) -&gt; FileCache:
    &#34;&#34;&#34;
    Get a valid cache object, error if the name does not exist.

    :param cache_name: Name of the cache
    :return: Cache object
    &#34;&#34;&#34;
    if cache_name is None:
        cache_name = DEFAULT_CACHE_NAME

    if not exists(cache_name):
        if cache_name == DEFAULT_CACHE_NAME:
            create_cache(cache_name)
        else:
            raise ValueError(f&#34;Cache with name {cache_name} does not exist.&#34;)

    return _ACTIVE_FILE_CACHES[cache_name]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ocean_science_utilities.filecache.filecache.create_cache"><code class="name flex">
<span>def <span class="ident">create_cache</span></span>(<span>cache_name: str, cache_path: str = '~/temporary_roguewave_files/filecache/', cache_size_GB: Union[float, int] = 5, do_cache_eviction_on_startup: bool = False, download_in_parallel=True, resources: Optional[List[<a title="ocean_science_utilities.filecache.remote_resources.RemoteResource" href="remote_resources.html#ocean_science_utilities.filecache.remote_resources.RemoteResource">RemoteResource</a>]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Create a file cache. Created caches <em>must</em> have unique names and cache_paths.</p>
<p>:param cache_name: name for the cache to be created. This name is used
to retrieve files from the cache.
:param cache_path: path to store cache. If path does not exist it will be
created.
:param cache_size_GB:
Maximum size of the cache in GiB. If cache exceeds
the size, then files with oldest access/modified dates get deleted
until everthing fits in the cache again. Fractional values (floats)
are allowed.
:param do_cache_eviction_on_startup: do_cache_eviction_on_startup: whether
we ensure the cache size conforms to the given size on startup.
If set to true, a cache directory that exceeds the maximum size
will be reduced to max size. Set to False by default in which case
an error occurs. The latter to prevent eroneously evicting files
from a cache that was previously created on purpose with a larger
size that the limit.
:param download_in_parallel: Download in paralel from resource. Per default 10
worker threads are created.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_cache(
    cache_name: str,
    cache_path: str = TEMPORARY_DIRECTORY,
    cache_size_GB: Union[int, float] = CACHE_SIZE_GB,
    do_cache_eviction_on_startup: bool = False,
    download_in_parallel=True,
    resources: Optional[List[RemoteResource]] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Create a file cache. Created caches *must* have unique names and cache_paths.

    :param cache_name: name for the cache to be created. This name is used
            to retrieve files from the cache.
    :param cache_path: path to store cache. If path does not exist it will be
            created.
    :param cache_size_GB:  Maximum size of the cache in GiB. If cache exceeds
            the size, then files with oldest access/modified dates get deleted
            until everthing fits in the cache again. Fractional values (floats)
            are allowed.
    :param do_cache_eviction_on_startup: do_cache_eviction_on_startup: whether
            we ensure the cache size conforms to the given size on startup.
            If set to true, a cache directory that exceeds the maximum size
            will be reduced to max size. Set to False by default in which case
            an error occurs. The latter to prevent eroneously evicting files
            from a cache that was previously created on purpose with a larger
            size that the limit.
    :param download_in_parallel: Download in paralel from resource. Per default 10
            worker threads are created.

    :return:
    &#34;&#34;&#34;
    cache_path = os.path.abspath(os.path.expanduser(cache_path))

    if cache_name in _ACTIVE_FILE_CACHES:
        raise ValueError(f&#34;Cache with name {cache_name} is already initialized&#34;)

    for key, cache in _ACTIVE_FILE_CACHES.items():
        if cache.path == cache_path:
            raise ValueError(
                f&#34;Error when creating cache with name: &#34;
                f&#39;&#34;{cache_name}&#34;. \n A cache named: &#34;{key}&#34; &#39;
                f&#34;already uses the path {cache_path} &#34;
                f&#34;for caching.\n &#34;
                f&#34;Multiple caches cannot share the same path.&#34;
            )

    _ACTIVE_FILE_CACHES[cache_name] = FileCache(
        cache_path,
        size_GB=cache_size_GB,
        do_cache_eviction_on_startup=do_cache_eviction_on_startup,
        parallel=download_in_parallel,
        resources=resources,
    )
    return</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.delete_cache"><code class="name flex">
<span>def <span class="ident">delete_cache</span></span>(<span>cache_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete all files associated with a cache and remove cache from available caches.</p>
<p>To note: all files are deleted, but the folder itself is not.</p>
<p>:param cache_name: Name of the cache to be deleted
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_cache(cache_name):
    &#34;&#34;&#34;
    Delete all files associated with a cache and remove cache from available caches.

    To note: all files are deleted, but the folder itself is not.

    :param cache_name: Name of the cache to be deleted
    :return:
    &#34;&#34;&#34;
    if not exists(cache_name):
        raise ValueError(f&#34;Cache with name {cache_name} does not exist&#34;)

    cache = _ACTIVE_FILE_CACHES.pop(cache_name)
    cache.purge()</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.delete_default"><code class="name flex">
<span>def <span class="ident">delete_default</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Clean up the default cache.</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_default():
    &#34;&#34;&#34;
    Clean up the default cache.

    :return:
    &#34;&#34;&#34;
    if exists(DEFAULT_CACHE_NAME):
        delete_cache(DEFAULT_CACHE_NAME)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.delete_files"><code class="name flex">
<span>def <span class="ident">delete_files</span></span>(<span>uris: Union[str, Iterable[str]], cache_name: Optional[str] = None, error_if_not_in_cache: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove given key(s) from the cache.</p>
<p>:param uris: list of keys to remove
:param cache_name: name of initialized cache.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_files(
    uris: Union[str, Iterable[str]],
    cache_name: Optional[str] = None,
    error_if_not_in_cache: bool = True,
) -&gt; None:
    &#34;&#34;&#34;
    Remove given key(s) from the cache.

    :param uris: list of keys to remove
    :param cache_name: name of initialized cache.
    :return:
    &#34;&#34;&#34;
    if not isinstance(uris, Iterable) or isinstance(uris, str):
        uris = [uris]

    cache = get_cache(cache_name)

    for key in uris:
        try:
            cache.remove(key)

        except ValueError as e:
            if error_if_not_in_cache:
                raise e</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>cache_name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the cache name already exists.</p>
<p>:param cache_name: name for the cache to be created. This name is used
to retrieve files from the cache.
:return: True if exists, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exists(cache_name: str) -&gt; bool:
    &#34;&#34;&#34;
    Check if the cache name already exists.

    :param cache_name: name for the cache to be created. This name is used
            to retrieve files from the cache.
    :return: True if exists, False otherwise
    &#34;&#34;&#34;
    return cache_name in _ACTIVE_FILE_CACHES</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.filepaths"><code class="name flex">
<span>def <span class="ident">filepaths</span></span>(<span>uris: Union[List[str], str], cache_name: Optional[str] = None) ‑> Union[List[str], Tuple[List[str], List[bool]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the full file path to locally stored objects corresponding to the given URI.</p>
<p>:param uris: List of uris, or a single uri
:param cache_name: name of the cache to use. If None, a default cache will
be initialized automatically (if not initialized) and used.
:param return_cache_hits: return whether or not the files were already in
cache or downloaded from the remote source (cache hit or miss).</p>
<p>:return: List Absolute paths to the locally stored versions corresponding
to the list of URI's. IF return_cache_hits=True, additionally return
a list of cache hits as the second entry of the return tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filepaths(
    uris: Union[List[str], str],
    cache_name: Optional[str] = None,
) -&gt; Union[List[str], Tuple[List[str], List[bool]]]:
    &#34;&#34;&#34;
    Return the full file path to locally stored objects corresponding to the given URI.

    :param uris: List of uris, or a single uri
    :param cache_name: name of the cache to use. If None, a default cache will
    be initialized automatically (if not initialized) and used.
    :param return_cache_hits: return whether or not the files were already in
        cache or downloaded from the remote source (cache hit or miss).

    :return: List Absolute paths to the locally stored versions corresponding
        to the list of URI&#39;s. IF return_cache_hits=True, additionally return
        a list of cache hits as the second entry of the return tuple.
    &#34;&#34;&#34;
    return get_cache(cache_name)[uris]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.get_cache"><code class="name flex">
<span>def <span class="ident">get_cache</span></span>(<span>cache_name: Optional[str]) ‑> <a title="ocean_science_utilities.filecache.cache_object.FileCache" href="cache_object.html#ocean_science_utilities.filecache.cache_object.FileCache">FileCache</a></span>
</code></dt>
<dd>
<div class="desc"><p>Get a valid cache object, error if the name does not exist.</p>
<p>:param cache_name: Name of the cache
:return: Cache object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cache(cache_name: Optional[str]) -&gt; FileCache:
    &#34;&#34;&#34;
    Get a valid cache object, error if the name does not exist.

    :param cache_name: Name of the cache
    :return: Cache object
    &#34;&#34;&#34;
    if cache_name is None:
        cache_name = DEFAULT_CACHE_NAME

    if not exists(cache_name):
        if cache_name == DEFAULT_CACHE_NAME:
            create_cache(cache_name)
        else:
            raise ValueError(f&#34;Cache with name {cache_name} does not exist.&#34;)

    return _ACTIVE_FILE_CACHES[cache_name]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.remove_directive_function"><code class="name flex">
<span>def <span class="ident">remove_directive_function</span></span>(<span>directive: str, name: str, cache_name=None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>EMPTY Doc String.</p>
<p>:directive:
:name:
:cache_name:</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_directive_function(directive: str, name: str, cache_name=None) -&gt; None:
    &#34;&#34;&#34;
    EMPTY Doc String.

    :directive:
    :name:
    :cache_name:

    :return: None
    &#34;&#34;&#34;
    _ = get_cache(cache_name).remove_directive_function(directive, name)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>name, value, cache_name: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Set cache value.</p>
<p>:name:
:value:
:param cache_name:</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(name, value, cache_name: Optional[str] = None) -&gt; None:
    &#34;&#34;&#34;
    Set cache value.

    :name:
    :value:
    :param cache_name:

    :return: None
    &#34;&#34;&#34;
    cache = get_cache(cache_name)
    setattr(cache, name, value)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.filecache.filecache.set_directive_function"><code class="name flex">
<span>def <span class="ident">set_directive_function</span></span>(<span>directive: str, name: str, post_process_function: Union[Callable[[str], None], Callable[[str], bool]], cache_name=None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>EMPTY Doc String.</p>
<p>:directive:
:name:
:post_process_function:
:cache_name:</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_directive_function(
    directive: str,
    name: str,
    post_process_function: Union[Callable[[str], None], Callable[[str], bool]],
    cache_name=None,
) -&gt; None:
    &#34;&#34;&#34;
    EMPTY Doc String.

    :directive:
    :name:
    :post_process_function:
    :cache_name:

    :return: None
    &#34;&#34;&#34;
    _ = get_cache(cache_name).set_directive_function(
        directive, name, post_process_function
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#authors-pieter-bart-smit">Authors: Pieter Bart Smit</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocean_science_utilities.filecache" href="index.html">ocean_science_utilities.filecache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ocean_science_utilities.filecache.filecache.create_cache" href="#ocean_science_utilities.filecache.filecache.create_cache">create_cache</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.delete_cache" href="#ocean_science_utilities.filecache.filecache.delete_cache">delete_cache</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.delete_default" href="#ocean_science_utilities.filecache.filecache.delete_default">delete_default</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.delete_files" href="#ocean_science_utilities.filecache.filecache.delete_files">delete_files</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.exists" href="#ocean_science_utilities.filecache.filecache.exists">exists</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.filepaths" href="#ocean_science_utilities.filecache.filecache.filepaths">filepaths</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.get_cache" href="#ocean_science_utilities.filecache.filecache.get_cache">get_cache</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.remove_directive_function" href="#ocean_science_utilities.filecache.filecache.remove_directive_function">remove_directive_function</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.set" href="#ocean_science_utilities.filecache.filecache.set">set</a></code></li>
<li><code><a title="ocean_science_utilities.filecache.filecache.set_directive_function" href="#ocean_science_utilities.filecache.filecache.set_directive_function">set_directive_function</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
