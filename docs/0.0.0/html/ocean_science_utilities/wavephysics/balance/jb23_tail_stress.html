<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ocean_science_utilities.wavephysics.balance.jb23_tail_stress API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocean_science_utilities.wavephysics.balance.jb23_tail_stress</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numba  # type: ignore
import numpy as np

from typing import Dict, Mapping, Tuple, Union
from ocean_science_utilities.wavephysics.balance._numba_settings import numba_default
from ocean_science_utilities.wavephysics.balance.solvers import numba_newton_raphson


@numba.jit(**numba_default)
def tail_stress_parametrization_jb23(
    variance_density: np.ndarray,
    wind: Tuple[np.ndarray, np.ndarray, str],
    depth: np.ndarray,
    roughness_length: np.ndarray,
    spectral_grid: Dict[str, np.ndarray],
    parameters: Mapping,
) -&gt; Tuple[Union[float, np.ndarray], Union[float, np.ndarray]]:
    vonkarman_constant = parameters[&#34;vonkarman_constant&#34;]
    radian_direction = spectral_grid[&#34;radian_direction&#34;]
    elevation = parameters[&#34;elevation&#34;]

    number_of_frequencies, number_of_directions = variance_density.shape
    direction_step = spectral_grid[&#34;direction_step&#34;]

    wind_forcing, wind_direction_degrees, wind_forcing_type = wind
    wind_direction_radian = wind_direction_degrees * np.pi / 180
    cosine_mutual_angle = np.cos(radian_direction - wind_direction_radian)
    cosine = np.cos(radian_direction)
    sine = np.sin(radian_direction)

    if wind_forcing_type == &#34;u10&#34;:
        friction_velocity = (
            wind_forcing * vonkarman_constant / np.log(elevation / roughness_length)
        )

    elif wind_forcing_type in [&#34;ustar&#34;, &#34;friction_velocity&#34;]:
        friction_velocity = wind_forcing

    else:
        raise ValueError(&#34;Unknown wind input type&#34;)

    directional_integral = 0.0
    directional_integral_last_bin = 0.0
    directional_integral_last_bin_east = 0.0
    directional_integral_last_bin_north = 0.0
    for direction_index in range(0, number_of_directions):
        if cosine_mutual_angle[direction_index] &lt;= 0.0:
            continue
        directional_integral += (
            variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

        directional_integral_last_bin += (
            cosine_mutual_angle[direction_index] ** 2
            * variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

        directional_integral_last_bin_east += (
            cosine_mutual_angle[direction_index] ** 2
            * cosine[direction_index]
            * variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

        directional_integral_last_bin_north += (
            cosine_mutual_angle[direction_index] ** 2
            * sine[direction_index]
            * variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

    if directional_integral_last_bin &gt; 0.0:
        stress_east_fac = (
            directional_integral_last_bin_east / directional_integral_last_bin
        )
        stress_north_fac = (
            directional_integral_last_bin_north / directional_integral_last_bin
        )
    else:
        stress_east_fac = 1.0
        stress_north_fac = 0.0

    last_resolved_wavenumber = (
        spectral_grid[&#34;radian_frequency&#34;][number_of_frequencies - 1] ** 2
        / parameters[&#34;gravitational_acceleration&#34;]
    )

    jacobian_to_wavenumber_density = (
        spectral_grid[&#34;radian_frequency&#34;][number_of_frequencies - 1]
        / last_resolved_wavenumber
        / 4
        / np.pi
    )

    starting_energy_wavenumber_density = (
        directional_integral_last_bin * jacobian_to_wavenumber_density
    )
    wavenumbers = wavenumber_grid(
        last_resolved_wavenumber, roughness_length, friction_velocity, parameters
    )

    if wavenumbers[0] &lt; 0:
        return 0.0, 0.0

    saturation_spectrum = saturation_spectrum_parametrization(
        wavenumbers,
        starting_energy_wavenumber_density,
        last_resolved_wavenumber,
        friction_velocity,
        parameters,
    )

    background_stress = (
        parameters[&#34;charnock_constant&#34;] ** 2
        * friction_velocity**6
        / parameters[&#34;gravitational_acceleration&#34;] ** 2
        / roughness_length**2
    )

    tail_spectrum = saturation_spectrum * wavenumbers ** (-3)
    stress = wind_stress_tail(
        wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters
    )
    integral = (
        np.trapz(stress, wavenumbers) + background_stress * parameters[&#34;air_density&#34;]
    )

    eastward_stress = integral * stress_east_fac

    northward_stress = integral * stress_north_fac

    return eastward_stress, northward_stress


# --------------------------------
# Janssen and Bidlot 2022
# --------------------------------
@numba.jit(**numba_default)
def wind_stress_tail(
    wavenumbers,
    roughness_length,
    friction_velocity,
    tail_spectrum,
    parameters,
):
    windinput = wind_input_tail(
        wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters
    )

    angular_frequency = dispersion(
        wavenumbers,
        parameters[&#34;gravitational_acceleration&#34;],
        parameters[&#34;surface_tension&#34;],
    )

    stress = np.empty(wavenumbers.shape[0])
    for wavenumber_index in range(0, wavenumbers.shape[0]):
        stress[wavenumber_index] = (
            angular_frequency[wavenumber_index] * windinput[wavenumber_index]
        )

    return stress * parameters[&#34;water_density&#34;]


# ----
# Helper functions Integration domains
# ----
@numba.jit(**numba_default)
def log_bounds_wavenumber(roughness_length, friction_velocity, parameters):
    &#34;&#34;&#34;
    Find the lower bound of the integration domain for JB2022.

    :param friction_velocity:
    :param effective_charnock:
    :param vonkarman_constant:
    :param wave_age_tuning_parameter:
    :param gravitational_acceleration:
    :return:
    &#34;&#34;&#34;

    args = (roughness_length, friction_velocity, parameters)

    if friction_velocity &lt;= 0.0:
        return np.array((-np.inf, -np.inf))

    # Wavenumber where miles_mu has a minimum value.
    miles_max_val_wavenumber = np.log(
        parameters[&#34;vonkarman_constant&#34;] ** 2
        * parameters[&#34;gravitational_acceleration&#34;]
        / 4
        / friction_velocity**2
    )

    if (
        miles_mu_cutoff(
            miles_max_val_wavenumber, roughness_length, friction_velocity, parameters
        )
        &gt; 0.0
    ):
        # Not solvable. Essentially zero stress interval.
        return np.array((-np.inf, -np.inf))

    # find the right root
    log_upper_bound = numba_newton_raphson(
        miles_mu_cutoff,
        np.log(1.1 / roughness_length),
        args,
        (miles_max_val_wavenumber, np.log(1 / roughness_length)),
        verbose=False,
        name=&#34;log bound wavenumber 1&#34;,
    )

    guess = miles_max_val_wavenumber - 1

    # find the left root
    while True:
        log_lower_bound = numba_newton_raphson(
            miles_mu_cutoff,
            guess,
            args,
            (-np.inf, miles_max_val_wavenumber),
            verbose=False,
            name=&#34;log bound wavenumber 3&#34;,
        )
        if log_lower_bound &lt; log_upper_bound * 0.98:
            break
        else:
            guess = guess - 1

    return np.array([log_lower_bound, log_upper_bound])


# ----
# Helper functions growth parameter
# ----
@numba.jit(**numba_default)
def miles_mu(log_wavenumber, roughness_length, friction_velocity, parameters):
    vonkarman_constant = parameters[&#34;vonkarman_constant&#34;]
    wave_age_tuning_parameter = parameters[&#34;wave_age_tuning_parameter&#34;]
    gravitational_acceleration = parameters[&#34;gravitational_acceleration&#34;]
    surface_tension = parameters[&#34;surface_tension&#34;]

    wavenumber = np.exp(log_wavenumber)
    wavespeed = celerity(wavenumber, gravitational_acceleration, surface_tension)

    return (
        log_wavenumber
        + np.log(roughness_length)
        + vonkarman_constant
        / (friction_velocity / wavespeed + wave_age_tuning_parameter)
    )


@numba.jit(**numba_default)
def miles_mu_cutoff(log_wavenumber, roughness_length, friction_velocity, parameters):
    return miles_mu(
        log_wavenumber, roughness_length, friction_velocity, parameters
    ) - np.log(1 + 0.25 * np.tanh(4 * friction_velocity**4))


@numba.jit(**numba_default)
def wind_input_tail(
    wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters
):
    vonkarman_constant = parameters[&#34;vonkarman_constant&#34;]
    growth_parameter_betamax = parameters[&#34;growth_parameter_betamax&#34;]

    non_linear_effect_strength = parameters[&#34;non_linear_effect_strength&#34;]

    number_of_wavenumbers = wavenumbers.shape[0]
    windinput = np.empty(number_of_wavenumbers)

    mu = miles_mu(np.log(wavenumbers), roughness_length, friction_velocity, parameters)

    epsilon = parameters[&#34;air_density&#34;] / parameters[&#34;water_density&#34;]

    wave_speed = celerity(
        wavenumbers,
        parameters[&#34;gravitational_acceleration&#34;],
        parameters[&#34;surface_tension&#34;],
    )  # parameters[&#34;surface_tension&#34;])
    angular_frequency = dispersion(
        wavenumbers,
        parameters[&#34;gravitational_acceleration&#34;],
        parameters[&#34;surface_tension&#34;],
    )

    miles_cutoff = np.log(1 + 0.25 * np.tanh(4 * friction_velocity**4))
    for wavenumber_index in range(0, number_of_wavenumbers):
        if mu[wavenumber_index] &gt; miles_cutoff:
            windinput[wavenumber_index] = 0.0
            continue

        linear_growth_parameter = (
            angular_frequency[wavenumber_index]
            * mu[wavenumber_index] ** 4
            * np.exp(mu[wavenumber_index])
            * growth_parameter_betamax
            / vonkarman_constant**2
            * epsilon
            * friction_velocity**2
            / wave_speed[wavenumber_index] ** 2
        )

        N2 = (
            non_linear_effect_strength
            * tail_spectrum[wavenumber_index]
            * linear_growth_parameter
            * wavenumbers[wavenumber_index] ** 2
            / vonkarman_constant
            / epsilon
            / friction_velocity
        )
        N1 = N2 / 6.0
        nonlinear_correction = (1.0 + N1) / (1.0 + N2)
        growth_parameter = linear_growth_parameter * nonlinear_correction

        windinput[wavenumber_index] = growth_parameter * tail_spectrum[wavenumber_index]

    return windinput


# ----
# Helper functions spectral parametrization tail
# ----


@numba.jit(**numba_default)
def wavenumber_grid(
    starting_wavenumber, roughness_length, friction_velocity, parameters
):
    log_starting_wavenumber = np.log(starting_wavenumber)
    log_bounds = log_bounds_wavenumber(roughness_length, friction_velocity, parameters)

    if log_bounds[0] &lt; log_starting_wavenumber:
        log_bounds[0] = log_starting_wavenumber

    if log_bounds[1] &lt; log_starting_wavenumber:
        # Numba does not handle multiple returns well. Here I return a len 1
        # np.array with a negative wavenumber to signal that there is no valid
        # wavenumber grid
        return np.array([-1.0])

    # After Lenain and Melville, 2017
    log_upper_bound_eq_range = np.log(
        upper_limit_wavenumber_equilibrium_range(friction_velocity, parameters)
    )

    # Starting wave number where we switch on 3-wave interactions.
    log_three_wave_start = np.log(
        three_wave_starting_wavenumber(friction_velocity, parameters)
    )

    has_eq_range = log_bounds[0] &lt; log_upper_bound_eq_range
    has_constant_range = (
        log_bounds[0] &lt; log_three_wave_start
        and log_bounds[1] &gt; log_upper_bound_eq_range
    )
    has_cap_range = log_bounds[1] &gt; log_three_wave_start

    if has_eq_range:
        high = np.min(np.array((log_upper_bound_eq_range, log_bounds[1])))
        low = log_bounds[0]
        wavenumber = np.linspace(low, high, 50)
    else:
        wavenumber = np.zeros((1,))
        wavenumber[0] = log_bounds[0]

    if has_constant_range:
        high = np.min(np.array((log_three_wave_start, log_bounds[1])))
        low = wavenumber[-1]
        wavenumber = np.concatenate((wavenumber[:-1], np.linspace(low, high, 50)))

    if has_cap_range:
        high = log_bounds[1]
        low = wavenumber[-1]
        wavenumber = np.concatenate((wavenumber[:-1], np.linspace(low, high, 50)))

    return np.exp(wavenumber)


@numba.jit(**numba_default)
def saturation_spectrum_parametrization(
    wavenumbers,
    energy_at_starting_wavenumber,
    starting_wavenumber,
    friction_velocity,
    parameters,
):
    &#34;&#34;&#34;
    Saturation spectrum accordin to the VIERS model (adapted from JB2023)

    :param wavenumbers: set of wavenumbers
    :param energy_at_starting_wavenumber: variance density as a function of wavenumber,
        scaled such that int(e(k) dk = variance. This varies from Peter&#39;s work who uses
        an energy E such that e = E*k with k the wavenumber which originates from a
        transfer to polar coordinates of the 2d wavenumber spectrum.

    :param gravitational_acceleration: gravitational
    :param surface_tension:
    :param friction_velocity:
    :return:
    &#34;&#34;&#34;

    gravitational_acceleration = parameters[&#34;gravitational_acceleration&#34;]
    surface_tension = parameters[&#34;surface_tension&#34;]

    # After Lenain and Melville, 2017
    upper_bound_eq_range = 0.01 * gravitational_acceleration / friction_velocity**2

    # Starting wave number where we switch on 3-wave interactions.
    three_wave_start = three_wave_starting_wavenumber(friction_velocity, parameters)

    number_of_wavenumbers = wavenumbers.shape[0]
    saturation_spectrum = np.empty(number_of_wavenumbers)

    # Saturation in the &#34;saturation range&#34;, we assume a k**-3 spectrum here (f**-5)
    saturation_at_start_of_eq_range = (
        energy_at_starting_wavenumber * starting_wavenumber**3
    )

    #
    if starting_wavenumber &lt; upper_bound_eq_range:
        saturation_at_end_of_eq_range = saturation_at_start_of_eq_range * np.sqrt(
            upper_bound_eq_range / starting_wavenumber
        )

    else:
        saturation_at_end_of_eq_range = saturation_at_start_of_eq_range

    # Strength of the 3-wave interactin parameter. This is directly taken from the
    # VIERS work - as it was not specified what was used in JB23.
    strength_three_wave_interactions = (
        3
        * np.pi
        / 16
        * (np.tanh(2 * (np.sqrt(wavenumbers / three_wave_start) - 1)) + 1)
    )

    # Strength at the point where we turn on the interactions
    strength_three_wave_interactions_start = 3 * np.pi / 16

    energy_flux_at_boundary = (
        strength_three_wave_interactions
        * saturation_at_end_of_eq_range**2
        * celerity(three_wave_start, gravitational_acceleration, surface_tension) ** 4
        / group_velocity(three_wave_start, gravitational_acceleration, surface_tension)
    )

    if surface_tension &gt; 0.0:
        k0 = np.sqrt(gravitational_acceleration / surface_tension)
    else:
        k0 = np.inf

    c0 = (gravitational_acceleration * surface_tension) ** (1 / 4)
    for wavenumber_index in range(number_of_wavenumbers):
        if wavenumbers[wavenumber_index] &lt; upper_bound_eq_range:
            # In the eq. range the saturation spectrum goes as np.sqrt(k)
            saturation_spectrum[
                wavenumber_index
            ] = saturation_at_start_of_eq_range * np.sqrt(
                wavenumbers[wavenumber_index] / starting_wavenumber
            )

        elif (
            wavenumbers[wavenumber_index] &gt;= upper_bound_eq_range
            and wavenumbers[wavenumber_index] &lt; three_wave_start
        ):
            # Constant saturation region
            saturation_spectrum[wavenumber_index] = saturation_at_end_of_eq_range

        elif wavenumbers[wavenumber_index] &gt;= three_wave_start:
            # Region where three-wave interactions play a role
            scaling_constant = np.sqrt(
                energy_flux_at_boundary[wavenumber_index]
                / 2
                # strength_three_wave_interactions[wavenumber_index]
                / strength_three_wave_interactions_start
            ) * c0 ** (-3 / 2)

            y = wavenumbers[wavenumber_index] / k0
            saturation_spectrum[wavenumber_index] = (
                scaling_constant
                * y
                * np.sqrt(1 + 3 * y**2)
                / ((1 + y**2) * (y + y**3) ** (1 / 4))
            )

    return saturation_spectrum


@numba.jit(**numba_default)
def upper_limit_wavenumber_equilibrium_range(friction_velocity, parameters):
    &#34;&#34;&#34;
    Upper limit eq. range
    :param gravitational_acceleration:
    :param surface_tension:
    :param friction_velocity:
    :return:
    &#34;&#34;&#34;

    return 0.01 * parameters[&#34;gravitational_acceleration&#34;] / friction_velocity**2


@numba.jit(**numba_default)
def three_wave_starting_wavenumber(friction_velocity, parameters):
    &#34;&#34;&#34;
    Starting wavenumber for the capilary-gravity part. See JB2023, eq 41 and 42.
    :param gravitational_acceleration:
    :param surface_tension:
    :param friction_velocity:
    :return:
    &#34;&#34;&#34;
    if parameters[&#34;surface_tension&#34;] == 0.0:
        return np.inf
    return (
        np.sqrt(
            parameters[&#34;gravitational_acceleration&#34;] / parameters[&#34;surface_tension&#34;]
        )
        * 1
        / (1.48 + 2.05 * friction_velocity)
    )


# ----
# Helper functions grav. cap. waves
# ----
@numba.jit(**numba_default)
def dispersion(wavenumber, gravitational_acceleration, surface_tension):
    return np.sqrt(
        gravitational_acceleration * wavenumber + surface_tension * wavenumber**3
    )


@numba.jit(**numba_default)
def celerity(wavenumber, gravitational_acceleration, surface_tension):
    return np.sqrt(
        gravitational_acceleration / wavenumber + surface_tension * wavenumber
    )


@numba.jit(**numba_default)
def group_velocity(wavenumber, gravitational_acceleration, surface_tension):
    return (
        1.0
        / 2.0
        * (gravitational_acceleration + 3 * surface_tension * wavenumber**2)
        / np.sqrt(
            gravitational_acceleration * wavenumber + surface_tension * wavenumber**3
        )
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.celerity"><code class="name flex">
<span>def <span class="ident">celerity</span></span>(<span>wavenumber, gravitational_acceleration, surface_tension)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def celerity(wavenumber, gravitational_acceleration, surface_tension):
    return np.sqrt(
        gravitational_acceleration / wavenumber + surface_tension * wavenumber
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.dispersion"><code class="name flex">
<span>def <span class="ident">dispersion</span></span>(<span>wavenumber, gravitational_acceleration, surface_tension)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def dispersion(wavenumber, gravitational_acceleration, surface_tension):
    return np.sqrt(
        gravitational_acceleration * wavenumber + surface_tension * wavenumber**3
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.group_velocity"><code class="name flex">
<span>def <span class="ident">group_velocity</span></span>(<span>wavenumber, gravitational_acceleration, surface_tension)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def group_velocity(wavenumber, gravitational_acceleration, surface_tension):
    return (
        1.0
        / 2.0
        * (gravitational_acceleration + 3 * surface_tension * wavenumber**2)
        / np.sqrt(
            gravitational_acceleration * wavenumber + surface_tension * wavenumber**3
        )
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.log_bounds_wavenumber"><code class="name flex">
<span>def <span class="ident">log_bounds_wavenumber</span></span>(<span>roughness_length, friction_velocity, parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the lower bound of the integration domain for JB2022.</p>
<p>:param friction_velocity:
:param effective_charnock:
:param vonkarman_constant:
:param wave_age_tuning_parameter:
:param gravitational_acceleration:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def log_bounds_wavenumber(roughness_length, friction_velocity, parameters):
    &#34;&#34;&#34;
    Find the lower bound of the integration domain for JB2022.

    :param friction_velocity:
    :param effective_charnock:
    :param vonkarman_constant:
    :param wave_age_tuning_parameter:
    :param gravitational_acceleration:
    :return:
    &#34;&#34;&#34;

    args = (roughness_length, friction_velocity, parameters)

    if friction_velocity &lt;= 0.0:
        return np.array((-np.inf, -np.inf))

    # Wavenumber where miles_mu has a minimum value.
    miles_max_val_wavenumber = np.log(
        parameters[&#34;vonkarman_constant&#34;] ** 2
        * parameters[&#34;gravitational_acceleration&#34;]
        / 4
        / friction_velocity**2
    )

    if (
        miles_mu_cutoff(
            miles_max_val_wavenumber, roughness_length, friction_velocity, parameters
        )
        &gt; 0.0
    ):
        # Not solvable. Essentially zero stress interval.
        return np.array((-np.inf, -np.inf))

    # find the right root
    log_upper_bound = numba_newton_raphson(
        miles_mu_cutoff,
        np.log(1.1 / roughness_length),
        args,
        (miles_max_val_wavenumber, np.log(1 / roughness_length)),
        verbose=False,
        name=&#34;log bound wavenumber 1&#34;,
    )

    guess = miles_max_val_wavenumber - 1

    # find the left root
    while True:
        log_lower_bound = numba_newton_raphson(
            miles_mu_cutoff,
            guess,
            args,
            (-np.inf, miles_max_val_wavenumber),
            verbose=False,
            name=&#34;log bound wavenumber 3&#34;,
        )
        if log_lower_bound &lt; log_upper_bound * 0.98:
            break
        else:
            guess = guess - 1

    return np.array([log_lower_bound, log_upper_bound])</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.miles_mu"><code class="name flex">
<span>def <span class="ident">miles_mu</span></span>(<span>log_wavenumber, roughness_length, friction_velocity, parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def miles_mu(log_wavenumber, roughness_length, friction_velocity, parameters):
    vonkarman_constant = parameters[&#34;vonkarman_constant&#34;]
    wave_age_tuning_parameter = parameters[&#34;wave_age_tuning_parameter&#34;]
    gravitational_acceleration = parameters[&#34;gravitational_acceleration&#34;]
    surface_tension = parameters[&#34;surface_tension&#34;]

    wavenumber = np.exp(log_wavenumber)
    wavespeed = celerity(wavenumber, gravitational_acceleration, surface_tension)

    return (
        log_wavenumber
        + np.log(roughness_length)
        + vonkarman_constant
        / (friction_velocity / wavespeed + wave_age_tuning_parameter)
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.miles_mu_cutoff"><code class="name flex">
<span>def <span class="ident">miles_mu_cutoff</span></span>(<span>log_wavenumber, roughness_length, friction_velocity, parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def miles_mu_cutoff(log_wavenumber, roughness_length, friction_velocity, parameters):
    return miles_mu(
        log_wavenumber, roughness_length, friction_velocity, parameters
    ) - np.log(1 + 0.25 * np.tanh(4 * friction_velocity**4))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.saturation_spectrum_parametrization"><code class="name flex">
<span>def <span class="ident">saturation_spectrum_parametrization</span></span>(<span>wavenumbers, energy_at_starting_wavenumber, starting_wavenumber, friction_velocity, parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Saturation spectrum accordin to the VIERS model (adapted from JB2023)</p>
<p>:param wavenumbers: set of wavenumbers
:param energy_at_starting_wavenumber: variance density as a function of wavenumber,
scaled such that int(e(k) dk = variance. This varies from Peter's work who uses
an energy E such that e = E*k with k the wavenumber which originates from a
transfer to polar coordinates of the 2d wavenumber spectrum.</p>
<p>:param gravitational_acceleration: gravitational
:param surface_tension:
:param friction_velocity:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def saturation_spectrum_parametrization(
    wavenumbers,
    energy_at_starting_wavenumber,
    starting_wavenumber,
    friction_velocity,
    parameters,
):
    &#34;&#34;&#34;
    Saturation spectrum accordin to the VIERS model (adapted from JB2023)

    :param wavenumbers: set of wavenumbers
    :param energy_at_starting_wavenumber: variance density as a function of wavenumber,
        scaled such that int(e(k) dk = variance. This varies from Peter&#39;s work who uses
        an energy E such that e = E*k with k the wavenumber which originates from a
        transfer to polar coordinates of the 2d wavenumber spectrum.

    :param gravitational_acceleration: gravitational
    :param surface_tension:
    :param friction_velocity:
    :return:
    &#34;&#34;&#34;

    gravitational_acceleration = parameters[&#34;gravitational_acceleration&#34;]
    surface_tension = parameters[&#34;surface_tension&#34;]

    # After Lenain and Melville, 2017
    upper_bound_eq_range = 0.01 * gravitational_acceleration / friction_velocity**2

    # Starting wave number where we switch on 3-wave interactions.
    three_wave_start = three_wave_starting_wavenumber(friction_velocity, parameters)

    number_of_wavenumbers = wavenumbers.shape[0]
    saturation_spectrum = np.empty(number_of_wavenumbers)

    # Saturation in the &#34;saturation range&#34;, we assume a k**-3 spectrum here (f**-5)
    saturation_at_start_of_eq_range = (
        energy_at_starting_wavenumber * starting_wavenumber**3
    )

    #
    if starting_wavenumber &lt; upper_bound_eq_range:
        saturation_at_end_of_eq_range = saturation_at_start_of_eq_range * np.sqrt(
            upper_bound_eq_range / starting_wavenumber
        )

    else:
        saturation_at_end_of_eq_range = saturation_at_start_of_eq_range

    # Strength of the 3-wave interactin parameter. This is directly taken from the
    # VIERS work - as it was not specified what was used in JB23.
    strength_three_wave_interactions = (
        3
        * np.pi
        / 16
        * (np.tanh(2 * (np.sqrt(wavenumbers / three_wave_start) - 1)) + 1)
    )

    # Strength at the point where we turn on the interactions
    strength_three_wave_interactions_start = 3 * np.pi / 16

    energy_flux_at_boundary = (
        strength_three_wave_interactions
        * saturation_at_end_of_eq_range**2
        * celerity(three_wave_start, gravitational_acceleration, surface_tension) ** 4
        / group_velocity(three_wave_start, gravitational_acceleration, surface_tension)
    )

    if surface_tension &gt; 0.0:
        k0 = np.sqrt(gravitational_acceleration / surface_tension)
    else:
        k0 = np.inf

    c0 = (gravitational_acceleration * surface_tension) ** (1 / 4)
    for wavenumber_index in range(number_of_wavenumbers):
        if wavenumbers[wavenumber_index] &lt; upper_bound_eq_range:
            # In the eq. range the saturation spectrum goes as np.sqrt(k)
            saturation_spectrum[
                wavenumber_index
            ] = saturation_at_start_of_eq_range * np.sqrt(
                wavenumbers[wavenumber_index] / starting_wavenumber
            )

        elif (
            wavenumbers[wavenumber_index] &gt;= upper_bound_eq_range
            and wavenumbers[wavenumber_index] &lt; three_wave_start
        ):
            # Constant saturation region
            saturation_spectrum[wavenumber_index] = saturation_at_end_of_eq_range

        elif wavenumbers[wavenumber_index] &gt;= three_wave_start:
            # Region where three-wave interactions play a role
            scaling_constant = np.sqrt(
                energy_flux_at_boundary[wavenumber_index]
                / 2
                # strength_three_wave_interactions[wavenumber_index]
                / strength_three_wave_interactions_start
            ) * c0 ** (-3 / 2)

            y = wavenumbers[wavenumber_index] / k0
            saturation_spectrum[wavenumber_index] = (
                scaling_constant
                * y
                * np.sqrt(1 + 3 * y**2)
                / ((1 + y**2) * (y + y**3) ** (1 / 4))
            )

    return saturation_spectrum</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.tail_stress_parametrization_jb23"><code class="name flex">
<span>def <span class="ident">tail_stress_parametrization_jb23</span></span>(<span>variance_density: numpy.ndarray, wind: Tuple[numpy.ndarray, numpy.ndarray, str], depth: numpy.ndarray, roughness_length: numpy.ndarray, spectral_grid: Dict[str, numpy.ndarray], parameters: Mapping) ‑> Tuple[Union[float, numpy.ndarray], Union[float, numpy.ndarray]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def tail_stress_parametrization_jb23(
    variance_density: np.ndarray,
    wind: Tuple[np.ndarray, np.ndarray, str],
    depth: np.ndarray,
    roughness_length: np.ndarray,
    spectral_grid: Dict[str, np.ndarray],
    parameters: Mapping,
) -&gt; Tuple[Union[float, np.ndarray], Union[float, np.ndarray]]:
    vonkarman_constant = parameters[&#34;vonkarman_constant&#34;]
    radian_direction = spectral_grid[&#34;radian_direction&#34;]
    elevation = parameters[&#34;elevation&#34;]

    number_of_frequencies, number_of_directions = variance_density.shape
    direction_step = spectral_grid[&#34;direction_step&#34;]

    wind_forcing, wind_direction_degrees, wind_forcing_type = wind
    wind_direction_radian = wind_direction_degrees * np.pi / 180
    cosine_mutual_angle = np.cos(radian_direction - wind_direction_radian)
    cosine = np.cos(radian_direction)
    sine = np.sin(radian_direction)

    if wind_forcing_type == &#34;u10&#34;:
        friction_velocity = (
            wind_forcing * vonkarman_constant / np.log(elevation / roughness_length)
        )

    elif wind_forcing_type in [&#34;ustar&#34;, &#34;friction_velocity&#34;]:
        friction_velocity = wind_forcing

    else:
        raise ValueError(&#34;Unknown wind input type&#34;)

    directional_integral = 0.0
    directional_integral_last_bin = 0.0
    directional_integral_last_bin_east = 0.0
    directional_integral_last_bin_north = 0.0
    for direction_index in range(0, number_of_directions):
        if cosine_mutual_angle[direction_index] &lt;= 0.0:
            continue
        directional_integral += (
            variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

        directional_integral_last_bin += (
            cosine_mutual_angle[direction_index] ** 2
            * variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

        directional_integral_last_bin_east += (
            cosine_mutual_angle[direction_index] ** 2
            * cosine[direction_index]
            * variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

        directional_integral_last_bin_north += (
            cosine_mutual_angle[direction_index] ** 2
            * sine[direction_index]
            * variance_density[number_of_frequencies - 1, direction_index]
            * direction_step[direction_index]
        )

    if directional_integral_last_bin &gt; 0.0:
        stress_east_fac = (
            directional_integral_last_bin_east / directional_integral_last_bin
        )
        stress_north_fac = (
            directional_integral_last_bin_north / directional_integral_last_bin
        )
    else:
        stress_east_fac = 1.0
        stress_north_fac = 0.0

    last_resolved_wavenumber = (
        spectral_grid[&#34;radian_frequency&#34;][number_of_frequencies - 1] ** 2
        / parameters[&#34;gravitational_acceleration&#34;]
    )

    jacobian_to_wavenumber_density = (
        spectral_grid[&#34;radian_frequency&#34;][number_of_frequencies - 1]
        / last_resolved_wavenumber
        / 4
        / np.pi
    )

    starting_energy_wavenumber_density = (
        directional_integral_last_bin * jacobian_to_wavenumber_density
    )
    wavenumbers = wavenumber_grid(
        last_resolved_wavenumber, roughness_length, friction_velocity, parameters
    )

    if wavenumbers[0] &lt; 0:
        return 0.0, 0.0

    saturation_spectrum = saturation_spectrum_parametrization(
        wavenumbers,
        starting_energy_wavenumber_density,
        last_resolved_wavenumber,
        friction_velocity,
        parameters,
    )

    background_stress = (
        parameters[&#34;charnock_constant&#34;] ** 2
        * friction_velocity**6
        / parameters[&#34;gravitational_acceleration&#34;] ** 2
        / roughness_length**2
    )

    tail_spectrum = saturation_spectrum * wavenumbers ** (-3)
    stress = wind_stress_tail(
        wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters
    )
    integral = (
        np.trapz(stress, wavenumbers) + background_stress * parameters[&#34;air_density&#34;]
    )

    eastward_stress = integral * stress_east_fac

    northward_stress = integral * stress_north_fac

    return eastward_stress, northward_stress</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.three_wave_starting_wavenumber"><code class="name flex">
<span>def <span class="ident">three_wave_starting_wavenumber</span></span>(<span>friction_velocity, parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Starting wavenumber for the capilary-gravity part. See JB2023, eq 41 and 42.
:param gravitational_acceleration:
:param surface_tension:
:param friction_velocity:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def three_wave_starting_wavenumber(friction_velocity, parameters):
    &#34;&#34;&#34;
    Starting wavenumber for the capilary-gravity part. See JB2023, eq 41 and 42.
    :param gravitational_acceleration:
    :param surface_tension:
    :param friction_velocity:
    :return:
    &#34;&#34;&#34;
    if parameters[&#34;surface_tension&#34;] == 0.0:
        return np.inf
    return (
        np.sqrt(
            parameters[&#34;gravitational_acceleration&#34;] / parameters[&#34;surface_tension&#34;]
        )
        * 1
        / (1.48 + 2.05 * friction_velocity)
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.upper_limit_wavenumber_equilibrium_range"><code class="name flex">
<span>def <span class="ident">upper_limit_wavenumber_equilibrium_range</span></span>(<span>friction_velocity, parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper limit eq. range
:param gravitational_acceleration:
:param surface_tension:
:param friction_velocity:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def upper_limit_wavenumber_equilibrium_range(friction_velocity, parameters):
    &#34;&#34;&#34;
    Upper limit eq. range
    :param gravitational_acceleration:
    :param surface_tension:
    :param friction_velocity:
    :return:
    &#34;&#34;&#34;

    return 0.01 * parameters[&#34;gravitational_acceleration&#34;] / friction_velocity**2</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wavenumber_grid"><code class="name flex">
<span>def <span class="ident">wavenumber_grid</span></span>(<span>starting_wavenumber, roughness_length, friction_velocity, parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def wavenumber_grid(
    starting_wavenumber, roughness_length, friction_velocity, parameters
):
    log_starting_wavenumber = np.log(starting_wavenumber)
    log_bounds = log_bounds_wavenumber(roughness_length, friction_velocity, parameters)

    if log_bounds[0] &lt; log_starting_wavenumber:
        log_bounds[0] = log_starting_wavenumber

    if log_bounds[1] &lt; log_starting_wavenumber:
        # Numba does not handle multiple returns well. Here I return a len 1
        # np.array with a negative wavenumber to signal that there is no valid
        # wavenumber grid
        return np.array([-1.0])

    # After Lenain and Melville, 2017
    log_upper_bound_eq_range = np.log(
        upper_limit_wavenumber_equilibrium_range(friction_velocity, parameters)
    )

    # Starting wave number where we switch on 3-wave interactions.
    log_three_wave_start = np.log(
        three_wave_starting_wavenumber(friction_velocity, parameters)
    )

    has_eq_range = log_bounds[0] &lt; log_upper_bound_eq_range
    has_constant_range = (
        log_bounds[0] &lt; log_three_wave_start
        and log_bounds[1] &gt; log_upper_bound_eq_range
    )
    has_cap_range = log_bounds[1] &gt; log_three_wave_start

    if has_eq_range:
        high = np.min(np.array((log_upper_bound_eq_range, log_bounds[1])))
        low = log_bounds[0]
        wavenumber = np.linspace(low, high, 50)
    else:
        wavenumber = np.zeros((1,))
        wavenumber[0] = log_bounds[0]

    if has_constant_range:
        high = np.min(np.array((log_three_wave_start, log_bounds[1])))
        low = wavenumber[-1]
        wavenumber = np.concatenate((wavenumber[:-1], np.linspace(low, high, 50)))

    if has_cap_range:
        high = log_bounds[1]
        low = wavenumber[-1]
        wavenumber = np.concatenate((wavenumber[:-1], np.linspace(low, high, 50)))

    return np.exp(wavenumber)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wind_input_tail"><code class="name flex">
<span>def <span class="ident">wind_input_tail</span></span>(<span>wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def wind_input_tail(
    wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters
):
    vonkarman_constant = parameters[&#34;vonkarman_constant&#34;]
    growth_parameter_betamax = parameters[&#34;growth_parameter_betamax&#34;]

    non_linear_effect_strength = parameters[&#34;non_linear_effect_strength&#34;]

    number_of_wavenumbers = wavenumbers.shape[0]
    windinput = np.empty(number_of_wavenumbers)

    mu = miles_mu(np.log(wavenumbers), roughness_length, friction_velocity, parameters)

    epsilon = parameters[&#34;air_density&#34;] / parameters[&#34;water_density&#34;]

    wave_speed = celerity(
        wavenumbers,
        parameters[&#34;gravitational_acceleration&#34;],
        parameters[&#34;surface_tension&#34;],
    )  # parameters[&#34;surface_tension&#34;])
    angular_frequency = dispersion(
        wavenumbers,
        parameters[&#34;gravitational_acceleration&#34;],
        parameters[&#34;surface_tension&#34;],
    )

    miles_cutoff = np.log(1 + 0.25 * np.tanh(4 * friction_velocity**4))
    for wavenumber_index in range(0, number_of_wavenumbers):
        if mu[wavenumber_index] &gt; miles_cutoff:
            windinput[wavenumber_index] = 0.0
            continue

        linear_growth_parameter = (
            angular_frequency[wavenumber_index]
            * mu[wavenumber_index] ** 4
            * np.exp(mu[wavenumber_index])
            * growth_parameter_betamax
            / vonkarman_constant**2
            * epsilon
            * friction_velocity**2
            / wave_speed[wavenumber_index] ** 2
        )

        N2 = (
            non_linear_effect_strength
            * tail_spectrum[wavenumber_index]
            * linear_growth_parameter
            * wavenumbers[wavenumber_index] ** 2
            / vonkarman_constant
            / epsilon
            / friction_velocity
        )
        N1 = N2 / 6.0
        nonlinear_correction = (1.0 + N1) / (1.0 + N2)
        growth_parameter = linear_growth_parameter * nonlinear_correction

        windinput[wavenumber_index] = growth_parameter * tail_spectrum[wavenumber_index]

    return windinput</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wind_stress_tail"><code class="name flex">
<span>def <span class="ident">wind_stress_tail</span></span>(<span>wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.jit(**numba_default)
def wind_stress_tail(
    wavenumbers,
    roughness_length,
    friction_velocity,
    tail_spectrum,
    parameters,
):
    windinput = wind_input_tail(
        wavenumbers, roughness_length, friction_velocity, tail_spectrum, parameters
    )

    angular_frequency = dispersion(
        wavenumbers,
        parameters[&#34;gravitational_acceleration&#34;],
        parameters[&#34;surface_tension&#34;],
    )

    stress = np.empty(wavenumbers.shape[0])
    for wavenumber_index in range(0, wavenumbers.shape[0]):
        stress[wavenumber_index] = (
            angular_frequency[wavenumber_index] * windinput[wavenumber_index]
        )

    return stress * parameters[&#34;water_density&#34;]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocean_science_utilities.wavephysics.balance" href="index.html">ocean_science_utilities.wavephysics.balance</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.celerity" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.celerity">celerity</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.dispersion" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.dispersion">dispersion</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.group_velocity" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.group_velocity">group_velocity</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.log_bounds_wavenumber" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.log_bounds_wavenumber">log_bounds_wavenumber</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.miles_mu" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.miles_mu">miles_mu</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.miles_mu_cutoff" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.miles_mu_cutoff">miles_mu_cutoff</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.saturation_spectrum_parametrization" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.saturation_spectrum_parametrization">saturation_spectrum_parametrization</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.tail_stress_parametrization_jb23" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.tail_stress_parametrization_jb23">tail_stress_parametrization_jb23</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.three_wave_starting_wavenumber" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.three_wave_starting_wavenumber">three_wave_starting_wavenumber</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.upper_limit_wavenumber_equilibrium_range" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.upper_limit_wavenumber_equilibrium_range">upper_limit_wavenumber_equilibrium_range</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wavenumber_grid" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wavenumber_grid">wavenumber_grid</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wind_input_tail" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wind_input_tail">wind_input_tail</a></code></li>
<li><code><a title="ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wind_stress_tail" href="#ocean_science_utilities.wavephysics.balance.jb23_tail_stress.wind_stress_tail">wind_stress_tail</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
