<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ocean_science_utilities.interpolate.nd_interp API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocean_science_utilities.interpolate.nd_interp</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

from typing import Any, Tuple, Callable, List, Generator, Set, Optional, Dict, Sequence

from ocean_science_utilities.interpolate.general import interpolation_weights_1d
from ocean_science_utilities.tools.math import wrapped_difference
from ocean_science_utilities.tools.grid import enclosing_points_1d


class NdInterpolator:
    def __init__(
        self,
        get_data: Callable[[List[np.ndarray], List[int]], np.ndarray],
        data_coordinates: Sequence[Tuple[str, np.ndarray[Any, Any]]],
        data_shape: Tuple[int, ...],
        interp_coord_names: List[str],
        interp_index_coord_name: str,
        data_periodic_coordinates: Dict[str, float],
        data_period: Optional[float] = None,
        data_discont: Optional[float] = None,
        nearest_neighbour: bool = False,
    ):
        self.get_data = get_data
        self.coord = [x[0] for x in data_coordinates]
        self.data_shape = data_shape
        self.interp_coord_names = interp_coord_names
        self.interp_index_coord_name = interp_index_coord_name
        self.data_coordinates = data_coordinates
        self.data_periodic_coordinates = data_periodic_coordinates
        self.data_period = data_period
        self.data_discont = data_discont
        self.nearest_neighbour = nearest_neighbour

    @property
    def passive_coordinate_names(self) -&gt; List[str]:
        return [name for name in self.coord if name not in self.interp_coord_names]

    @property
    def passive_coord_dim_indices(self) -&gt; List[int]:
        return [self.coord.index(x) for x in self.passive_coordinate_names]

    @property
    def output_passive_coord_dim_indices(self) -&gt; Tuple[int, ...]:
        indices = list(range(self.output_ndims))
        _ = indices.pop(indices.index(self.output_index_coord_index))
        return tuple(indices)

    @property
    def interp_coord_dim_indices(self) -&gt; List[int]:
        return [self.coord.index(x) for x in self.interp_coord_names]

    @property
    def interp_index_coord_index(self) -&gt; int:
        return self.coord.index(self.interp_index_coord_name)

    def output_shape(self, number_of_points: int) -&gt; np.ndarray:
        output_shape = np.ones(self.output_ndims, dtype=&#34;int32&#34;)
        interpolating_index = self.output_index_coord_index
        passive_ind = self.passive_coord_dim_indices
        jj = 0
        for index in range(self.output_ndims):
            if index == interpolating_index:
                output_shape[index] = number_of_points
            else:
                output_shape[index] = self.data_shape[passive_ind[jj]]
                jj += 1
        return output_shape

    @property
    def output_index_coord_index(self) -&gt; int:
        return int(
            np.searchsorted(
                self.passive_coord_dim_indices, self.interp_index_coord_index
            )
        )

    @property
    def interpolating_coordinates(self) -&gt; List[Tuple[str, np.ndarray]]:
        return [x for x in self.data_coordinates if x[0] in self.interp_coord_names]

    @property
    def output_ndims(self) -&gt; int:
        return self.data_ndims - self.interp_ndims + 1

    @property
    def interp_ndims(self) -&gt; int:
        return len(self.interp_coord_names)

    @property
    def data_ndims(self) -&gt; int:
        return len(self.coord)

    def output_indexing_full(self, slicer: slice) -&gt; Tuple[slice, ...]:
        indicer = [slice(None)] * self.output_ndims
        indicer[self.output_index_coord_index] = slicer
        return tuple(indicer)

    def output_indexing_broadcast(self, slicer: slice) -&gt; Tuple[Any, ...]:
        indicer = [None] * self.output_ndims
        indicer[self.output_index_coord_index] = slicer  # type: ignore
        return tuple(indicer)

    def coordinate_period(self, coordinate_name: str) -&gt; Optional[float]:
        if coordinate_name in self.data_periodic_coordinates:
            return self.data_periodic_coordinates[coordinate_name]
        else:
            return None

    @property
    def data_is_periodic(self) -&gt; bool:
        return self.data_period is not None

    def interpolate(
        self,
        points: Dict[str, np.ndarray],
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;

        :param self:
        :param points:

        :return:
        &#34;&#34;&#34;
        number_points = len(points[self.interp_coord_names[0]])

        # Find indices and weights for the succesive 1d interpolation problems
        indices_1d = np.empty((self.interp_ndims, 2, number_points), dtype=&#34;int64&#34;)

        weights_1d = np.empty((self.interp_ndims, 2, number_points), dtype=&#34;float64&#34;)

        for index, (coordinate_name, coordinate) in enumerate(
            self.interpolating_coordinates
        ):
            period = self.coordinate_period(coordinate_name)
            indices_1d[index, :, :] = enclosing_points_1d(
                coordinate, points[coordinate_name], period=period
            )
            weights_1d[index, :, :] = interpolation_weights_1d(
                coordinate,
                points[coordinate_name],
                indices_1d[index, :, :],
                period=period,
                extrapolate_left=False,
                extrapolate_right=False,
                nearest_neighbour=self.nearest_neighbour,
            )

        if self.data_is_periodic:
            return self._periodic_data_interpolator(
                number_points, indices_1d, weights_1d
            )
        else:
            return self._data_interpolator(number_points, indices_1d, weights_1d)

    def _data_interpolator(
        self, number_points: int, indices_1d: np.ndarray, weights_1d: np.ndarray
    ) -&gt; np.ndarray:
        # We keep a running sum of the weights, if a point is excluded because it
        # contains no data (NaN) the weights will no longer add up to 1 - and we
        # reschale to account for the missing value. This is an easy way to account
        # for interpolation near missing points. Note that if the contribution of
        # missing weights ( 1-weights_sum) exceeds 0.5 - we consider the point
        # invalid.
        output_shape = self.output_shape(number_points)
        weights_sum = np.zeros(output_shape)
        interp_val = np.zeros(output_shape, dtype=np.float64)

        for intp_indices_nd, intp_weight_nd in _next_point(
            self.interp_ndims, indices_1d, weights_1d
        ):
            # Loop over all interpolation points one at a time.
            val = self.get_data(intp_indices_nd, self.interp_coord_dim_indices)

            mask = np.all(
                ~np.isnan(val), axis=self.output_passive_coord_dim_indices
            ) &amp; (intp_weight_nd &gt; 0)

            weights_sum[self.output_indexing_full(mask)] += intp_weight_nd[
                self.output_indexing_broadcast(mask)
            ]

            interp_val[self.output_indexing_full(mask)] += (
                intp_weight_nd[self.output_indexing_broadcast(mask)]
                * val[self.output_indexing_full(mask)]
            )

        with np.errstate(invalid=&#34;ignore&#34;, divide=&#34;ignore&#34;):
            return np.where(weights_sum &gt; 0.5, interp_val / weights_sum, np.nan)

    def _periodic_data_interpolator(
        self, number_points: int, indices_1d: np.ndarray, weights_1d: np.ndarray
    ) -&gt; np.ndarray:
        # We keep a running sum of the weights, if a point is excluded because it
        # contains no data (NaN) the weights will no longer add up to 1 - and we
        # reschale to account for the missing value. This is an easy way to account
        # for interpolation near missing points. Note that if the contribution of
        # missing weights ( 1-weights_sum) exceeds 0.5 - we consider the point
        # invalid.
        output_shape = self.output_shape(number_points)
        weights_sum = np.zeros(output_shape)

        interp_val = np.zeros(output_shape, dtype=np.complex64)
        for intp_indices_nd, intp_weight_nd in _next_point(
            self.interp_ndims, indices_1d, weights_1d
        ):
            # Loop over all interpolation points one at a time.
            to_rad = np.pi * 2 / self.data_period  # type: ignore
            val = np.exp(
                1j
                * self.get_data(intp_indices_nd, self.interp_coord_dim_indices)
                * to_rad
            )

            mask = np.all(~np.isnan(val), axis=self.output_passive_coord_dim_indices)

            weights_sum[self.output_indexing_full(mask)] += intp_weight_nd[
                self.output_indexing_broadcast(mask)
            ]

            interp_val[self.output_indexing_full(mask)] += (
                intp_weight_nd[self.output_indexing_broadcast(mask)]
                * val[self.output_indexing_full(mask)]
            )

        interp_val = (
            np.angle(  # type: ignore
                np.where(weights_sum &gt; 0.5, interp_val / weights_sum, np.nan)
            )
            * self.data_period  # type: ignore
            / np.pi
            / 2
        )

        return wrapped_difference(
            delta=interp_val, period=self.data_period, discont=self.data_period
        )


def _next_point(
    recursion_depth: int, indices_1d: np.ndarray, weights_1d: np.ndarray, *narg
) -&gt; Generator[Tuple[List[np.ndarray], np.ndarray], None, None]:
    &#34;&#34;&#34;
    We are trying to interpolate over N dimensions. In bilinear interpolation
    this means we have to visit 2**N points. If N is known this is most
    clearly expressed as a set of N nested loops:

    J=-1
    for i1 in range(0,2):
        for i2 in range(0,2):
            ...
                for iN in range(0,2):
                    J+=1
                    do stuff for J&#39;th item.

    Here instead, since we do not know N in advance, use a set of recursive
    loops to depth N, where at the final level we yield for each of the 2**N
    points the values of the points and the weights with which they contribute
    to the interpolated value.

    :param recursion_depth:
    :param indices_1d:
    :param weights_1d:
    :param narg: indices from outer recursive loops
    :return: generater function that yields the J&#34;th thing to do stuff with.
    &#34;&#34;&#34;
    number_of_coordinates = indices_1d.shape[0]
    number_of_points = indices_1d.shape[2]

    if recursion_depth &gt; 0:
        # Loop over the n&#39;th coordinate, with
        #    n = number_of_coordinates - recursion_depth
        for ii in range(0, 2):
            # Yield from next recursive loop, add the loop coordinate to the
            # arg of the next call
            arg = (*narg, ii)
            yield from _next_point(recursion_depth - 1, indices_1d, weights_1d, *arg)
    else:
        #
        # Here we construct the &#34;fancy&#34; indexes we will use to grab datavalues.
        indices_nd = []
        weights_nd = np.ones((number_of_points,), dtype=&#34;float64&#34;)
        for index in range(0, number_of_coordinates):
            # get the coordinate index for the current point.
            indices_nd.append(indices_1d[index, narg[index], :])

            # The N-dimensional weight is the multiplication of all weights
            # of the associated 1d problems
            weights_nd *= weights_1d[index, narg[index], :]

        yield indices_nd, weights_nd</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator"><code class="flex name class">
<span>class <span class="ident">NdInterpolator</span></span>
<span>(</span><span>get_data: Callable[[List[numpy.ndarray], List[int]], numpy.ndarray], data_coordinates: Sequence[Tuple[str, numpy.ndarray[Any, Any]]], data_shape: Tuple[int, ...], interp_coord_names: List[str], interp_index_coord_name: str, data_periodic_coordinates: Dict[str, float], data_period: Optional[float] = None, data_discont: Optional[float] = None, nearest_neighbour: bool = False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NdInterpolator:
    def __init__(
        self,
        get_data: Callable[[List[np.ndarray], List[int]], np.ndarray],
        data_coordinates: Sequence[Tuple[str, np.ndarray[Any, Any]]],
        data_shape: Tuple[int, ...],
        interp_coord_names: List[str],
        interp_index_coord_name: str,
        data_periodic_coordinates: Dict[str, float],
        data_period: Optional[float] = None,
        data_discont: Optional[float] = None,
        nearest_neighbour: bool = False,
    ):
        self.get_data = get_data
        self.coord = [x[0] for x in data_coordinates]
        self.data_shape = data_shape
        self.interp_coord_names = interp_coord_names
        self.interp_index_coord_name = interp_index_coord_name
        self.data_coordinates = data_coordinates
        self.data_periodic_coordinates = data_periodic_coordinates
        self.data_period = data_period
        self.data_discont = data_discont
        self.nearest_neighbour = nearest_neighbour

    @property
    def passive_coordinate_names(self) -&gt; List[str]:
        return [name for name in self.coord if name not in self.interp_coord_names]

    @property
    def passive_coord_dim_indices(self) -&gt; List[int]:
        return [self.coord.index(x) for x in self.passive_coordinate_names]

    @property
    def output_passive_coord_dim_indices(self) -&gt; Tuple[int, ...]:
        indices = list(range(self.output_ndims))
        _ = indices.pop(indices.index(self.output_index_coord_index))
        return tuple(indices)

    @property
    def interp_coord_dim_indices(self) -&gt; List[int]:
        return [self.coord.index(x) for x in self.interp_coord_names]

    @property
    def interp_index_coord_index(self) -&gt; int:
        return self.coord.index(self.interp_index_coord_name)

    def output_shape(self, number_of_points: int) -&gt; np.ndarray:
        output_shape = np.ones(self.output_ndims, dtype=&#34;int32&#34;)
        interpolating_index = self.output_index_coord_index
        passive_ind = self.passive_coord_dim_indices
        jj = 0
        for index in range(self.output_ndims):
            if index == interpolating_index:
                output_shape[index] = number_of_points
            else:
                output_shape[index] = self.data_shape[passive_ind[jj]]
                jj += 1
        return output_shape

    @property
    def output_index_coord_index(self) -&gt; int:
        return int(
            np.searchsorted(
                self.passive_coord_dim_indices, self.interp_index_coord_index
            )
        )

    @property
    def interpolating_coordinates(self) -&gt; List[Tuple[str, np.ndarray]]:
        return [x for x in self.data_coordinates if x[0] in self.interp_coord_names]

    @property
    def output_ndims(self) -&gt; int:
        return self.data_ndims - self.interp_ndims + 1

    @property
    def interp_ndims(self) -&gt; int:
        return len(self.interp_coord_names)

    @property
    def data_ndims(self) -&gt; int:
        return len(self.coord)

    def output_indexing_full(self, slicer: slice) -&gt; Tuple[slice, ...]:
        indicer = [slice(None)] * self.output_ndims
        indicer[self.output_index_coord_index] = slicer
        return tuple(indicer)

    def output_indexing_broadcast(self, slicer: slice) -&gt; Tuple[Any, ...]:
        indicer = [None] * self.output_ndims
        indicer[self.output_index_coord_index] = slicer  # type: ignore
        return tuple(indicer)

    def coordinate_period(self, coordinate_name: str) -&gt; Optional[float]:
        if coordinate_name in self.data_periodic_coordinates:
            return self.data_periodic_coordinates[coordinate_name]
        else:
            return None

    @property
    def data_is_periodic(self) -&gt; bool:
        return self.data_period is not None

    def interpolate(
        self,
        points: Dict[str, np.ndarray],
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;

        :param self:
        :param points:

        :return:
        &#34;&#34;&#34;
        number_points = len(points[self.interp_coord_names[0]])

        # Find indices and weights for the succesive 1d interpolation problems
        indices_1d = np.empty((self.interp_ndims, 2, number_points), dtype=&#34;int64&#34;)

        weights_1d = np.empty((self.interp_ndims, 2, number_points), dtype=&#34;float64&#34;)

        for index, (coordinate_name, coordinate) in enumerate(
            self.interpolating_coordinates
        ):
            period = self.coordinate_period(coordinate_name)
            indices_1d[index, :, :] = enclosing_points_1d(
                coordinate, points[coordinate_name], period=period
            )
            weights_1d[index, :, :] = interpolation_weights_1d(
                coordinate,
                points[coordinate_name],
                indices_1d[index, :, :],
                period=period,
                extrapolate_left=False,
                extrapolate_right=False,
                nearest_neighbour=self.nearest_neighbour,
            )

        if self.data_is_periodic:
            return self._periodic_data_interpolator(
                number_points, indices_1d, weights_1d
            )
        else:
            return self._data_interpolator(number_points, indices_1d, weights_1d)

    def _data_interpolator(
        self, number_points: int, indices_1d: np.ndarray, weights_1d: np.ndarray
    ) -&gt; np.ndarray:
        # We keep a running sum of the weights, if a point is excluded because it
        # contains no data (NaN) the weights will no longer add up to 1 - and we
        # reschale to account for the missing value. This is an easy way to account
        # for interpolation near missing points. Note that if the contribution of
        # missing weights ( 1-weights_sum) exceeds 0.5 - we consider the point
        # invalid.
        output_shape = self.output_shape(number_points)
        weights_sum = np.zeros(output_shape)
        interp_val = np.zeros(output_shape, dtype=np.float64)

        for intp_indices_nd, intp_weight_nd in _next_point(
            self.interp_ndims, indices_1d, weights_1d
        ):
            # Loop over all interpolation points one at a time.
            val = self.get_data(intp_indices_nd, self.interp_coord_dim_indices)

            mask = np.all(
                ~np.isnan(val), axis=self.output_passive_coord_dim_indices
            ) &amp; (intp_weight_nd &gt; 0)

            weights_sum[self.output_indexing_full(mask)] += intp_weight_nd[
                self.output_indexing_broadcast(mask)
            ]

            interp_val[self.output_indexing_full(mask)] += (
                intp_weight_nd[self.output_indexing_broadcast(mask)]
                * val[self.output_indexing_full(mask)]
            )

        with np.errstate(invalid=&#34;ignore&#34;, divide=&#34;ignore&#34;):
            return np.where(weights_sum &gt; 0.5, interp_val / weights_sum, np.nan)

    def _periodic_data_interpolator(
        self, number_points: int, indices_1d: np.ndarray, weights_1d: np.ndarray
    ) -&gt; np.ndarray:
        # We keep a running sum of the weights, if a point is excluded because it
        # contains no data (NaN) the weights will no longer add up to 1 - and we
        # reschale to account for the missing value. This is an easy way to account
        # for interpolation near missing points. Note that if the contribution of
        # missing weights ( 1-weights_sum) exceeds 0.5 - we consider the point
        # invalid.
        output_shape = self.output_shape(number_points)
        weights_sum = np.zeros(output_shape)

        interp_val = np.zeros(output_shape, dtype=np.complex64)
        for intp_indices_nd, intp_weight_nd in _next_point(
            self.interp_ndims, indices_1d, weights_1d
        ):
            # Loop over all interpolation points one at a time.
            to_rad = np.pi * 2 / self.data_period  # type: ignore
            val = np.exp(
                1j
                * self.get_data(intp_indices_nd, self.interp_coord_dim_indices)
                * to_rad
            )

            mask = np.all(~np.isnan(val), axis=self.output_passive_coord_dim_indices)

            weights_sum[self.output_indexing_full(mask)] += intp_weight_nd[
                self.output_indexing_broadcast(mask)
            ]

            interp_val[self.output_indexing_full(mask)] += (
                intp_weight_nd[self.output_indexing_broadcast(mask)]
                * val[self.output_indexing_full(mask)]
            )

        interp_val = (
            np.angle(  # type: ignore
                np.where(weights_sum &gt; 0.5, interp_val / weights_sum, np.nan)
            )
            * self.data_period  # type: ignore
            / np.pi
            / 2
        )

        return wrapped_difference(
            delta=interp_val, period=self.data_period, discont=self.data_period
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.data_is_periodic"><code class="name">var <span class="ident">data_is_periodic</span> : bool</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_is_periodic(self) -&gt; bool:
    return self.data_period is not None</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.data_ndims"><code class="name">var <span class="ident">data_ndims</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_ndims(self) -&gt; int:
    return len(self.coord)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_coord_dim_indices"><code class="name">var <span class="ident">interp_coord_dim_indices</span> : List[int]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interp_coord_dim_indices(self) -&gt; List[int]:
    return [self.coord.index(x) for x in self.interp_coord_names]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_index_coord_index"><code class="name">var <span class="ident">interp_index_coord_index</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interp_index_coord_index(self) -&gt; int:
    return self.coord.index(self.interp_index_coord_name)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_ndims"><code class="name">var <span class="ident">interp_ndims</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interp_ndims(self) -&gt; int:
    return len(self.interp_coord_names)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interpolating_coordinates"><code class="name">var <span class="ident">interpolating_coordinates</span> : List[Tuple[str, numpy.ndarray]]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def interpolating_coordinates(self) -&gt; List[Tuple[str, np.ndarray]]:
    return [x for x in self.data_coordinates if x[0] in self.interp_coord_names]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_index_coord_index"><code class="name">var <span class="ident">output_index_coord_index</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output_index_coord_index(self) -&gt; int:
    return int(
        np.searchsorted(
            self.passive_coord_dim_indices, self.interp_index_coord_index
        )
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_ndims"><code class="name">var <span class="ident">output_ndims</span> : int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output_ndims(self) -&gt; int:
    return self.data_ndims - self.interp_ndims + 1</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_passive_coord_dim_indices"><code class="name">var <span class="ident">output_passive_coord_dim_indices</span> : Tuple[int, ...]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output_passive_coord_dim_indices(self) -&gt; Tuple[int, ...]:
    indices = list(range(self.output_ndims))
    _ = indices.pop(indices.index(self.output_index_coord_index))
    return tuple(indices)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.passive_coord_dim_indices"><code class="name">var <span class="ident">passive_coord_dim_indices</span> : List[int]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def passive_coord_dim_indices(self) -&gt; List[int]:
    return [self.coord.index(x) for x in self.passive_coordinate_names]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.passive_coordinate_names"><code class="name">var <span class="ident">passive_coordinate_names</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def passive_coordinate_names(self) -&gt; List[str]:
    return [name for name in self.coord if name not in self.interp_coord_names]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.coordinate_period"><code class="name flex">
<span>def <span class="ident">coordinate_period</span></span>(<span>self, coordinate_name: str) ‑> Optional[float]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coordinate_period(self, coordinate_name: str) -&gt; Optional[float]:
    if coordinate_name in self.data_periodic_coordinates:
        return self.data_periodic_coordinates[coordinate_name]
    else:
        return None</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, points: Dict[str, numpy.ndarray]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>:param self:
:param points:</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(
    self,
    points: Dict[str, np.ndarray],
) -&gt; np.ndarray:
    &#34;&#34;&#34;

    :param self:
    :param points:

    :return:
    &#34;&#34;&#34;
    number_points = len(points[self.interp_coord_names[0]])

    # Find indices and weights for the succesive 1d interpolation problems
    indices_1d = np.empty((self.interp_ndims, 2, number_points), dtype=&#34;int64&#34;)

    weights_1d = np.empty((self.interp_ndims, 2, number_points), dtype=&#34;float64&#34;)

    for index, (coordinate_name, coordinate) in enumerate(
        self.interpolating_coordinates
    ):
        period = self.coordinate_period(coordinate_name)
        indices_1d[index, :, :] = enclosing_points_1d(
            coordinate, points[coordinate_name], period=period
        )
        weights_1d[index, :, :] = interpolation_weights_1d(
            coordinate,
            points[coordinate_name],
            indices_1d[index, :, :],
            period=period,
            extrapolate_left=False,
            extrapolate_right=False,
            nearest_neighbour=self.nearest_neighbour,
        )

    if self.data_is_periodic:
        return self._periodic_data_interpolator(
            number_points, indices_1d, weights_1d
        )
    else:
        return self._data_interpolator(number_points, indices_1d, weights_1d)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_indexing_broadcast"><code class="name flex">
<span>def <span class="ident">output_indexing_broadcast</span></span>(<span>self, slicer: slice) ‑> Tuple[Any, ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_indexing_broadcast(self, slicer: slice) -&gt; Tuple[Any, ...]:
    indicer = [None] * self.output_ndims
    indicer[self.output_index_coord_index] = slicer  # type: ignore
    return tuple(indicer)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_indexing_full"><code class="name flex">
<span>def <span class="ident">output_indexing_full</span></span>(<span>self, slicer: slice) ‑> Tuple[slice, ...]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_indexing_full(self, slicer: slice) -&gt; Tuple[slice, ...]:
    indicer = [slice(None)] * self.output_ndims
    indicer[self.output_index_coord_index] = slicer
    return tuple(indicer)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_shape"><code class="name flex">
<span>def <span class="ident">output_shape</span></span>(<span>self, number_of_points: int) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_shape(self, number_of_points: int) -&gt; np.ndarray:
    output_shape = np.ones(self.output_ndims, dtype=&#34;int32&#34;)
    interpolating_index = self.output_index_coord_index
    passive_ind = self.passive_coord_dim_indices
    jj = 0
    for index in range(self.output_ndims):
        if index == interpolating_index:
            output_shape[index] = number_of_points
        else:
            output_shape[index] = self.data_shape[passive_ind[jj]]
            jj += 1
    return output_shape</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocean_science_utilities.interpolate" href="index.html">ocean_science_utilities.interpolate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator">NdInterpolator</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.coordinate_period" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.coordinate_period">coordinate_period</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.data_is_periodic" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.data_is_periodic">data_is_periodic</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.data_ndims" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.data_ndims">data_ndims</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_coord_dim_indices" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_coord_dim_indices">interp_coord_dim_indices</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_index_coord_index" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_index_coord_index">interp_index_coord_index</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_ndims" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interp_ndims">interp_ndims</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interpolate" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interpolate">interpolate</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interpolating_coordinates" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.interpolating_coordinates">interpolating_coordinates</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_index_coord_index" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_index_coord_index">output_index_coord_index</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_indexing_broadcast" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_indexing_broadcast">output_indexing_broadcast</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_indexing_full" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_indexing_full">output_indexing_full</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_ndims" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_ndims">output_ndims</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_passive_coord_dim_indices" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_passive_coord_dim_indices">output_passive_coord_dim_indices</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_shape" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.output_shape">output_shape</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.passive_coord_dim_indices" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.passive_coord_dim_indices">passive_coord_dim_indices</a></code></li>
<li><code><a title="ocean_science_utilities.interpolate.nd_interp.NdInterpolator.passive_coordinate_names" href="#ocean_science_utilities.interpolate.nd_interp.NdInterpolator.passive_coordinate_names">passive_coordinate_names</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
