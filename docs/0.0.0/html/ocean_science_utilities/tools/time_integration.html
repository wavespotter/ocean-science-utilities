<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ocean_science_utilities.tools.time_integration API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocean_science_utilities.tools.time_integration</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

from numba import njit  # type: ignore
from typing import Tuple, Optional


DEFAULT_ORDER = 4
DEFAULT_N = 1


@njit(cache=True)
def integrate(
    time: np.typing.NDArray,
    signal: np.typing.NDArray,
    order=DEFAULT_ORDER,
    n=DEFAULT_N,
    start_value=0.0,
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    Cumulatively integrate the given discretely sampled signal in time using a
    Newton-Coases like formulation of requested order and layout. Note that higher
    order methods are only used in regions where the timestep is constant across the
    integration stencil- otherwise we fall back to the trapezoidal rule which can
    handle variable timesteps. A small amount of jitter (&lt;1%) in timesteps is permitted
    though (and effectively ignored).

    NOTE: by default we start at 0.0 - which in general means that for a zero-mean
        process we will pick up a random offset that will need to be corracted
        afterwards. (out is not zero-mean).

    :param time: ndarray of length nt containing the elapsed time in seconds.
    :param signal: ndarray of length nt containing the signal to be integrated
    :param order: Order of the returned Newton-Coates integration approximation.
    :param n: number of future points in the integration stencil.
    :param start_value: Starting value of the integrated signal.
    :return: NDARRAY of length nt that contains the integrated signal that starts
        at the requested start_value.
    &#34;&#34;&#34;

    primary_stencil = integration_stencil(order, n)
    primary_stencil_width = len(primary_stencil)

    integrated_signal = np.empty_like(signal)
    integrated_signal[0] = start_value
    integrated_signal[:] = 0.0

    number_of_constant_time_steps = 0
    prev_dt = time[1] - time[0]
    restart = True

    nt = len(signal)
    for ii in range(1, len(signal)):
        curr_dt = time[ii] - time[ii - 1]

        if ii + n - 1 &lt; nt:
            future_dt = time[ii + n - 1] - time[ii + n - 2]
        else:
            future_dt = curr_dt
            restart = True

        if np.abs(future_dt - prev_dt) &gt; 0.01 * curr_dt:
            # Jitter in the timestep, fall back to a lower order method that
            # can handle this.
            restart = True
            number_of_constant_time_steps = 0

        if restart:
            number_of_constant_time_steps += 1
            stencil_width = 2
            stencil = np.array([0.5, 0.5])
            number_of_implicit_points = 1

            if number_of_constant_time_steps == primary_stencil_width:
                # We now have a series of enough constant timesteps to go to
                # the higher order method.
                restart = False

        else:
            stencil_width = primary_stencil_width
            stencil = primary_stencil
            number_of_implicit_points = n

        delta = 0.0
        jstart = -(stencil_width - number_of_implicit_points)
        jend = number_of_implicit_points
        for jj in range(jstart, jend):
            delta += stencil[jj - jstart] * signal[ii + jj]

        integrated_signal[ii] = integrated_signal[ii - 1] + delta * curr_dt
        prev_dt = curr_dt

    return integrated_signal


@njit(cache=True)
def cumulative_distance(
    latitudes: np.typing.NDArray, longitudes: np.typing.NDArray
) -&gt; Tuple[np.typing.NDArray, np.typing.NDArray]:
    semi_major_axis = 6378137
    semi_minor_axis = 6356752.314245
    # eccentricity - squared
    eccentricity_squared = (
        semi_major_axis**2 - semi_minor_axis**2
    ) / semi_major_axis**2

    x = np.empty_like(latitudes)
    y = np.empty_like(longitudes)
    x[0] = 0
    y[0] = 0

    for ii in range(1, len(latitudes)):
        delta_longitude = (
            ((longitudes[ii] - longitudes[ii - 1] + 180) % 360 - 180) * np.pi / 180
        )
        delta_latitude = (latitudes[ii] - latitudes[ii - 1]) * np.pi / 180

        mean_latitude = (latitudes[ii] + latitudes[ii - 1]) / 2 * np.pi / 180

        # reduced latitude
        reduced_latitude = np.arctan(
            np.sqrt(1 - eccentricity_squared) * np.tan(mean_latitude)
        )

        # length of a small meridian arc
        arc_length = (
            semi_major_axis
            * (1 - eccentricity_squared)
            * (1 - eccentricity_squared * np.sin(mean_latitude) ** 2) ** (-3 / 2)
        )

        x[ii] = x[ii - 1] + delta_longitude * semi_major_axis * np.cos(reduced_latitude)
        y[ii] = y[ii - 1] + arc_length * delta_latitude
    return x, y


@njit(cache=True)
def complex_response(
    normalized_frequency: np.typing.NDArray,
    order: int,
    number_of_implicit_points: int = 1,
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    The frequency complex response factor of the numerical integration scheme with
    given order and number of implicit points.

    :param normalized_frequency: Frequency normalized with the sampling frequency to
        calculate response factor at
    :param order: Order of the returned Newton-Coates integration approximation.
    :param number_of_implicit_points: number of future points in the integration
        stencil.
    :return: complex np.typing.NDArray of same length as the input frequency containing
        the response factor at the given frequencies
    &#34;&#34;&#34;
    number_of_explicit_points = order - number_of_implicit_points
    stencil = integration_stencil(order, number_of_implicit_points)

    normalized_omega = 2j * np.pi * normalized_frequency

    response_factor = np.zeros_like(normalized_frequency, dtype=&#34;complex_&#34;)
    for ii in range(-number_of_explicit_points, number_of_implicit_points):
        response_factor += stencil[ii + number_of_explicit_points] * np.exp(
            normalized_omega * ii
        )

    for index, omega in enumerate(normalized_omega):
        if omega == 0.0 + 0.0j:
            response_factor[index] = 1.0 + 0.0j
        else:
            response_factor[index] = response_factor[index] * (
                omega / (1 - np.exp(-omega))
            )

    return response_factor


@njit(cache=True)
def lagrange_base_polynomial_coef(
    order: int, base_polynomial_index: int
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    We consider the interpolation of Y[0] Y[1] ... Y[order] spaced 1 apart
    at 0, 1,... point_index, ... order in terms of the Lagrange polynomial:

    Y[x]  =   L_0[x] Y[0] + L_1[x] Y[1] + .... L_order[x] Y[order].

    Here each of the lagrange polynomial coefficients L_n is expressed as
    a polynomial in x

    L_n = a_0 x**(order-1) + a_1 x**(order-2) + ... a_order

    where the coeficients may be found from the standard definition of the base
    polynomial (e.g. for L_0)

          ( x - x_1) * ... * (x - x_order )         ( x- 1) * (x-2) * ... * (x - order)
    L_0 = ------------------------------------  =  -------------------------------------
          (x_0 -x_1) * .... * (x_0 - x_order)        -1 * -2 * .... * -order

    where the right hand side follows after substituting x_n = n (i.e. 1 spacing).
    This function returns the set of coefficients [ a_0, a_1, ..., a_order ].

    :param order: order of the base polynomials.
    :param base_polynomial_index: which of the base polynomials to calculate
    :return: set of polynomial coefficients [ a_0, a_1, ..., a_order ]
    &#34;&#34;&#34;
    poly = np.zeros(order + 1)
    poly[0] = 1
    denominator = 1
    jj = 0
    for ii in range(0, order + 1):
        if ii == base_polynomial_index:
            continue
        jj += 1

        # calculate the denomitor by repeated multiplication
        denominator = denominator * (base_polynomial_index - ii)

        # Calculate the polynomial coeficients. We start with a constant function
        # (a_0=1) of order 0 and multiply this polynomial with the next term
        # ( x - x_0), (x-x_1) etc.
        poly[1:jj + 1] += -ii * poly[0:jj]

    return poly / denominator


@njit(cache=True)
def integrated_lagrange_base_polynomial_coef(
    order: int, base_polynomial_index: int
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    Calculate the polynomial coefficents of the integrated base polynomial.

    :param order: polynomial order of the interated base_polynomial.
    :param base_polynomial_index: which of the base polynomials to calculate
    :return: set of polynomial coefficients [ a_0, a_1, ..., a_[order-1], 0 ]
    &#34;&#34;&#34;
    poly = np.zeros(order + 1)
    poly[0:order] = lagrange_base_polynomial_coef(order - 1, base_polynomial_index)

    # Calculate the coefficients of the integrated polynimial.
    for ii in range(order - 1):
        poly[ii] = poly[ii] / (order - ii)
    return poly


@njit(cache=True)
def evaluate_polynomial(poly: np.typing.NDArray, x: int) -&gt; int:
    &#34;&#34;&#34;
    Eval a polynomial at location x.
    :param poly: polynomial coeficients [a_0, a_1, ..., a_[order+1]]
    :param x: location to evaluate the polynomial/
    :return: value of the polynomial at the location
    &#34;&#34;&#34;
    res = 0
    order = len(poly) - 1
    for ii in range(0, order + 1):
        res += poly[ii] * x ** (order - ii)
    return res


@njit(cache=True)
def integration_stencil(
    order: int, number_of_implicit_points: int = 1
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    Find the Newton-Coastes like- integration stencil given the desired order and the
    number of &#34;implicit&#34; points. Specicially, let the position z at instance t[j-1]
    be known, and we wish to approximate z at time t[j], where t[j] - t[j-1] = dt
    for all j, given the velocities w[j]. This implies we solve

            dz
           ---- = w    -&gt;    z[j] = z[j-1] + dz     with dz = Integral[w] ~ dt * F[w]
            dt

    To solve the integral we use Newton-Coates like approximation and express w(t) as a
    function of points w[j+i], where i = -m-1 ... n-1 using a Lagrange Polynomial.
    Specifically we consider points in the past and future as we anticipate we can
    buffer w values in any application.

    In this framework the interval of interest lies between j-1, and j  (i=0 and 1).

        j-m-1  ...  j-2  j-1   j   j+1  ...  j+n-1
          |    |    |    |----|    |    |    |

    The number of points used will be refered to ast the order = n+m+1. The number of
    points with i&gt;=0 will be referred to as the number of implicit points, so tha
     n = number_of_implicit_points. The number of points i&lt;0 is the number
    of explicit points m = order - n - 1.

    This function calculates the weights such that

    dz = weights[0] w[j-m] + ... +  weights[m-1] w[j-1] + weights[m] w[j]
        + ... weights[order-1] w[j+n-1]

    :param order: Order of the returned Newton-Coates set of coefficients.
    :param number_of_implicit_points: number of points for which i&gt;0
    :return: Numpy array of length Order with the weights.
    &#34;&#34;&#34;
    weights = np.zeros(order)
    number_of_explicit_points = order - number_of_implicit_points

    for ii in range(0, order):
        # Get the polynomial coefficients assocated with the ii&#39;th lagrangian
        # base polynomial l_ii
        base_poly = integrated_lagrange_base_polynomial_coef(order, ii)

        # Calculate the dz from the evaluation of the indeterminate integrals
        weights[ii] = evaluate_polynomial(
            base_poly, number_of_explicit_points
        ) - evaluate_polynomial(base_poly, number_of_explicit_points - 1)

    return weights


@njit(cache=True)
def integrated_response_factor_spectral_tail(
    tail_power: int,
    start_frequency: int,
    end_frequency: int,
    sampling_frequency: int,
    frequency_delta: Optional[int] = None,
    order: int = 4,
    transition_frequency: Optional[int] = None,
) -&gt; np.ndarray:
    if frequency_delta is None:
        N = (
            int(
                (start_frequency - end_frequency)
                / ((start_frequency - end_frequency) / 100)
            )
            + 1
        )
    else:
        N = int((start_frequency - end_frequency) / frequency_delta) + 1

    if transition_frequency is None:
        transition_frequency = end_frequency

    integration_frequencies = np.linspace(start_frequency, end_frequency, N)
    complex_amplification_factor = complex_response(
        integration_frequencies / sampling_frequency, order
    )

    spectrum = np.empty_like(integration_frequencies)
    for index in range(spectrum.shape[0]):
        if integration_frequencies[index] &gt;= transition_frequency:
            spectrum[index] = (
                integration_frequencies[index] ** -5 * transition_frequency
            )

        else:
            spectrum[index] = integration_frequencies[index] ** tail_power

    return np.trapz(spectrum, integration_frequencies) / np.trapz(
        np.abs(complex_amplification_factor) ** 2 * spectrum, integration_frequencies
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ocean_science_utilities.tools.time_integration.complex_response"><code class="name flex">
<span>def <span class="ident">complex_response</span></span>(<span>normalized_frequency: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], order: int, number_of_implicit_points: int = 1) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>The frequency complex response factor of the numerical integration scheme with
given order and number of implicit points.</p>
<p>:param normalized_frequency: Frequency normalized with the sampling frequency to
calculate response factor at
:param order: Order of the returned Newton-Coates integration approximation.
:param number_of_implicit_points: number of future points in the integration
stencil.
:return: complex np.typing.NDArray of same length as the input frequency containing
the response factor at the given frequencies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def complex_response(
    normalized_frequency: np.typing.NDArray,
    order: int,
    number_of_implicit_points: int = 1,
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    The frequency complex response factor of the numerical integration scheme with
    given order and number of implicit points.

    :param normalized_frequency: Frequency normalized with the sampling frequency to
        calculate response factor at
    :param order: Order of the returned Newton-Coates integration approximation.
    :param number_of_implicit_points: number of future points in the integration
        stencil.
    :return: complex np.typing.NDArray of same length as the input frequency containing
        the response factor at the given frequencies
    &#34;&#34;&#34;
    number_of_explicit_points = order - number_of_implicit_points
    stencil = integration_stencil(order, number_of_implicit_points)

    normalized_omega = 2j * np.pi * normalized_frequency

    response_factor = np.zeros_like(normalized_frequency, dtype=&#34;complex_&#34;)
    for ii in range(-number_of_explicit_points, number_of_implicit_points):
        response_factor += stencil[ii + number_of_explicit_points] * np.exp(
            normalized_omega * ii
        )

    for index, omega in enumerate(normalized_omega):
        if omega == 0.0 + 0.0j:
            response_factor[index] = 1.0 + 0.0j
        else:
            response_factor[index] = response_factor[index] * (
                omega / (1 - np.exp(-omega))
            )

    return response_factor</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.tools.time_integration.cumulative_distance"><code class="name flex">
<span>def <span class="ident">cumulative_distance</span></span>(<span>latitudes: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], longitudes: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]) ‑> Tuple[numpy.ndarray[Any, numpy.dtype[+ScalarType]], numpy.ndarray[Any, numpy.dtype[+ScalarType]]]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def cumulative_distance(
    latitudes: np.typing.NDArray, longitudes: np.typing.NDArray
) -&gt; Tuple[np.typing.NDArray, np.typing.NDArray]:
    semi_major_axis = 6378137
    semi_minor_axis = 6356752.314245
    # eccentricity - squared
    eccentricity_squared = (
        semi_major_axis**2 - semi_minor_axis**2
    ) / semi_major_axis**2

    x = np.empty_like(latitudes)
    y = np.empty_like(longitudes)
    x[0] = 0
    y[0] = 0

    for ii in range(1, len(latitudes)):
        delta_longitude = (
            ((longitudes[ii] - longitudes[ii - 1] + 180) % 360 - 180) * np.pi / 180
        )
        delta_latitude = (latitudes[ii] - latitudes[ii - 1]) * np.pi / 180

        mean_latitude = (latitudes[ii] + latitudes[ii - 1]) / 2 * np.pi / 180

        # reduced latitude
        reduced_latitude = np.arctan(
            np.sqrt(1 - eccentricity_squared) * np.tan(mean_latitude)
        )

        # length of a small meridian arc
        arc_length = (
            semi_major_axis
            * (1 - eccentricity_squared)
            * (1 - eccentricity_squared * np.sin(mean_latitude) ** 2) ** (-3 / 2)
        )

        x[ii] = x[ii - 1] + delta_longitude * semi_major_axis * np.cos(reduced_latitude)
        y[ii] = y[ii - 1] + arc_length * delta_latitude
    return x, y</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.tools.time_integration.evaluate_polynomial"><code class="name flex">
<span>def <span class="ident">evaluate_polynomial</span></span>(<span>poly: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], x: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Eval a polynomial at location x.
:param poly: polynomial coeficients [a_0, a_1, &hellip;, a_[order+1]]
:param x: location to evaluate the polynomial/
:return: value of the polynomial at the location</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def evaluate_polynomial(poly: np.typing.NDArray, x: int) -&gt; int:
    &#34;&#34;&#34;
    Eval a polynomial at location x.
    :param poly: polynomial coeficients [a_0, a_1, ..., a_[order+1]]
    :param x: location to evaluate the polynomial/
    :return: value of the polynomial at the location
    &#34;&#34;&#34;
    res = 0
    order = len(poly) - 1
    for ii in range(0, order + 1):
        res += poly[ii] * x ** (order - ii)
    return res</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.tools.time_integration.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>time: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], signal: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]], order=4, n=1, start_value=0.0) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Cumulatively integrate the given discretely sampled signal in time using a
Newton-Coases like formulation of requested order and layout. Note that higher
order methods are only used in regions where the timestep is constant across the
integration stencil- otherwise we fall back to the trapezoidal rule which can
handle variable timesteps. A small amount of jitter (&lt;1%) in timesteps is permitted
though (and effectively ignored).</p>
<p>NOTE: by default we start at 0.0 - which in general means that for a zero-mean
process we will pick up a random offset that will need to be corracted
afterwards. (out is not zero-mean).</p>
<p>:param time: ndarray of length nt containing the elapsed time in seconds.
:param signal: ndarray of length nt containing the signal to be integrated
:param order: Order of the returned Newton-Coates integration approximation.
:param n: number of future points in the integration stencil.
:param start_value: Starting value of the integrated signal.
:return: NDARRAY of length nt that contains the integrated signal that starts
at the requested start_value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def integrate(
    time: np.typing.NDArray,
    signal: np.typing.NDArray,
    order=DEFAULT_ORDER,
    n=DEFAULT_N,
    start_value=0.0,
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    Cumulatively integrate the given discretely sampled signal in time using a
    Newton-Coases like formulation of requested order and layout. Note that higher
    order methods are only used in regions where the timestep is constant across the
    integration stencil- otherwise we fall back to the trapezoidal rule which can
    handle variable timesteps. A small amount of jitter (&lt;1%) in timesteps is permitted
    though (and effectively ignored).

    NOTE: by default we start at 0.0 - which in general means that for a zero-mean
        process we will pick up a random offset that will need to be corracted
        afterwards. (out is not zero-mean).

    :param time: ndarray of length nt containing the elapsed time in seconds.
    :param signal: ndarray of length nt containing the signal to be integrated
    :param order: Order of the returned Newton-Coates integration approximation.
    :param n: number of future points in the integration stencil.
    :param start_value: Starting value of the integrated signal.
    :return: NDARRAY of length nt that contains the integrated signal that starts
        at the requested start_value.
    &#34;&#34;&#34;

    primary_stencil = integration_stencil(order, n)
    primary_stencil_width = len(primary_stencil)

    integrated_signal = np.empty_like(signal)
    integrated_signal[0] = start_value
    integrated_signal[:] = 0.0

    number_of_constant_time_steps = 0
    prev_dt = time[1] - time[0]
    restart = True

    nt = len(signal)
    for ii in range(1, len(signal)):
        curr_dt = time[ii] - time[ii - 1]

        if ii + n - 1 &lt; nt:
            future_dt = time[ii + n - 1] - time[ii + n - 2]
        else:
            future_dt = curr_dt
            restart = True

        if np.abs(future_dt - prev_dt) &gt; 0.01 * curr_dt:
            # Jitter in the timestep, fall back to a lower order method that
            # can handle this.
            restart = True
            number_of_constant_time_steps = 0

        if restart:
            number_of_constant_time_steps += 1
            stencil_width = 2
            stencil = np.array([0.5, 0.5])
            number_of_implicit_points = 1

            if number_of_constant_time_steps == primary_stencil_width:
                # We now have a series of enough constant timesteps to go to
                # the higher order method.
                restart = False

        else:
            stencil_width = primary_stencil_width
            stencil = primary_stencil
            number_of_implicit_points = n

        delta = 0.0
        jstart = -(stencil_width - number_of_implicit_points)
        jend = number_of_implicit_points
        for jj in range(jstart, jend):
            delta += stencil[jj - jstart] * signal[ii + jj]

        integrated_signal[ii] = integrated_signal[ii - 1] + delta * curr_dt
        prev_dt = curr_dt

    return integrated_signal</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.tools.time_integration.integrated_lagrange_base_polynomial_coef"><code class="name flex">
<span>def <span class="ident">integrated_lagrange_base_polynomial_coef</span></span>(<span>order: int, base_polynomial_index: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the polynomial coefficents of the integrated base polynomial.</p>
<p>:param order: polynomial order of the interated base_polynomial.
:param base_polynomial_index: which of the base polynomials to calculate
:return: set of polynomial coefficients [ a_0, a_1, &hellip;, a_[order-1], 0 ]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def integrated_lagrange_base_polynomial_coef(
    order: int, base_polynomial_index: int
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    Calculate the polynomial coefficents of the integrated base polynomial.

    :param order: polynomial order of the interated base_polynomial.
    :param base_polynomial_index: which of the base polynomials to calculate
    :return: set of polynomial coefficients [ a_0, a_1, ..., a_[order-1], 0 ]
    &#34;&#34;&#34;
    poly = np.zeros(order + 1)
    poly[0:order] = lagrange_base_polynomial_coef(order - 1, base_polynomial_index)

    # Calculate the coefficients of the integrated polynimial.
    for ii in range(order - 1):
        poly[ii] = poly[ii] / (order - ii)
    return poly</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.tools.time_integration.integrated_response_factor_spectral_tail"><code class="name flex">
<span>def <span class="ident">integrated_response_factor_spectral_tail</span></span>(<span>tail_power: int, start_frequency: int, end_frequency: int, sampling_frequency: int, frequency_delta: Optional[int] = None, order: int = 4, transition_frequency: Optional[int] = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def integrated_response_factor_spectral_tail(
    tail_power: int,
    start_frequency: int,
    end_frequency: int,
    sampling_frequency: int,
    frequency_delta: Optional[int] = None,
    order: int = 4,
    transition_frequency: Optional[int] = None,
) -&gt; np.ndarray:
    if frequency_delta is None:
        N = (
            int(
                (start_frequency - end_frequency)
                / ((start_frequency - end_frequency) / 100)
            )
            + 1
        )
    else:
        N = int((start_frequency - end_frequency) / frequency_delta) + 1

    if transition_frequency is None:
        transition_frequency = end_frequency

    integration_frequencies = np.linspace(start_frequency, end_frequency, N)
    complex_amplification_factor = complex_response(
        integration_frequencies / sampling_frequency, order
    )

    spectrum = np.empty_like(integration_frequencies)
    for index in range(spectrum.shape[0]):
        if integration_frequencies[index] &gt;= transition_frequency:
            spectrum[index] = (
                integration_frequencies[index] ** -5 * transition_frequency
            )

        else:
            spectrum[index] = integration_frequencies[index] ** tail_power

    return np.trapz(spectrum, integration_frequencies) / np.trapz(
        np.abs(complex_amplification_factor) ** 2 * spectrum, integration_frequencies
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.tools.time_integration.integration_stencil"><code class="name flex">
<span>def <span class="ident">integration_stencil</span></span>(<span>order: int, number_of_implicit_points: int = 1) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Find the Newton-Coastes like- integration stencil given the desired order and the
number of "implicit" points. Specicially, let the position z at instance t[j-1]
be known, and we wish to approximate z at time t[j], where t[j] - t[j-1] = dt
for all j, given the velocities w[j]. This implies we solve</p>
<pre><code>    dz
   ---- = w    -&gt;    z[j] = z[j-1] + dz     with dz = Integral[w] ~ dt * F[w]
    dt
</code></pre>
<p>To solve the integral we use Newton-Coates like approximation and express w(t) as a
function of points w[j+i], where i = -m-1 &hellip; n-1 using a Lagrange Polynomial.
Specifically we consider points in the past and future as we anticipate we can
buffer w values in any application.</p>
<p>In this framework the interval of interest lies between j-1, and j
(i=0 and 1).</p>
<pre><code>j-m-1  ...  j-2  j-1   j   j+1  ...  j+n-1
  |    |    |    |----|    |    |    |
</code></pre>
<p>The number of points used will be refered to ast the order = n+m+1. The number of
points with i&gt;=0 will be referred to as the number of implicit points, so tha
n = number_of_implicit_points. The number of points i&lt;0 is the number
of explicit points m = order - n - 1.</p>
<p>This function calculates the weights such that</p>
<p>dz = weights[0] w[j-m] + &hellip; +
weights[m-1] w[j-1] + weights[m] w[j]
+ &hellip; weights[order-1] w[j+n-1]</p>
<p>:param order: Order of the returned Newton-Coates set of coefficients.
:param number_of_implicit_points: number of points for which i&gt;0
:return: Numpy array of length Order with the weights.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def integration_stencil(
    order: int, number_of_implicit_points: int = 1
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    Find the Newton-Coastes like- integration stencil given the desired order and the
    number of &#34;implicit&#34; points. Specicially, let the position z at instance t[j-1]
    be known, and we wish to approximate z at time t[j], where t[j] - t[j-1] = dt
    for all j, given the velocities w[j]. This implies we solve

            dz
           ---- = w    -&gt;    z[j] = z[j-1] + dz     with dz = Integral[w] ~ dt * F[w]
            dt

    To solve the integral we use Newton-Coates like approximation and express w(t) as a
    function of points w[j+i], where i = -m-1 ... n-1 using a Lagrange Polynomial.
    Specifically we consider points in the past and future as we anticipate we can
    buffer w values in any application.

    In this framework the interval of interest lies between j-1, and j  (i=0 and 1).

        j-m-1  ...  j-2  j-1   j   j+1  ...  j+n-1
          |    |    |    |----|    |    |    |

    The number of points used will be refered to ast the order = n+m+1. The number of
    points with i&gt;=0 will be referred to as the number of implicit points, so tha
     n = number_of_implicit_points. The number of points i&lt;0 is the number
    of explicit points m = order - n - 1.

    This function calculates the weights such that

    dz = weights[0] w[j-m] + ... +  weights[m-1] w[j-1] + weights[m] w[j]
        + ... weights[order-1] w[j+n-1]

    :param order: Order of the returned Newton-Coates set of coefficients.
    :param number_of_implicit_points: number of points for which i&gt;0
    :return: Numpy array of length Order with the weights.
    &#34;&#34;&#34;
    weights = np.zeros(order)
    number_of_explicit_points = order - number_of_implicit_points

    for ii in range(0, order):
        # Get the polynomial coefficients assocated with the ii&#39;th lagrangian
        # base polynomial l_ii
        base_poly = integrated_lagrange_base_polynomial_coef(order, ii)

        # Calculate the dz from the evaluation of the indeterminate integrals
        weights[ii] = evaluate_polynomial(
            base_poly, number_of_explicit_points
        ) - evaluate_polynomial(base_poly, number_of_explicit_points - 1)

    return weights</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.tools.time_integration.lagrange_base_polynomial_coef"><code class="name flex">
<span>def <span class="ident">lagrange_base_polynomial_coef</span></span>(<span>order: int, base_polynomial_index: int) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>We consider the interpolation of Y[0] Y[1] &hellip; Y[order] spaced 1 apart
at 0, 1,&hellip; point_index, &hellip; order in terms of the Lagrange polynomial:</p>
<p>Y[x]
=
L_0[x] Y[0] + L_1[x] Y[1] + .... L_order[x] Y[order].</p>
<p>Here each of the lagrange polynomial coefficients L_n is expressed as
a polynomial in x</p>
<p>L_n = a_0 x<strong>(order-1) + a_1 x</strong>(order-2) + &hellip; a_order</p>
<p>where the coeficients may be found from the standard definition of the base
polynomial (e.g. for L_0)</p>
<pre><code>  ( x - x_1) * ... * (x - x_order )         ( x- 1) * (x-2) * ... * (x - order)
</code></pre>
<p>L_0 = ------------------------------------
=
-------------------------------------
(x_0 -x_1) * .... * (x_0 - x_order)
-1 * -2 * .... * -order</p>
<p>where the right hand side follows after substituting x_n = n (i.e. 1 spacing).
This function returns the set of coefficients [ a_0, a_1, &hellip;, a_order ].</p>
<p>:param order: order of the base polynomials.
:param base_polynomial_index: which of the base polynomials to calculate
:return: set of polynomial coefficients [ a_0, a_1, &hellip;, a_order ]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def lagrange_base_polynomial_coef(
    order: int, base_polynomial_index: int
) -&gt; np.typing.NDArray:
    &#34;&#34;&#34;
    We consider the interpolation of Y[0] Y[1] ... Y[order] spaced 1 apart
    at 0, 1,... point_index, ... order in terms of the Lagrange polynomial:

    Y[x]  =   L_0[x] Y[0] + L_1[x] Y[1] + .... L_order[x] Y[order].

    Here each of the lagrange polynomial coefficients L_n is expressed as
    a polynomial in x

    L_n = a_0 x**(order-1) + a_1 x**(order-2) + ... a_order

    where the coeficients may be found from the standard definition of the base
    polynomial (e.g. for L_0)

          ( x - x_1) * ... * (x - x_order )         ( x- 1) * (x-2) * ... * (x - order)
    L_0 = ------------------------------------  =  -------------------------------------
          (x_0 -x_1) * .... * (x_0 - x_order)        -1 * -2 * .... * -order

    where the right hand side follows after substituting x_n = n (i.e. 1 spacing).
    This function returns the set of coefficients [ a_0, a_1, ..., a_order ].

    :param order: order of the base polynomials.
    :param base_polynomial_index: which of the base polynomials to calculate
    :return: set of polynomial coefficients [ a_0, a_1, ..., a_order ]
    &#34;&#34;&#34;
    poly = np.zeros(order + 1)
    poly[0] = 1
    denominator = 1
    jj = 0
    for ii in range(0, order + 1):
        if ii == base_polynomial_index:
            continue
        jj += 1

        # calculate the denomitor by repeated multiplication
        denominator = denominator * (base_polynomial_index - ii)

        # Calculate the polynomial coeficients. We start with a constant function
        # (a_0=1) of order 0 and multiply this polynomial with the next term
        # ( x - x_0), (x-x_1) etc.
        poly[1:jj + 1] += -ii * poly[0:jj]

    return poly / denominator</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocean_science_utilities.tools" href="index.html">ocean_science_utilities.tools</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ocean_science_utilities.tools.time_integration.complex_response" href="#ocean_science_utilities.tools.time_integration.complex_response">complex_response</a></code></li>
<li><code><a title="ocean_science_utilities.tools.time_integration.cumulative_distance" href="#ocean_science_utilities.tools.time_integration.cumulative_distance">cumulative_distance</a></code></li>
<li><code><a title="ocean_science_utilities.tools.time_integration.evaluate_polynomial" href="#ocean_science_utilities.tools.time_integration.evaluate_polynomial">evaluate_polynomial</a></code></li>
<li><code><a title="ocean_science_utilities.tools.time_integration.integrate" href="#ocean_science_utilities.tools.time_integration.integrate">integrate</a></code></li>
<li><code><a title="ocean_science_utilities.tools.time_integration.integrated_lagrange_base_polynomial_coef" href="#ocean_science_utilities.tools.time_integration.integrated_lagrange_base_polynomial_coef">integrated_lagrange_base_polynomial_coef</a></code></li>
<li><code><a title="ocean_science_utilities.tools.time_integration.integrated_response_factor_spectral_tail" href="#ocean_science_utilities.tools.time_integration.integrated_response_factor_spectral_tail">integrated_response_factor_spectral_tail</a></code></li>
<li><code><a title="ocean_science_utilities.tools.time_integration.integration_stencil" href="#ocean_science_utilities.tools.time_integration.integration_stencil">integration_stencil</a></code></li>
<li><code><a title="ocean_science_utilities.tools.time_integration.lagrange_base_polynomial_coef" href="#ocean_science_utilities.tools.time_integration.lagrange_base_polynomial_coef">lagrange_base_polynomial_coef</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
