<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ocean_science_utilities.wavespectra.estimators.mem2 API documentation</title>
<meta name="description" content="Implementation of the &#34;MEM2&#34; method: …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocean_science_utilities.wavespectra.estimators.mem2</code></h1>
</header>
<section id="section-intro">
<p>Implementation of the "MEM2" method:</p>
<p>see Kim1995:</p>
<pre><code>Kim, T., Lin, L. H., &amp; Wang, H. (1995). Application of maximum entropy method
to the real sea data. In Coastal Engineering 1994 (pp. 340-355).

link: &lt;https://icce-ojs-tamu.tdl.org/icce/index.php/icce/article/download/4967/4647&gt;
(working as of May 29, 2022)
</code></pre>
<p>and references therein.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Implementation of the &#34;MEM2&#34; method:

see Kim1995:

    Kim, T., Lin, L. H., &amp; Wang, H. (1995). Application of maximum entropy method
    to the real sea data. In Coastal Engineering 1994 (pp. 340-355).

    link: https://icce-ojs-tamu.tdl.org/icce/index.php/icce/article/download/4967/4647
    (working as of May 29, 2022)

and references therein.

&#34;&#34;&#34;
import numpy as np
import numba  # type: ignore
import scipy  # type: ignore


from numba_progress import ProgressBar  # type: ignore

from ocean_science_utilities.wavespectra.estimators.mem import numba_mem
from ocean_science_utilities.wavespectra.estimators.utils import get_direction_increment


# Settings for numba JIT compilation- whether to use fast math and parallel
# optimizations when possible.
_FASTMATH = True
_PARALLEL = False

# Numerical settings used in solving for the mem2 distribution
NUMERICS = {
    # absolute tolerence stopping criterium. let moment = [ a1,b1,a2,b2] and let
    # iterate_moment contain the moments calculated from the current estmitated
    # distribution.
    # The stopping criterium is:
    #     np.linalg.norm( moment-iterate_moment ) &lt; atol
    &#34;atol&#34;: 0.01,
    # Maximum number of iterations
    &#34;max_iter&#34;: 100,
    # Maximum number of subiterations in the line search algorithm. Typically deep line
    # search activates only when the convergence is poor anyway.
    &#34;max_line_search_depth&#34;: 8,
    # If we fall back to least squares estimate of the newton update we have an
    # ill-conditioned system, and solve the system approximately removing the
    # smallest singular values. rcond it the ration of smallest divided by largest
    # singular value.
    &#34;rcond&#34;: 1e-6,
    # Convergence is mostly (based on limited testing) poor for narrow distributions
    # (large lagrange multipliers). If
    # we fail to converge we fall back to the mem estimate which has no such issues.
    # For narrow distributions this is
    # hopefully fine.
    &#34;use_mem_when_failing_to_converge&#34;: True,
}

# Entry Function
# =============================================================================


def mem2(
    directions_radians: np.ndarray,
    a1: np.ndarray,
    b1: np.ndarray,
    a2: np.ndarray,
    b2: np.ndarray,
    progress_bar: ProgressBar = None,
    solution_method=&#34;newton&#34;,
    solver_config=None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;

    :param directions_radians:
    :param a1:
    :param b1:
    :param a2:
    :param b2:
    :param solution_method:
    :return:
    &#34;&#34;&#34;

    if solver_config is None:
        solver_config = NUMERICS

    else:
        solver_config = NUMERICS | solver_config

    if solution_method == &#34;scipy&#34;:
        func = mem2_scipy_root_finder
        kwargs = {}

    elif solution_method == &#34;newton&#34;:
        func = mem2_newton
        numba_solver_config = numba.typed.Dict.empty(
            key_type=numba.core.types.unicode_type, value_type=numba.core.types.float64
        )
        for key in solver_config:
            numba_solver_config[key] = solver_config[key]

        kwargs = {&#34;config&#34;: numba_solver_config}

    elif solution_method == &#34;approximate&#34;:
        func = mem2_newton
        kwargs = {&#34;approximate&#34;: True}

    else:
        raise ValueError(&#34;Unknown method&#34;)

    return func(directions_radians, a1, b1, a2, b2, progress_bar, **kwargs)


# Scipy Implementation
# =============================================================================
def mem2_scipy_root_finder(
    directions_radians: np.ndarray,
    a1: np.ndarray,
    b1: np.ndarray,
    a2: np.ndarray,
    b2: np.ndarray,
    progress,
    **kwargs
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return the directional distribution that maximizes Shannon [ - D log(D) ]
    enthrophy constrained by given observed directional moments,

    :param directions_radians: 1d array of wave directions in radians,
    length[number_of_directions]

    :param a1: 1d array of cosine directional moment as function of frequency,
    length [number_of_frequencies]

    :param b1: 1d array of sine directional moment as function of frequency,
    length [number_of_frequencies]

    :param a2: 1d array of double angle cosine directional moment as function
    of frequency, length [number_of_frequencies]

    :param b2: 1d array of double angle sine directional moment as function of
    frequency, length [number_of_frequencies]

    :return: array with shape [number_of_frequencies,number_of_direction]
    representing the directional distribution of the waves at each frequency.

    Maximize the enthrophy of the solution with entrophy defined as:

           integrate - D * log(D) over directions

    such that the resulting distribution D reproduces the observed moments.

    &#34;&#34;&#34;

    number_of_frequencies = a1.shape[-1]
    number_of_points = a1.shape[0]

    directional_distribution = np.zeros(
        (number_of_points, number_of_frequencies, len(directions_radians))
    )

    direction_increment = get_direction_increment(directions_radians)

    twiddle_factors = np.empty((4, len(directions_radians)))
    twiddle_factors[0, :] = np.cos(directions_radians)
    twiddle_factors[1, :] = np.sin(directions_radians)
    twiddle_factors[2, :] = np.cos(2 * directions_radians)
    twiddle_factors[3, :] = np.sin(2 * directions_radians)

    guess = initial_value(a1, b1, a2, b2)
    for ipoint in range(0, number_of_points):
        progress.update(1)
        for ifreq in range(0, number_of_frequencies):
            #
            moments = np.array(
                [
                    a1[ipoint, ifreq],
                    b1[ipoint, ifreq],
                    a2[ipoint, ifreq],
                    b2[ipoint, ifreq],
                ]
            )

            if np.any(np.isnan(guess[ipoint, ifreq, :])):
                continue

            res = scipy.optimize.root(
                moment_constraints,
                guess[ipoint, ifreq, :],
                args=(twiddle_factors, moments, direction_increment),
                method=&#34;lm&#34;,
            )
            lambas = res.x

            directional_distribution[ipoint, ifreq, :] = mem2_directional_distribution(
                lambas, direction_increment, twiddle_factors
            )

    return directional_distribution


# Numba Implementation
# =============================================================================


# spatial iteration
# ---------------------


# To note; enabling caching seems to not play nice with paralel
@numba.njit(parallel=_PARALLEL, cache=(not _PARALLEL))
def mem2_newton(
    directions_radians: np.ndarray,
    a1: np.ndarray,
    b1: np.ndarray,
    a2: np.ndarray,
    b2: np.ndarray,
    progress_bar: ProgressBar = None,
    config: numba.typed.Dict = None,
    approximate: bool = False,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return the directional distribution that maximizes Shannon [ - D log(D) ]
    enthrophy constrained by given observed directional moments.

    :param directions_radians: 1d array of wave directions in radians,
    length[number_of_directions]

    :param a1: 1d array of cosine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param b1: 1d array of sine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param a2: 1d array of double angle cosine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param b2: 1d array of double angle sine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param progress_bar: Progress bar instance if updates are desired.

    :return: array with shape [
        numbrt_of_points,
        number_of_frequencies,
        number_of_direction
    ]
    representing the directional distribution of the waves at each frequency.

    Maximize the enthrophy of the solution with entrophy defined as:

           integrate - D * log(D) over directions

    such that the resulting distribution D reproduces the observed moments.

    &#34;&#34;&#34;

    number_of_frequencies = a1.shape[-1]
    number_of_points = a1.shape[0]

    directional_distribution = np.zeros(
        (number_of_points, number_of_frequencies, len(directions_radians))
    )

    direction_increment_downward_difference = (
        directions_radians - np.roll(directions_radians, 1) + np.pi
    ) % (2 * np.pi) - np.pi

    direction_increment_upward_difference = (
        -(directions_radians - np.roll(directions_radians, -1) + np.pi) % (2 * np.pi)
        - np.pi
    )

    direction_increment = (
        direction_increment_downward_difference + direction_increment_upward_difference
    ) / 2

    # Calculate the needed Fourier transform twiddle factors to calculate moments.
    twiddle_factors = np.empty((4, len(directions_radians)))
    twiddle_factors[0, :] = np.cos(directions_radians)
    twiddle_factors[1, :] = np.sin(directions_radians)
    twiddle_factors[2, :] = np.cos(2 * directions_radians)
    twiddle_factors[3, :] = np.sin(2 * directions_radians)

    guess = initial_value(a1, b1, a2, b2)
    for ipoint in numba.prange(0, number_of_points):
        if progress_bar is not None:
            progress_bar.update(1)

        # Note; entries to directional_distribution[ipoint, :, :] is modified in the
        # call below. This avoids creation of memory for the resulting array at the
        # expense of allowing for side-effects.
        _mem2_newton_point(
            directional_distribution[ipoint, :, :],
            a1[ipoint, :],
            b1[ipoint, :],
            a2[ipoint, :],
            b2[ipoint, :],
            guess[ipoint, :, :],
            direction_increment,
            twiddle_factors,
            config,
            approximate,
        )

    return directional_distribution


# frequency iteration
# ----------------------


@numba.njit(cache=True)
def _mem2_newton_point(
    out,
    a1,
    b1,
    a2,
    b2,
    guess,
    direction_increment,
    twiddle_factors,
    config=None,
    approximate=False,
):
    &#34;&#34;&#34;

    :param out: a (view) of the array that will containt the output
    :param a1: 1d array of cosine directional moment as function of frequency,
    :param b1: 1d array of sine directional moment as function of frequency,
    :param a2: 1d array of double angle cosine directional moment
        as function of frequency,
    :param b2: 1d array of double angle sine directional moment
        as function of frequency,
    :param guess: initial guess of the lagrange multipliers
    :param direction_increment: directional stepsize used in the integration, nd-array
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta]
        as a 4 by ndir array
    :param config: numerical settings, see description at NUMERICS at top of file.
    :param approximate: whether or not to use the approximate relations.
    :return: None - we use side-effects to pass the results back to the
        caller (modifying out)
    &#34;&#34;&#34;
    number_of_frequencies = a1.shape[0]
    for ifreq in range(0, number_of_frequencies):
        #
        moments = np.array([a1[ifreq], b1[ifreq], a2[ifreq], b2[ifreq]])
        out[ifreq, :] = mem2_newton_solver(
            moments,
            guess[ifreq, :],
            direction_increment,
            twiddle_factors,
            config,
            approximate,
        )


# mem2 numerical solver
# ----------------------


@numba.njit(cache=True)
def mem2_newton_solver(
    moments: np.ndarray,
    guess: np.ndarray,
    direction_increment: np.ndarray,
    twiddle_factors: np.ndarray,
    config=None,
    approximate=False,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Newton iteration to find the solution to the non-linear system of constraint
    equations defining the lagrange multipliers in the MEM2 method. Because the
    Lagrange multipliers enter the equations as exponents the system can
    be unstable to solve numerically.

    :param moments: the normalized directional moments [a1,b1,a2,b2]
    :param guess: first guess for the lagrange multipliers (ndarray, length 4)
    :param direction_increment: directional stepsize used in the integration, nd-array
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a
        4 by ndir array
    :param config: numerical settings, see description at NUMERICS at top of file.
    :param approximate: whether or not to use the approximate relations.
    :return:
    &#34;&#34;&#34;
    if config is None:
        max_iter = 100
        rcond = 1e-6
        atol = 0.01
        max_line_search_depth = 8
        use_mem_when_failing_to_converge = True

    else:
        max_iter = config[&#34;max_iter&#34;]
        rcond = config[&#34;rcond&#34;]
        atol = config[&#34;atol&#34;]
        max_line_search_depth = config[&#34;max_line_search_depth&#34;]
        use_mem_when_failing_to_converge = (
            config[&#34;use_mem_when_failing_to_converge&#34;] &gt; 0.0
        )

    directional_distribution = np.empty(len(direction_increment))
    if np.any(np.isnan(guess)):
        directional_distribution[:] = 0
        return directional_distribution

    if approximate:
        directional_distribution[:] = mem2_directional_distribution(
            guess, direction_increment, twiddle_factors
        )
        return directional_distribution

    current_iterate = guess
    current_func = moment_constraints(
        current_iterate,
        twiddle_factors,
        moments,
        direction_increment,
    )

    jacobian = np.empty((4, 4))

    convergence = False
    for iter in range(0, max_iter):
        # Stopping criterium
        magnitude_cur_func_eval = np.linalg.norm(current_func)
        if magnitude_cur_func_eval &lt; atol:
            convergence = True
            break

        #
        # Compute jacobian, and find newton iterate innovation as we solve for:
        #
        #       jacobian @ delta = - current_iterate_func_eval
        #
        # with:
        #
        #       delta = next_lagrange_multiplier_iterate-cur_lagrange_multiplier_iterate

        jacobian = mem2_jacobian(
            current_iterate, twiddle_factors, direction_increment, jacobian
        )
        try:
            update_iterate = solve_cholesky(jacobian, -current_func)
        except Exception:
            update_iterate = np.linalg.lstsq(jacobian, -current_func, rcond=rcond)[0]

        magnitude_current_iterate = np.linalg.norm(current_iterate)
        magnitude_update = np.linalg.norm(update_iterate)

        # Do a line search for the optimum decrease. This is intended to stabilize the
        # algorithm as the equations are ill-posed.
        line_search_factor = 1
        for ii in range(max_line_search_depth):
            next_iterate = current_iterate + line_search_factor * update_iterate
            next_func = moment_constraints(
                next_iterate, twiddle_factors, moments, direction_increment
            )

            if np.linalg.norm(next_func) &lt; magnitude_cur_func_eval:
                # If we are decreasing- continue
                current_func = next_func
                current_iterate = next_iterate
                break
            else:
                # The update may be too big as we are not decreasing the cost function
                # magnitude. We will decrease the step size we take - but keep the
                # direction of the step the same.
                inverse_relative_update = magnitude_current_iterate / magnitude_update
                line_search_factor = min(
                    inverse_relative_update, line_search_factor / 2
                )
        else:
            # The linesearch failed. We could not find a factor that ensures the next
            # function estimate is closer to 0.
            convergence = False
            break
    else:
        # We failed to converge after the maximum number of iterations.
        convergence = False

    if not convergence:
        if use_mem_when_failing_to_converge:
            directions = np.arctan2(twiddle_factors[1, :], twiddle_factors[0, :])
            directional_distribution[:] = numba_mem(
                directions, moments[0], moments[1], moments[2], moments[3]
            )
        else:
            raise ValueError(&#34;we did not converge&#34;)

    directional_distribution[:] = mem2_directional_distribution(
        current_iterate, direction_increment, twiddle_factors
    )

    return directional_distribution


# mem2 functions
# ----------------------


@numba.njit(cache=True, fastmath=_FASTMATH)
def moment_constraints(lambdas, twiddle_factors, moments, direction_increment):
    &#34;&#34;&#34;
    Construct the nonlinear equations we need to solve for lambda. The constrainst are
    the difference between the desired moments a1,b1,a2,b2 and the moment calculated
    from the current distribution guess and for a perfect fit should be 0.

    To note: we differ from Kim et al here who formulate the constraints using
    unnormalized equations. Here we opt to use the normalized version as that
    allows us to cast the error / or mismatch directly in terms of an error in the
    moments.

    :param lambdas: the lagrange multipliers
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a 4
    by ndir array
    :param moments: [a1,b1,a2,b2]
    :param direction_increment: directional stepsize used in the integration, nd-array
    :return: array (length=4) with the difference between desired moments and those
        calculated from the current approximate distribution
    &#34;&#34;&#34;

    # Get the current estimate of the directional distribution
    dist = mem2_directional_distribution(lambdas, direction_increment, twiddle_factors)
    out = np.zeros(4)
    for mm in range(0, 4):
        # note - the part after the &#34;-&#34; is just a discrete approximation of the
        # Fourier sine/cosine amplitude (moment)
        out[mm] = moments[mm] - np.sum(
            (twiddle_factors[mm, :]) * dist * direction_increment
        )

    return out


@numba.njit(cache=True, fastmath=_FASTMATH)
def mem2_jacobian(lagrange_multiplier, twiddle_factors, direction_increment, jacobian):
    &#34;&#34;&#34;
    Calculate the jacobian of the constraint equations. The resulting jacobian is a
    square and positive definite matrix

    :param lambdas: the lagrange multipliers
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a
        4 by ndir array
    :param direction_increment: directional stepsize used in the integration, nd-array

    :return: a 4 by 4 matrix that is the Jacobian of the constraint equations.
    &#34;&#34;&#34;
    inner_product = np.zeros(twiddle_factors.shape[1])
    for jj in range(0, 4):
        inner_product = inner_product + lagrange_multiplier[jj] * twiddle_factors[jj, :]

    # We subtract the minimum to ensure that the values in the exponent do not become
    # too large. This amounts to multiplyig with a constant - which is fine since we
    # normalize anyway. Effectively- this avoids overflow errors (or infinities)
    #  - at the expense of underflowing (which is less of an issue).
    inner_product = inner_product - np.min(inner_product)

    normalization = 1 / np.sum(np.exp(-inner_product) * direction_increment)
    shape = np.exp(-inner_product)

    normalization_derivative = np.zeros(4)
    for mm in range(0, 4):
        normalization_derivative[mm] = normalization * np.sum(
            twiddle_factors[mm, :] * np.exp(-inner_product) * direction_increment
        )

    # To note- we have to multiply seperately to avoid potential
    # underflow/overflow errors.
    normalization_derivative = normalization_derivative * normalization

    shape_derivative = np.zeros((4, twiddle_factors.shape[1]))
    for mm in range(0, 4):
        shape_derivative[mm, :] = -twiddle_factors[mm, :] * shape

    for mm in range(0, 4):
        # we make use of symmetry and only explicitly calculate up to the diagonal
        for nn in range(0, mm + 1):
            jacobian[mm, nn] = -np.sum(
                twiddle_factors[mm, :]
                * direction_increment
                * (
                    normalization * shape_derivative[nn, :]
                    + shape * normalization_derivative[nn]
                ),
                -1,
            )
            if nn != mm:
                jacobian[nn, mm] = jacobian[mm, nn]
    return jacobian


@numba.njit(cache=True, fastmath=_FASTMATH)
def mem2_directional_distribution(
    lagrange_multiplier, direction_increment, twiddle_factors
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Given the solution for the Lagrange multipliers- reconstruct the directional
    distribution.
    :param lagrange_multiplier: the lagrange multipliers
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a 4 by
        ndir array
    :param direction_increment: directional stepsize used in the integration, nd-array
    :return: Directional distribution arrasy as a function of directions
    &#34;&#34;&#34;
    inner_product = np.zeros(twiddle_factors.shape[1])
    for jj in range(0, 4):
        inner_product = inner_product + lagrange_multiplier[jj] * twiddle_factors[jj, :]

    inner_product = inner_product - np.min(inner_product)

    normalization = 1 / np.sum(np.exp(-inner_product) * direction_increment)
    return np.exp(-inner_product) * normalization


@numba.njit(cache=True, fastmath=_FASTMATH)
def initial_value(a1: np.ndarray, b1: np.ndarray, a2: np.ndarray, b2: np.ndarray):
    &#34;&#34;&#34;
    Initial guess of the Lagrange Multipliers according to the &#34;MEM AP2&#34; approximation
    found im Kim1995

    :param a1: moment a1
    :param b1: moment b1
    :param a2: moment a2
    :param b2: moment b2
    :return: initial guess of the lagrange multipliers,
        with the same leading dimensions as input.
    &#34;&#34;&#34;
    guess = np.empty((*a1.shape, 4))
    fac = 1 + a1**2 + b1**2 + a2**2 + b2**2
    guess[..., 0] = 2 * a1 * a2 + 2 * b1 * b2 - 2 * a1 * fac
    guess[..., 1] = 2 * a1 * b2 - 2 * b1 * a2 - 2 * b1 * fac
    guess[..., 2] = a1**2 - b1**2 - 2 * a2 * fac
    guess[..., 3] = 2 * a1 * b1 - 2 * b2 * fac
    return guess


@numba.njit(cache=True, fastmath=True)
def solve_cholesky(matrix, rhs):
    &#34;&#34;&#34;
    Solve using cholesky decomposition according to the Cholesky–Banachiewicz algorithm.
    See: https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm
    &#34;&#34;&#34;
    M, N = matrix.shape
    x = np.zeros(M)
    cholesky_decomposition = np.zeros((M, M))
    inv = np.zeros(M)

    for mm in range(0, M):
        forward_sub_sum = rhs[mm]
        for nn in range(0, mm):
            sum = matrix[mm, nn]
            for kk in range(0, nn):
                sum -= cholesky_decomposition[mm, kk] * cholesky_decomposition[nn, kk]

            cholesky_decomposition[mm, nn] = inv[nn] * sum
            forward_sub_sum += -cholesky_decomposition[mm, nn] * x[nn]

        sum = matrix[mm, mm]
        for kk in range(0, mm):
            sum -= cholesky_decomposition[mm, kk] ** 2

        if sum &lt;= 0.0:
            raise ValueError(
                &#34;Matrix not positive definite, likely due to finite precision errors.&#34;
            )

        cholesky_decomposition[mm, mm] = np.sqrt(sum)
        inv[mm] = 1 / cholesky_decomposition[mm, mm]
        x[mm] = forward_sub_sum * inv[mm]

    # Backward Substitution (in place)
    for mm in range(0, M):
        kk = M - mm - 1
        sum = x[kk]
        for nn in range(kk + 1, N):
            sum += -cholesky_decomposition[nn, kk] * x[nn]
        x[kk] = sum * inv[kk]
    return x</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.initial_value"><code class="name flex">
<span>def <span class="ident">initial_value</span></span>(<span>a1: numpy.ndarray, b1: numpy.ndarray, a2: numpy.ndarray, b2: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>Initial guess of the Lagrange Multipliers according to the "MEM AP2" approximation
found im Kim1995</p>
<p>:param a1: moment a1
:param b1: moment b1
:param a2: moment a2
:param b2: moment b2
:return: initial guess of the lagrange multipliers,
with the same leading dimensions as input.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(cache=True, fastmath=_FASTMATH)
def initial_value(a1: np.ndarray, b1: np.ndarray, a2: np.ndarray, b2: np.ndarray):
    &#34;&#34;&#34;
    Initial guess of the Lagrange Multipliers according to the &#34;MEM AP2&#34; approximation
    found im Kim1995

    :param a1: moment a1
    :param b1: moment b1
    :param a2: moment a2
    :param b2: moment b2
    :return: initial guess of the lagrange multipliers,
        with the same leading dimensions as input.
    &#34;&#34;&#34;
    guess = np.empty((*a1.shape, 4))
    fac = 1 + a1**2 + b1**2 + a2**2 + b2**2
    guess[..., 0] = 2 * a1 * a2 + 2 * b1 * b2 - 2 * a1 * fac
    guess[..., 1] = 2 * a1 * b2 - 2 * b1 * a2 - 2 * b1 * fac
    guess[..., 2] = a1**2 - b1**2 - 2 * a2 * fac
    guess[..., 3] = 2 * a1 * b1 - 2 * b2 * fac
    return guess</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.mem2"><code class="name flex">
<span>def <span class="ident">mem2</span></span>(<span>directions_radians: numpy.ndarray, a1: numpy.ndarray, b1: numpy.ndarray, a2: numpy.ndarray, b2: numpy.ndarray, progress_bar: numba_progress.progress.ProgressBar = None, solution_method='newton', solver_config=None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>:param directions_radians:
:param a1:
:param b1:
:param a2:
:param b2:
:param solution_method:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mem2(
    directions_radians: np.ndarray,
    a1: np.ndarray,
    b1: np.ndarray,
    a2: np.ndarray,
    b2: np.ndarray,
    progress_bar: ProgressBar = None,
    solution_method=&#34;newton&#34;,
    solver_config=None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;

    :param directions_radians:
    :param a1:
    :param b1:
    :param a2:
    :param b2:
    :param solution_method:
    :return:
    &#34;&#34;&#34;

    if solver_config is None:
        solver_config = NUMERICS

    else:
        solver_config = NUMERICS | solver_config

    if solution_method == &#34;scipy&#34;:
        func = mem2_scipy_root_finder
        kwargs = {}

    elif solution_method == &#34;newton&#34;:
        func = mem2_newton
        numba_solver_config = numba.typed.Dict.empty(
            key_type=numba.core.types.unicode_type, value_type=numba.core.types.float64
        )
        for key in solver_config:
            numba_solver_config[key] = solver_config[key]

        kwargs = {&#34;config&#34;: numba_solver_config}

    elif solution_method == &#34;approximate&#34;:
        func = mem2_newton
        kwargs = {&#34;approximate&#34;: True}

    else:
        raise ValueError(&#34;Unknown method&#34;)

    return func(directions_radians, a1, b1, a2, b2, progress_bar, **kwargs)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.mem2_directional_distribution"><code class="name flex">
<span>def <span class="ident">mem2_directional_distribution</span></span>(<span>lagrange_multiplier, direction_increment, twiddle_factors) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Given the solution for the Lagrange multipliers- reconstruct the directional
distribution.
:param lagrange_multiplier: the lagrange multipliers
:param twiddle_factors: [sin theta, cost theta, sin 2<em>theta, cos 2</em>theta] as a 4 by
ndir array
:param direction_increment: directional stepsize used in the integration, nd-array
:return: Directional distribution arrasy as a function of directions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(cache=True, fastmath=_FASTMATH)
def mem2_directional_distribution(
    lagrange_multiplier, direction_increment, twiddle_factors
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Given the solution for the Lagrange multipliers- reconstruct the directional
    distribution.
    :param lagrange_multiplier: the lagrange multipliers
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a 4 by
        ndir array
    :param direction_increment: directional stepsize used in the integration, nd-array
    :return: Directional distribution arrasy as a function of directions
    &#34;&#34;&#34;
    inner_product = np.zeros(twiddle_factors.shape[1])
    for jj in range(0, 4):
        inner_product = inner_product + lagrange_multiplier[jj] * twiddle_factors[jj, :]

    inner_product = inner_product - np.min(inner_product)

    normalization = 1 / np.sum(np.exp(-inner_product) * direction_increment)
    return np.exp(-inner_product) * normalization</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.mem2_jacobian"><code class="name flex">
<span>def <span class="ident">mem2_jacobian</span></span>(<span>lagrange_multiplier, twiddle_factors, direction_increment, jacobian)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the jacobian of the constraint equations. The resulting jacobian is a
square and positive definite matrix</p>
<p>:param lambdas: the lagrange multipliers
:param twiddle_factors: [sin theta, cost theta, sin 2<em>theta, cos 2</em>theta] as a
4 by ndir array
:param direction_increment: directional stepsize used in the integration, nd-array</p>
<p>:return: a 4 by 4 matrix that is the Jacobian of the constraint equations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(cache=True, fastmath=_FASTMATH)
def mem2_jacobian(lagrange_multiplier, twiddle_factors, direction_increment, jacobian):
    &#34;&#34;&#34;
    Calculate the jacobian of the constraint equations. The resulting jacobian is a
    square and positive definite matrix

    :param lambdas: the lagrange multipliers
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a
        4 by ndir array
    :param direction_increment: directional stepsize used in the integration, nd-array

    :return: a 4 by 4 matrix that is the Jacobian of the constraint equations.
    &#34;&#34;&#34;
    inner_product = np.zeros(twiddle_factors.shape[1])
    for jj in range(0, 4):
        inner_product = inner_product + lagrange_multiplier[jj] * twiddle_factors[jj, :]

    # We subtract the minimum to ensure that the values in the exponent do not become
    # too large. This amounts to multiplyig with a constant - which is fine since we
    # normalize anyway. Effectively- this avoids overflow errors (or infinities)
    #  - at the expense of underflowing (which is less of an issue).
    inner_product = inner_product - np.min(inner_product)

    normalization = 1 / np.sum(np.exp(-inner_product) * direction_increment)
    shape = np.exp(-inner_product)

    normalization_derivative = np.zeros(4)
    for mm in range(0, 4):
        normalization_derivative[mm] = normalization * np.sum(
            twiddle_factors[mm, :] * np.exp(-inner_product) * direction_increment
        )

    # To note- we have to multiply seperately to avoid potential
    # underflow/overflow errors.
    normalization_derivative = normalization_derivative * normalization

    shape_derivative = np.zeros((4, twiddle_factors.shape[1]))
    for mm in range(0, 4):
        shape_derivative[mm, :] = -twiddle_factors[mm, :] * shape

    for mm in range(0, 4):
        # we make use of symmetry and only explicitly calculate up to the diagonal
        for nn in range(0, mm + 1):
            jacobian[mm, nn] = -np.sum(
                twiddle_factors[mm, :]
                * direction_increment
                * (
                    normalization * shape_derivative[nn, :]
                    + shape * normalization_derivative[nn]
                ),
                -1,
            )
            if nn != mm:
                jacobian[nn, mm] = jacobian[mm, nn]
    return jacobian</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.mem2_newton"><code class="name flex">
<span>def <span class="ident">mem2_newton</span></span>(<span>directions_radians: numpy.ndarray, a1: numpy.ndarray, b1: numpy.ndarray, a2: numpy.ndarray, b2: numpy.ndarray, progress_bar: numba_progress.progress.ProgressBar = None, config: numba.typed.typeddict.Dict = None, approximate: bool = False) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the directional distribution that maximizes Shannon [ - D log(D) ]
enthrophy constrained by given observed directional moments.</p>
<p>:param directions_radians: 1d array of wave directions in radians,
length[number_of_directions]</p>
<p>:param a1: 1d array of cosine directional moment as function of
position and frequency,
shape = ( number_of_points,number_of_frequencies)</p>
<p>:param b1: 1d array of sine directional moment as function of
position and frequency,
shape = ( number_of_points,number_of_frequencies)</p>
<p>:param a2: 1d array of double angle cosine directional moment as function of
position and frequency,
shape = ( number_of_points,number_of_frequencies)</p>
<p>:param b2: 1d array of double angle sine directional moment as function of
position and frequency,
shape = ( number_of_points,number_of_frequencies)</p>
<p>:param progress_bar: Progress bar instance if updates are desired.</p>
<p>:return: array with shape [
numbrt_of_points,
number_of_frequencies,
number_of_direction
]
representing the directional distribution of the waves at each frequency.</p>
<p>Maximize the enthrophy of the solution with entrophy defined as:</p>
<pre><code>   integrate - D * log(D) over directions
</code></pre>
<p>such that the resulting distribution D reproduces the observed moments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(parallel=_PARALLEL, cache=(not _PARALLEL))
def mem2_newton(
    directions_radians: np.ndarray,
    a1: np.ndarray,
    b1: np.ndarray,
    a2: np.ndarray,
    b2: np.ndarray,
    progress_bar: ProgressBar = None,
    config: numba.typed.Dict = None,
    approximate: bool = False,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return the directional distribution that maximizes Shannon [ - D log(D) ]
    enthrophy constrained by given observed directional moments.

    :param directions_radians: 1d array of wave directions in radians,
    length[number_of_directions]

    :param a1: 1d array of cosine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param b1: 1d array of sine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param a2: 1d array of double angle cosine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param b2: 1d array of double angle sine directional moment as function of
        position and frequency,
        shape = ( number_of_points,number_of_frequencies)

    :param progress_bar: Progress bar instance if updates are desired.

    :return: array with shape [
        numbrt_of_points,
        number_of_frequencies,
        number_of_direction
    ]
    representing the directional distribution of the waves at each frequency.

    Maximize the enthrophy of the solution with entrophy defined as:

           integrate - D * log(D) over directions

    such that the resulting distribution D reproduces the observed moments.

    &#34;&#34;&#34;

    number_of_frequencies = a1.shape[-1]
    number_of_points = a1.shape[0]

    directional_distribution = np.zeros(
        (number_of_points, number_of_frequencies, len(directions_radians))
    )

    direction_increment_downward_difference = (
        directions_radians - np.roll(directions_radians, 1) + np.pi
    ) % (2 * np.pi) - np.pi

    direction_increment_upward_difference = (
        -(directions_radians - np.roll(directions_radians, -1) + np.pi) % (2 * np.pi)
        - np.pi
    )

    direction_increment = (
        direction_increment_downward_difference + direction_increment_upward_difference
    ) / 2

    # Calculate the needed Fourier transform twiddle factors to calculate moments.
    twiddle_factors = np.empty((4, len(directions_radians)))
    twiddle_factors[0, :] = np.cos(directions_radians)
    twiddle_factors[1, :] = np.sin(directions_radians)
    twiddle_factors[2, :] = np.cos(2 * directions_radians)
    twiddle_factors[3, :] = np.sin(2 * directions_radians)

    guess = initial_value(a1, b1, a2, b2)
    for ipoint in numba.prange(0, number_of_points):
        if progress_bar is not None:
            progress_bar.update(1)

        # Note; entries to directional_distribution[ipoint, :, :] is modified in the
        # call below. This avoids creation of memory for the resulting array at the
        # expense of allowing for side-effects.
        _mem2_newton_point(
            directional_distribution[ipoint, :, :],
            a1[ipoint, :],
            b1[ipoint, :],
            a2[ipoint, :],
            b2[ipoint, :],
            guess[ipoint, :, :],
            direction_increment,
            twiddle_factors,
            config,
            approximate,
        )

    return directional_distribution</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.mem2_newton_solver"><code class="name flex">
<span>def <span class="ident">mem2_newton_solver</span></span>(<span>moments: numpy.ndarray, guess: numpy.ndarray, direction_increment: numpy.ndarray, twiddle_factors: numpy.ndarray, config=None, approximate=False) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Newton iteration to find the solution to the non-linear system of constraint
equations defining the lagrange multipliers in the MEM2 method. Because the
Lagrange multipliers enter the equations as exponents the system can
be unstable to solve numerically.</p>
<p>:param moments: the normalized directional moments [a1,b1,a2,b2]
:param guess: first guess for the lagrange multipliers (ndarray, length 4)
:param direction_increment: directional stepsize used in the integration, nd-array
:param twiddle_factors: [sin theta, cost theta, sin 2<em>theta, cos 2</em>theta] as a
4 by ndir array
:param config: numerical settings, see description at NUMERICS at top of file.
:param approximate: whether or not to use the approximate relations.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(cache=True)
def mem2_newton_solver(
    moments: np.ndarray,
    guess: np.ndarray,
    direction_increment: np.ndarray,
    twiddle_factors: np.ndarray,
    config=None,
    approximate=False,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Newton iteration to find the solution to the non-linear system of constraint
    equations defining the lagrange multipliers in the MEM2 method. Because the
    Lagrange multipliers enter the equations as exponents the system can
    be unstable to solve numerically.

    :param moments: the normalized directional moments [a1,b1,a2,b2]
    :param guess: first guess for the lagrange multipliers (ndarray, length 4)
    :param direction_increment: directional stepsize used in the integration, nd-array
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a
        4 by ndir array
    :param config: numerical settings, see description at NUMERICS at top of file.
    :param approximate: whether or not to use the approximate relations.
    :return:
    &#34;&#34;&#34;
    if config is None:
        max_iter = 100
        rcond = 1e-6
        atol = 0.01
        max_line_search_depth = 8
        use_mem_when_failing_to_converge = True

    else:
        max_iter = config[&#34;max_iter&#34;]
        rcond = config[&#34;rcond&#34;]
        atol = config[&#34;atol&#34;]
        max_line_search_depth = config[&#34;max_line_search_depth&#34;]
        use_mem_when_failing_to_converge = (
            config[&#34;use_mem_when_failing_to_converge&#34;] &gt; 0.0
        )

    directional_distribution = np.empty(len(direction_increment))
    if np.any(np.isnan(guess)):
        directional_distribution[:] = 0
        return directional_distribution

    if approximate:
        directional_distribution[:] = mem2_directional_distribution(
            guess, direction_increment, twiddle_factors
        )
        return directional_distribution

    current_iterate = guess
    current_func = moment_constraints(
        current_iterate,
        twiddle_factors,
        moments,
        direction_increment,
    )

    jacobian = np.empty((4, 4))

    convergence = False
    for iter in range(0, max_iter):
        # Stopping criterium
        magnitude_cur_func_eval = np.linalg.norm(current_func)
        if magnitude_cur_func_eval &lt; atol:
            convergence = True
            break

        #
        # Compute jacobian, and find newton iterate innovation as we solve for:
        #
        #       jacobian @ delta = - current_iterate_func_eval
        #
        # with:
        #
        #       delta = next_lagrange_multiplier_iterate-cur_lagrange_multiplier_iterate

        jacobian = mem2_jacobian(
            current_iterate, twiddle_factors, direction_increment, jacobian
        )
        try:
            update_iterate = solve_cholesky(jacobian, -current_func)
        except Exception:
            update_iterate = np.linalg.lstsq(jacobian, -current_func, rcond=rcond)[0]

        magnitude_current_iterate = np.linalg.norm(current_iterate)
        magnitude_update = np.linalg.norm(update_iterate)

        # Do a line search for the optimum decrease. This is intended to stabilize the
        # algorithm as the equations are ill-posed.
        line_search_factor = 1
        for ii in range(max_line_search_depth):
            next_iterate = current_iterate + line_search_factor * update_iterate
            next_func = moment_constraints(
                next_iterate, twiddle_factors, moments, direction_increment
            )

            if np.linalg.norm(next_func) &lt; magnitude_cur_func_eval:
                # If we are decreasing- continue
                current_func = next_func
                current_iterate = next_iterate
                break
            else:
                # The update may be too big as we are not decreasing the cost function
                # magnitude. We will decrease the step size we take - but keep the
                # direction of the step the same.
                inverse_relative_update = magnitude_current_iterate / magnitude_update
                line_search_factor = min(
                    inverse_relative_update, line_search_factor / 2
                )
        else:
            # The linesearch failed. We could not find a factor that ensures the next
            # function estimate is closer to 0.
            convergence = False
            break
    else:
        # We failed to converge after the maximum number of iterations.
        convergence = False

    if not convergence:
        if use_mem_when_failing_to_converge:
            directions = np.arctan2(twiddle_factors[1, :], twiddle_factors[0, :])
            directional_distribution[:] = numba_mem(
                directions, moments[0], moments[1], moments[2], moments[3]
            )
        else:
            raise ValueError(&#34;we did not converge&#34;)

    directional_distribution[:] = mem2_directional_distribution(
        current_iterate, direction_increment, twiddle_factors
    )

    return directional_distribution</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.mem2_scipy_root_finder"><code class="name flex">
<span>def <span class="ident">mem2_scipy_root_finder</span></span>(<span>directions_radians: numpy.ndarray, a1: numpy.ndarray, b1: numpy.ndarray, a2: numpy.ndarray, b2: numpy.ndarray, progress, **kwargs) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the directional distribution that maximizes Shannon [ - D log(D) ]
enthrophy constrained by given observed directional moments,</p>
<p>:param directions_radians: 1d array of wave directions in radians,
length[number_of_directions]</p>
<p>:param a1: 1d array of cosine directional moment as function of frequency,
length [number_of_frequencies]</p>
<p>:param b1: 1d array of sine directional moment as function of frequency,
length [number_of_frequencies]</p>
<p>:param a2: 1d array of double angle cosine directional moment as function
of frequency, length [number_of_frequencies]</p>
<p>:param b2: 1d array of double angle sine directional moment as function of
frequency, length [number_of_frequencies]</p>
<p>:return: array with shape [number_of_frequencies,number_of_direction]
representing the directional distribution of the waves at each frequency.</p>
<p>Maximize the enthrophy of the solution with entrophy defined as:</p>
<pre><code>   integrate - D * log(D) over directions
</code></pre>
<p>such that the resulting distribution D reproduces the observed moments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mem2_scipy_root_finder(
    directions_radians: np.ndarray,
    a1: np.ndarray,
    b1: np.ndarray,
    a2: np.ndarray,
    b2: np.ndarray,
    progress,
    **kwargs
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Return the directional distribution that maximizes Shannon [ - D log(D) ]
    enthrophy constrained by given observed directional moments,

    :param directions_radians: 1d array of wave directions in radians,
    length[number_of_directions]

    :param a1: 1d array of cosine directional moment as function of frequency,
    length [number_of_frequencies]

    :param b1: 1d array of sine directional moment as function of frequency,
    length [number_of_frequencies]

    :param a2: 1d array of double angle cosine directional moment as function
    of frequency, length [number_of_frequencies]

    :param b2: 1d array of double angle sine directional moment as function of
    frequency, length [number_of_frequencies]

    :return: array with shape [number_of_frequencies,number_of_direction]
    representing the directional distribution of the waves at each frequency.

    Maximize the enthrophy of the solution with entrophy defined as:

           integrate - D * log(D) over directions

    such that the resulting distribution D reproduces the observed moments.

    &#34;&#34;&#34;

    number_of_frequencies = a1.shape[-1]
    number_of_points = a1.shape[0]

    directional_distribution = np.zeros(
        (number_of_points, number_of_frequencies, len(directions_radians))
    )

    direction_increment = get_direction_increment(directions_radians)

    twiddle_factors = np.empty((4, len(directions_radians)))
    twiddle_factors[0, :] = np.cos(directions_radians)
    twiddle_factors[1, :] = np.sin(directions_radians)
    twiddle_factors[2, :] = np.cos(2 * directions_radians)
    twiddle_factors[3, :] = np.sin(2 * directions_radians)

    guess = initial_value(a1, b1, a2, b2)
    for ipoint in range(0, number_of_points):
        progress.update(1)
        for ifreq in range(0, number_of_frequencies):
            #
            moments = np.array(
                [
                    a1[ipoint, ifreq],
                    b1[ipoint, ifreq],
                    a2[ipoint, ifreq],
                    b2[ipoint, ifreq],
                ]
            )

            if np.any(np.isnan(guess[ipoint, ifreq, :])):
                continue

            res = scipy.optimize.root(
                moment_constraints,
                guess[ipoint, ifreq, :],
                args=(twiddle_factors, moments, direction_increment),
                method=&#34;lm&#34;,
            )
            lambas = res.x

            directional_distribution[ipoint, ifreq, :] = mem2_directional_distribution(
                lambas, direction_increment, twiddle_factors
            )

    return directional_distribution</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.moment_constraints"><code class="name flex">
<span>def <span class="ident">moment_constraints</span></span>(<span>lambdas, twiddle_factors, moments, direction_increment)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct the nonlinear equations we need to solve for lambda. The constrainst are
the difference between the desired moments a1,b1,a2,b2 and the moment calculated
from the current distribution guess and for a perfect fit should be 0.</p>
<p>To note: we differ from Kim et al here who formulate the constraints using
unnormalized equations. Here we opt to use the normalized version as that
allows us to cast the error / or mismatch directly in terms of an error in the
moments.</p>
<p>:param lambdas: the lagrange multipliers
:param twiddle_factors: [sin theta, cost theta, sin 2<em>theta, cos 2</em>theta] as a 4
by ndir array
:param moments: [a1,b1,a2,b2]
:param direction_increment: directional stepsize used in the integration, nd-array
:return: array (length=4) with the difference between desired moments and those
calculated from the current approximate distribution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(cache=True, fastmath=_FASTMATH)
def moment_constraints(lambdas, twiddle_factors, moments, direction_increment):
    &#34;&#34;&#34;
    Construct the nonlinear equations we need to solve for lambda. The constrainst are
    the difference between the desired moments a1,b1,a2,b2 and the moment calculated
    from the current distribution guess and for a perfect fit should be 0.

    To note: we differ from Kim et al here who formulate the constraints using
    unnormalized equations. Here we opt to use the normalized version as that
    allows us to cast the error / or mismatch directly in terms of an error in the
    moments.

    :param lambdas: the lagrange multipliers
    :param twiddle_factors: [sin theta, cost theta, sin 2*theta, cos 2*theta] as a 4
    by ndir array
    :param moments: [a1,b1,a2,b2]
    :param direction_increment: directional stepsize used in the integration, nd-array
    :return: array (length=4) with the difference between desired moments and those
        calculated from the current approximate distribution
    &#34;&#34;&#34;

    # Get the current estimate of the directional distribution
    dist = mem2_directional_distribution(lambdas, direction_increment, twiddle_factors)
    out = np.zeros(4)
    for mm in range(0, 4):
        # note - the part after the &#34;-&#34; is just a discrete approximation of the
        # Fourier sine/cosine amplitude (moment)
        out[mm] = moments[mm] - np.sum(
            (twiddle_factors[mm, :]) * dist * direction_increment
        )

    return out</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.estimators.mem2.solve_cholesky"><code class="name flex">
<span>def <span class="ident">solve_cholesky</span></span>(<span>matrix, rhs)</span>
</code></dt>
<dd>
<div class="desc"><p>Solve using cholesky decomposition according to the Cholesky–Banachiewicz algorithm.
See: <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm">https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(cache=True, fastmath=True)
def solve_cholesky(matrix, rhs):
    &#34;&#34;&#34;
    Solve using cholesky decomposition according to the Cholesky–Banachiewicz algorithm.
    See: https://en.wikipedia.org/wiki/Cholesky_decomposition#The_Cholesky_algorithm
    &#34;&#34;&#34;
    M, N = matrix.shape
    x = np.zeros(M)
    cholesky_decomposition = np.zeros((M, M))
    inv = np.zeros(M)

    for mm in range(0, M):
        forward_sub_sum = rhs[mm]
        for nn in range(0, mm):
            sum = matrix[mm, nn]
            for kk in range(0, nn):
                sum -= cholesky_decomposition[mm, kk] * cholesky_decomposition[nn, kk]

            cholesky_decomposition[mm, nn] = inv[nn] * sum
            forward_sub_sum += -cholesky_decomposition[mm, nn] * x[nn]

        sum = matrix[mm, mm]
        for kk in range(0, mm):
            sum -= cholesky_decomposition[mm, kk] ** 2

        if sum &lt;= 0.0:
            raise ValueError(
                &#34;Matrix not positive definite, likely due to finite precision errors.&#34;
            )

        cholesky_decomposition[mm, mm] = np.sqrt(sum)
        inv[mm] = 1 / cholesky_decomposition[mm, mm]
        x[mm] = forward_sub_sum * inv[mm]

    # Backward Substitution (in place)
    for mm in range(0, M):
        kk = M - mm - 1
        sum = x[kk]
        for nn in range(kk + 1, N):
            sum += -cholesky_decomposition[nn, kk] * x[nn]
        x[kk] = sum * inv[kk]
    return x</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocean_science_utilities.wavespectra.estimators" href="index.html">ocean_science_utilities.wavespectra.estimators</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.initial_value" href="#ocean_science_utilities.wavespectra.estimators.mem2.initial_value">initial_value</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.mem2" href="#ocean_science_utilities.wavespectra.estimators.mem2.mem2">mem2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.mem2_directional_distribution" href="#ocean_science_utilities.wavespectra.estimators.mem2.mem2_directional_distribution">mem2_directional_distribution</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.mem2_jacobian" href="#ocean_science_utilities.wavespectra.estimators.mem2.mem2_jacobian">mem2_jacobian</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.mem2_newton" href="#ocean_science_utilities.wavespectra.estimators.mem2.mem2_newton">mem2_newton</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.mem2_newton_solver" href="#ocean_science_utilities.wavespectra.estimators.mem2.mem2_newton_solver">mem2_newton_solver</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.mem2_scipy_root_finder" href="#ocean_science_utilities.wavespectra.estimators.mem2.mem2_scipy_root_finder">mem2_scipy_root_finder</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.moment_constraints" href="#ocean_science_utilities.wavespectra.estimators.mem2.moment_constraints">moment_constraints</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.estimators.mem2.solve_cholesky" href="#ocean_science_utilities.wavespectra.estimators.mem2.solve_cholesky">solve_cholesky</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
