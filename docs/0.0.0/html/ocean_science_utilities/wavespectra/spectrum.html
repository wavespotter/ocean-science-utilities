<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ocean_science_utilities.wavespectra.spectrum API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ocean_science_utilities.wavespectra.spectrum</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import xarray

from typing import (
    Dict,
    Iterator,
    Hashable,
    List,
    Literal,
    Mapping,
    Optional,
    Union,
)
from warnings import warn

from ocean_science_utilities.interpolate.dataset import (
    interpolate_dataset_grid,
    interpolate_dataset_along_axis,
)
from ocean_science_utilities.tools.grid import midpoint_rule_step
from ocean_science_utilities.tools.math import wrapped_difference
from ocean_science_utilities.tools.time import to_datetime64
from ocean_science_utilities.wavetheory.lineardispersion import (
    inverse_intrinsic_dispersion_relation,
    intrinsic_group_velocity,
)
from ocean_science_utilities.wavespectra.estimators.estimate import (
    estimate_directional_distribution,
    Estimators,
)
from ocean_science_utilities.wavespectra._tools import (
    numba_fill_zeros_or_nan_in_tail,
    spline_peak_frequency,
    _cdf_interpolate_spline,
)

NAME_F: Literal[&#34;frequency&#34;] = &#34;frequency&#34;
NAME_D: Literal[&#34;direction&#34;] = &#34;direction&#34;
NAME_T: Literal[&#34;time&#34;] = &#34;time&#34;
NAME_E: Literal[&#34;variance_density&#34;] = &#34;variance_density&#34;
NAME_a1: Literal[&#34;a1&#34;] = &#34;a1&#34;
NAME_b1: Literal[&#34;b1&#34;] = &#34;b1&#34;
NAME_a2: Literal[&#34;a2&#34;] = &#34;a2&#34;
NAME_b2: Literal[&#34;b2&#34;] = &#34;b2&#34;
NAME_LAT: Literal[&#34;latitude&#34;] = &#34;latitude&#34;
NAME_LON: Literal[&#34;longitude&#34;] = &#34;longitude&#34;
NAME_DEPTH: Literal[&#34;depth&#34;] = &#34;depth&#34;
NAMES_2D = (NAME_F, NAME_D, NAME_T, NAME_E, NAME_LAT, NAME_LON, NAME_DEPTH)
NAMES_1D = (
    NAME_F,
    NAME_T,
    NAME_E,
    NAME_LAT,
    NAME_LON,
    NAME_a1,
    NAME_b1,
    NAME_a2,
    NAME_b2,
    NAME_DEPTH,
)
SPECTRAL_VARS = (NAME_E, NAME_a1, NAME_b1, NAME_a2, NAME_b2)
SPECTRAL_MOMENTS = (NAME_a1, NAME_b1, NAME_a2, NAME_b2)
SPECTRAL_DIMS = (NAME_F, NAME_D)
SPACE_TIME_DIMS = (NAME_T, NAME_LON, NAME_LAT)


class DatasetWrapper:
    &#34;&#34;&#34;
    A class that wraps a dataset object and passes through some of its primary
    functionality (get/set etc.). Used here mostly to make explicit what parts
    of the Dataset interface we actually expose in frequency objects. Note that
    we do not claim- or try to obtain completeness here. If full capabilities
    of the dataset object are needed we can simple operate directly on the
    dataset object itself.
    &#34;&#34;&#34;

    def __init__(self, dataset: xarray.Dataset):
        self.dataset = dataset

    def __getitem__(self, item) -&gt; xarray.DataArray:
        return self.dataset.__getitem__(item)

    def __setitem__(self, key, value) -&gt; None:
        return self.dataset.__setitem__(key, value)

    def __copy__(self):
        cls = self.__class__
        return cls(self.dataset.copy())

    def __len__(self) -&gt; int:
        return len(self.dataset)

    def copy(self, deep=True):
        if deep:
            return self.__deepcopy__({})
        else:
            return self.__copy__()

    def __deepcopy__(self, memodict):
        cls = self.__class__
        return cls(self.dataset.copy(deep=True))

    def coords(self) -&gt; xarray.core.coordinates.DatasetCoordinates:
        return self.dataset.coords

    def keys(self):
        return self.dataset.keys()

    def __contains__(self, key: object) -&gt; bool:
        return key in self.dataset

    def __iter__(self) -&gt; Iterator[Hashable]:
        return self.dataset.__iter__()

    def sel(self, *args, method=&#34;nearest&#34;):
        cls = type(self)
        dataset = xarray.Dataset()
        for var in self.dataset:
            dataset = dataset.assign({var: self.dataset[var].sel(*args, method=method)})
        return cls(dataset=dataset)

    def isel(self, *args, **kwargs):
        cls = type(self)
        dataset = xarray.Dataset()
        for var in self.dataset:
            dataset = dataset.assign({var: self.dataset[var].isel(*args, **kwargs)})
        return cls(dataset=dataset)


class WaveSpectrum(DatasetWrapper):
    frequency_units = &#34;Hertz&#34;
    angular_units = &#34;Degrees&#34;
    spectral_density_units = &#34;m**2/Hertz&#34;
    angular_convention = (
        &#34;Wave travel direction (going-to), measured anti-clockwise from East&#34;
    )
    bulk_properties = (
        &#34;m0&#34;,
        &#34;hm0&#34;,
        &#34;tm01&#34;,
        &#34;tm02&#34;,
        &#34;peak_period&#34;,
        &#34;peak_direction&#34;,
        &#34;peak_directional_spread&#34;,
        &#34;mean_direction&#34;,
        &#34;mean_directional_spread&#34;,
        &#34;peak_frequency&#34;,
        &#34;peak_wavenumber&#34;,
        &#34;latitude&#34;,
        &#34;longitude&#34;,
        &#34;time&#34;,
    )

    def __init__(self, dataset: xarray.Dataset):
        super(WaveSpectrum, self).__init__(dataset)

    def __add__(self, other):
        cls = type(self)
        spectrum = cls(self.copy(deep=True).dataset)
        spectrum.dataset[NAME_E] = spectrum.dataset[NAME_E] + other.dataset[NAME_E]
        return spectrum

    def __sub__(self, other):
        cls = type(self)
        spectrum = cls(self.copy(deep=True).dataset)
        spectrum.dataset[NAME_E] = spectrum.dataset[NAME_E] - other.dataset[NAME_E]
        return spectrum

    def __neg__(self):
        &#34;&#34;&#34;
        Negate self- that is -spectrum
        :return: spectrum with all spectral values taken to have the opposite
            sign.
        &#34;&#34;&#34;
        cls = type(self)
        spectrum = cls(self.copy(deep=True).dataset)
        spectrum.dataset[NAME_E] = -spectrum.dataset[NAME_E]
        return spectrum

    def __len__(self) -&gt; int:
        return self.number_of_spectra

    def __getitem__(self, item) -&gt; xarray.DataArray:
        if isinstance(item, tuple):
            if len(item) &lt; self.ndims:
                raise ValueError(
                    &#34;Indexing requires same number of inputs&#34;
                    f&#34;as dimensions: {self.ndims}&#34;
                )
            space_time_index = item[: -len(self.dims_spectral)]
        else:
            if not self.ndims == 1:
                raise ValueError(
                    &#34;Indexing requires same number of inputs&#34;
                    f&#34;as dimensions: {self.ndims}&#34;
                )
            space_time_index = []

        dataset = xarray.Dataset()
        for var in self.dataset:
            if var in SPECTRAL_VARS:
                dataset = dataset.assign({var: self.dataset[var].__getitem__(item)})
            else:
                if space_time_index:
                    # array
                    dataset = dataset.assign(
                        {var: self.dataset[var].__getitem__(space_time_index)}
                    )
                else:
                    # Scalar
                    dataset = dataset.assign({var: self.dataset[var]})

        for coor in dataset.coords:
            if coor not in dataset.dims:
                dataset = dataset.reset_coords(str(coor))

        cls = type(self)
        return cls(dataset)

    @property
    def ndims(self) -&gt; int:
        return len(self.dims)

    @property
    def frequency_step(self) -&gt; xarray.DataArray:
        prepend = 2 * self.frequency[0] - self.frequency[1]
        append = 2 * self.frequency[-1] - self.frequency[-2]
        diff = np.diff(self.frequency, append=append, prepend=prepend)
        return xarray.DataArray(
            data=(diff[0:-1] * 0.5 + diff[1:] * 0.5),
            dims=NAME_F,
            coords={NAME_F: self.frequency},
        )

    def fillna(self, value=0.0):
        for variable in SPECTRAL_VARS:
            if variable in self.dataset:
                self.dataset[variable] = self.dataset[variable].fillna(value)

    def is_invalid(self) -&gt; xarray.DataArray:
        return self.variance_density.isnull().all(dim=self.dims_spectral)

    def is_valid(self) -&gt; xarray.DataArray:
        return ~self.is_invalid()

    def drop_invalid(self):
        return self._apply_filter(self.is_valid())

    def where(self, condition: xarray.DataArray):
        return self._apply_filter(condition)

    def _apply_filter(self, boolean_mask: xarray.DataArray):
        dataset = xarray.Dataset()
        for var in self.dataset:
            data = self.dataset[var].where(
                boolean_mask.reindex_like(self.dataset[var]), drop=True
            )
            dataset = dataset.assign({var: data})

        cls = type(self)
        return cls(dataset)

    def mean(self, dim, skipna=False):
        &#34;&#34;&#34;
        Calculate the mean value of the spectrum along the given dimension.
        :param dim: dimension to average over
        :param skipna: whether or not to &#34;skip&#34; nan values; if
            True behaves as np.nanmean
        :return:
        &#34;&#34;&#34;
        if dim in SPECTRAL_DIMS:
            raise ValueError(&#34;Cannot calculate mean over spectral dimensions&#34;)

        cls = type(self)
        dataset = xarray.Dataset()
        # Todo: fix averaging over longitude for (prime/anti) meridian issues
        dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
        for x in self.dataset:
            dataset = dataset.assign({x: self.dataset[x].mean(dim=dim, skipna=skipna)})
        return cls(dataset)

    def flatten(self, flattened_coordinate=&#34;linear_index&#34;):
        &#34;&#34;&#34;
        Serialize the non-spectral dimensions creating a single leading dimension
        without a coordinate.
        &#34;&#34;&#34;

        # Get the current dimensions and shape
        dims = self.dims_space_time
        coords = self.coords_space_time
        shape = self.space_time_shape()
        if len(shape) == 0:
            length = 1
            shape = (1,)
        else:
            length = np.prod(shape)

        # Calculate the flattened shape
        new_shape = (length,)
        new_spectral_shape = (length, *self.spectral_shape())
        new_dims = [flattened_coordinate] + self.dims_spectral

        linear_index = xarray.DataArray(
            data=np.arange(0, length), dims=flattened_coordinate
        )
        indices = np.unravel_index(linear_index.values, shape)

        dataset = {}
        for index, dim in zip(indices, dims):
            dataset[dim] = xarray.DataArray(
                data=coords[dim].values[index], dims=flattened_coordinate
            )

        for name in self.dataset:
            if name in SPECTRAL_VARS:
                x = xarray.DataArray(
                    data=self.dataset[name].values.reshape(new_spectral_shape),
                    dims=new_dims,
                    coords=self.coords_spectral,
                )
            else:
                x = xarray.DataArray(
                    data=self.dataset[name].values.reshape(new_shape),
                    dims=flattened_coordinate,
                )
            dataset[str(name)] = x

        cls = type(self)
        return cls(xarray.Dataset(dataset))

    def sum(self, dim: str, skipna: bool = False):
        &#34;&#34;&#34;
        Calculate the sum value of the spectrum along the given dimension.
        :param dim: dimension to sum over
        :param skipna: whether or not to &#34;skip&#34; nan values; if True behaves as np.nansum
        :return:
        &#34;&#34;&#34;

        if dim in SPECTRAL_DIMS:
            raise ValueError(&#34;Cannot calculate sum over spectral dimensions&#34;)

        cls = type(self)
        dataset = xarray.Dataset()
        # we assign the average coordinate to the dimension we sum over
        dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
        for x in self.dataset:
            dataset = dataset.assign({x: self.dataset[x].sum(dim=dim, skipna=skipna)})
        return cls(dataset)

    def std(self, dim: str, skipna: bool = False):
        &#34;&#34;&#34;
        Calculate the standard deviation of the spectrum along the given dimension.
        :param dim: dimension to calculate standard deviation over
        :param skipna: whether or not to &#34;skip&#34; nan values; if True behaves as np.nanstd
        :return:
        &#34;&#34;&#34;
        if dim in SPECTRAL_DIMS:
            raise ValueError(
                &#34;Cannot calculate standard deviation over spectral dimensions&#34;
            )

        cls = type(self)
        dataset = xarray.Dataset()
        # we assign the average coordinate to the dimension we calculate the std over
        dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
        for x in self.dataset:
            dataset = dataset.assign({x: self.dataset[x].std(dim=dim, skipna=skipna)})
        return cls(dataset)

    def shape(self):
        return self.variance_density.shape

    def spectral_shape(self):
        number_of_spectral_dims = len(self.dims_spectral)
        return self.shape()[-number_of_spectral_dims:]

    def space_time_shape(self):
        number_of_spectral_dims = len(self.dims_spectral)
        return self.shape()[:-number_of_spectral_dims]

    def frequency_moment(self, power: int, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Calculate a &#34;frequency moment&#34; over the given range. A frequency moment
        here refers to the integral:

                    Integral-over-frequency-range[ e(f) * f**power ]

        :param power: power of the frequency
        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: frequency moment
        &#34;&#34;&#34;
        _range = self._range(fmin, fmax)

        # Integrate dataset over frequencies. Make sure to fill any NaN entries
        # with 0 before the integration.
        return (
            (self.e.isel({NAME_F: _range}) * self.frequency[_range] ** power)
            .fillna(0)
            .integrate(coord=NAME_F)
        )

    @property
    def number_of_frequencies(self) -&gt; int:
        &#34;&#34;&#34;
        :return: number of frequencies
        &#34;&#34;&#34;
        return len(self.frequency)

    @property
    def dims_space_time(self) -&gt; List[str]:
        return [str(x) for x in self.variance_density.dims if x not in (SPECTRAL_DIMS)]

    @property
    def coords_space_time(self) -&gt; Mapping[str, xarray.DataArray]:
        return {dim: self.dataset[dim] for dim in self.dims_space_time}

    @property
    def coords_spectral(self) -&gt; Mapping[str, xarray.DataArray]:
        return {dim: self.dataset[dim] for dim in self.dims_spectral}

    @property
    def dims_spectral(self) -&gt; List[str]:
        return [str(x) for x in self.variance_density.dims if x in (SPECTRAL_DIMS)]

    @property
    def dims(self) -&gt; List[str]:
        return [str(x) for x in self.variance_density.dims]

    @property
    def number_of_spectra(self):
        dims = self.dims_space_time
        if dims:
            shape = 1
            for d in dims:
                shape *= len(self.dataset[d])
            return shape
        else:
            return 1

    @property
    def spectral_values(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Spectral levels
        &#34;&#34;&#34;
        return self.dataset[NAME_E]

    @property
    def radian_frequency(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Radian frequency
        &#34;&#34;&#34;
        data_array = self.dataset[NAME_F] * 2 * np.pi
        data_array.name = &#34;radian_frequency&#34;
        return data_array

    @property
    def latitude(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: latitudes
        &#34;&#34;&#34;
        return self.dataset[NAME_LAT]

    @property
    def longitude(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: longitudes
        &#34;&#34;&#34;
        return self.dataset[NAME_LON]

    @property
    def time(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Time
        &#34;&#34;&#34;
        return self.dataset[NAME_T]

    @property
    def variance_density(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Time
        &#34;&#34;&#34;
        return self.dataset[NAME_E]

    @property
    def values(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get the raw np representation of the wave spectrum
        :return: Numpy ndarray of the wave spectrum.
        &#34;&#34;&#34;
        return self.dataset[NAME_E].values

    @property
    def e(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: 1D spectral values (directionally integrated spectrum).
            Equivalent to self.spectral_values if this is a 1D spectrum.
        &#34;&#34;&#34;
        return self.dataset[NAME_E]

    @property
    def a1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment cos(theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_a1]

    @property
    def b1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment sin(theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_b1]

    @property
    def a2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment cos(2*theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_a2]

    @property
    def b2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment sin(2*theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_b2]

    @property
    def A1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment cos(theta)
        &#34;&#34;&#34;
        return self.a1 * self.e

    @property
    def B1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment sin(theta)
        &#34;&#34;&#34;
        return self.b1 * self.e

    @property
    def A2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment cos(2*theta)
        &#34;&#34;&#34;
        return self.a2 * self.e

    @property
    def B2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment sin(2*theta)
        &#34;&#34;&#34;
        return self.b2 * self.e

    @property
    def frequency(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Frequencies (Hz)
        &#34;&#34;&#34;
        return self.dataset[NAME_F]

    def m0(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Zero order frequency moment. Also referred to as variance or energy.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: variance/energy
        &#34;&#34;&#34;
        return self.frequency_moment(0, fmin, fmax)

    def m1(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        First order frequency moment. Primarily used in calculating a mean
        period measure (Tm01)

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: first order frequency moment.
        &#34;&#34;&#34;
        return self.frequency_moment(1, fmin, fmax)

    def wave_speed(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return:
        &#34;&#34;&#34;
        # Note we multiply inverse wavenumber with frequency to force xarray to return
        # a number_of_points by by number of frequencies data structure.
        return (1 / self.wavenumber) * self.radian_frequency

    def wave_age(self, windspeed):
        return self.peak_wave_speed() / windspeed

    def peak_wave_speed(self) -&gt; xarray.DataArray:
        return 2 * np.pi * self.peak_frequency() / self.peak_wavenumber

    @property
    def wavenumber_density(self) -&gt; xarray.DataArray:
        return self.variance_density * self.group_velocity / (np.pi * 2)

    @property
    def saturation_spectrum(self) -&gt; xarray.DataArray:
        return self.wavenumber_density * self.wavenumber**3

    @property
    def slope_spectrum(self) -&gt; xarray.DataArray:
        return self.variance_density * self.wavenumber**2

    def mean_squared_slope(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        _range = self._range(fmin, fmax)

        # Integrate dataset over frequencies. Make sure to fill any NaN entries with
        # 0 before the integration.
        return (
            self.slope_spectrum.fillna(0).isel({NAME_F: _range}).integrate(coord=NAME_F)
        )

    def m2(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Second order frequency moment. Primarily used in calculating the zero
        crossing period (Tm02)

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Second order frequency moment.
        &#34;&#34;&#34;
        return self.frequency_moment(2, fmin, fmax)

    def hm0(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Significant wave height estimated from the spectrum, i.e. waveheight
        h estimated from variance m0. Common notation in literature.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Significant wave height
        &#34;&#34;&#34;
        return xarray.DataArray(4 * np.sqrt(self.m0(fmin, fmax)))

    def tm01(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Mean period, estimated as the inverse of the center of mass of the
        spectral curve under the 1d spectrum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Mean period
        &#34;&#34;&#34;
        return self.m0(fmin, fmax) / self.m1(fmin, fmax)

    def tm02(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Zero crossing period based on Rice&#39;s spectral estimate.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Zero crossing period
        &#34;&#34;&#34;
        return xarray.DataArray(np.sqrt(self.m0(fmin, fmax) / self.m2(fmin, fmax)))

    def peak_index(self, fmin: float = 0, fmax: float = np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Index of the peak frequency of the 1d spectrum within the given range
        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: peak indices
        &#34;&#34;&#34;
        return self.e.where(self._range(fmin, fmax), 0).argmax(dim=NAME_F)

    def peak_frequency(
        self, fmin=0.0, fmax=np.inf, use_spline=False, **kwargs
    ) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Peak frequency of the spectrum, i.e. frequency at which the spectrum
        obtains its maximum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :param use_spline: Use a spline based interpolation and determine peak
            frequency from the spline. This
        allows for a continuous estimate of the peak frequency. WARNING: if True the
        fmin and fmax paramteres are IGNORED
        :return: peak frequency
        &#34;&#34;&#34;
        if use_spline:
            if not fmin == 0.0 or np.isfinite(fmax):
                warn(
                    &#34;The fmin and fmax parameters are ignored&#34;
                    &#34;if use_spline is set to True&#34;
                )

            data = spline_peak_frequency(self.frequency.values, self.e.values, **kwargs)
            if len(self.dims_space_time) == 0:
                data = data[0]

            return xarray.DataArray(
                data=data,
                coords=self.coords_space_time,
                dims=self.dims_space_time,
            )
        else:
            return self.dataset[NAME_F][self.peak_index(fmin, fmax)]

    def peak_angular_frequency(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Peak frequency of the spectrum, i.e. frequency at which the spectrum
        obtains its maximum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: peak frequency
        &#34;&#34;&#34;
        return self.peak_frequency(fmin, fmax) * np.pi * 2

    def peak_period(
        self, fmin=0, fmax=np.inf, use_spline=False, **kwargs
    ) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Peak period of the spectrum, i.e. period at which the spectrum
        obtains its maximum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: peak period
        &#34;&#34;&#34;
        peak_period = 1 / self.peak_frequency(
            fmin, fmax, use_spline=use_spline, **kwargs
        )
        peak_period.name = &#34;peak period&#34;
        try:
            peak_period = peak_period.drop(&#34;frequency&#34;)
        except Exception:
            pass
        return peak_period

    def peak_direction(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        index = self.peak_index(fmin, fmax)
        return self._mean_direction(
            self.a1.isel(**{NAME_F: index}), self.b1.isel(**{NAME_F: index})
        )

    def peak_directional_spread(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        index = self.peak_index(fmin, fmax)
        a1 = self.a1.isel(**{NAME_F: index})
        b1 = self.b1.isel(**{NAME_F: index})
        return self._spread(a1, b1)

    @staticmethod
    def _mean_direction(a1: xarray.DataArray, b1: xarray.DataArray) -&gt; xarray.DataArray:
        return xarray.DataArray(np.arctan2(b1, a1) * 180 / np.pi)

    @staticmethod
    def _spread(a1: xarray.DataArray, b1: xarray.DataArray) -&gt; xarray.DataArray:
        return xarray.DataArray(
            np.sqrt(2 - 2 * np.sqrt(a1**2 + b1**2)) * 180 / np.pi
        )

    @property
    def mean_direction_per_frequency(self) -&gt; xarray.DataArray:
        return self._mean_direction(self.a1, self.b1)

    @property
    def mean_spread_per_frequency(self) -&gt; xarray.DataArray:
        return self._spread(self.a1, self.b1)

    def _spectral_weighted(self, property: xarray.DataArray, fmin=0, fmax=np.inf):
        range = {NAME_F: self._range(fmin, fmax)}

        property = property.fillna(0)
        return np.trapz(
            property.isel(**range) * self.e.isel(**range), self.frequency[range]
        ) / self.m0(fmin, fmax)

    def mean_direction(self, fmin=0, fmax=np.inf):
        return self._mean_direction(self.mean_a1(fmin, fmax), self.mean_b1(fmin, fmax))

    def mean_directional_spread(self, fmin=0, fmax=np.inf):
        return self._spread(self.mean_a1(fmin, fmax), self.mean_b1(fmin, fmax))

    def mean_a1(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.a1, fmin, fmax)

    def mean_b1(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.b1, fmin, fmax)

    def mean_a2(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.a2, fmin, fmax)

    def mean_b2(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.b2, fmin, fmax)

    @property
    def depth(self) -&gt; xarray.DataArray:
        depth = self.dataset[NAME_DEPTH]
        return xarray.where(depth.isnull(), np.inf, depth)

    @property
    def group_velocity(self) -&gt; xarray.DataArray:
        depth = self.depth.expand_dims(dim=NAME_F, axis=-1).values
        k = self.wavenumber.values
        depth = depth * np.ones(k.shape)

        # Construct the output coordinates and dimension of the data array
        return_dimensions = (*self.dims_space_time, NAME_F)
        coords = {}
        for dim in return_dimensions:
            coords[dim] = self.dataset[dim].values

        return xarray.DataArray(
            data=intrinsic_group_velocity(k, depth),
            dims=return_dimensions,
            coords=coords,
        )

    @property
    def wavenumber(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Determine the wavenumbers for the frequencies in the spectrum. Note that since
        the dispersion relation depends on depth the returned wavenumber array has the
        dimensions associated with the depth array by the frequency dimension.

        :return: wavenumbers
        &#34;&#34;&#34;

        # For numba (used in the dispersion relation) we need raw np arrays of
        # the correct dimension
        depth = self.depth.expand_dims(dim=NAME_F, axis=-1).values
        radian_frequency = self.radian_frequency.expand_dims(dim=self.depth.dims).values

        # Broadcasting does not work inside the numba implementaiton, we explicitly
        # need to construct arrays of the correct input dimension.
        depth_shape = depth.shape
        radian_frequency_shape = radian_frequency.shape

        depth = depth * np.ones(radian_frequency_shape)
        radian_frequency = np.ones(depth_shape) * radian_frequency

        # Construct the output coordinates and dimension of the data array
        return_dimensions = (*self.dims_space_time, NAME_F)
        coords = {}
        for dim in return_dimensions:
            coords[dim] = self.dataset[dim].values

        return xarray.DataArray(
            data=inverse_intrinsic_dispersion_relation(radian_frequency, depth),
            dims=return_dimensions,
            coords=coords,
        )

    @property
    def wavelength(self) -&gt; xarray.DataArray:
        return 2 * np.pi / self.wavenumber

    @property
    def peak_wavenumber(self) -&gt; xarray.DataArray:
        index = self.peak_index()
        # Construct the output coordinates and dimension of the data array
        coords = {}
        for dim in self.dims_space_time:
            coords[dim] = self.dataset[dim].values

        return xarray.DataArray(
            data=inverse_intrinsic_dispersion_relation(
                self.radian_frequency[index].values, self.depth.values
            ),
            dims=self.dims_space_time,
            coords=coords,
        )

    def bulk_variables(self) -&gt; xarray.Dataset:
        dataset = xarray.Dataset()
        dataset[&#34;significant_waveheight&#34;] = self.significant_waveheight
        dataset[&#34;mean_period&#34;] = self.mean_period
        dataset[&#34;peak_period&#34;] = self.peak_period()
        dataset[&#34;peak_direction&#34;] = self.peak_direction()
        dataset[&#34;peak_directional_spread&#34;] = self.peak_directional_spread()
        dataset[&#34;mean_direction&#34;] = self.mean_direction()
        dataset[&#34;mean_directional_spread&#34;] = self.mean_directional_spread()
        dataset[&#34;peak_frequency&#34;] = self.peak_frequency()
        dataset[&#34;latitude&#34;] = self.latitude
        dataset[&#34;longitude&#34;] = self.longitude
        dataset[&#34;timestamp&#34;] = self.time
        return dataset

    @property
    def significant_waveheight(self) -&gt; xarray.DataArray:
        return self.hm0()

    @property
    def mean_period(self) -&gt; xarray.DataArray:
        return self.tm01()

    @property
    def zero_crossing_period(self) -&gt; xarray.DataArray:
        return self.tm02()

    def cdf(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;

        :return:
        &#34;&#34;&#34;
        frequency_step = self.frequency_step
        integration_frequencies = np.concatenate(
            ([0], np.cumsum(frequency_step.values))
        )
        integration_frequencies = (
            integration_frequencies
            - frequency_step.values[0] / 2
            + self.frequency.values[0]
        )
        values = (self.variance_density * frequency_step).values

        frequency_axis = self.dims.index(NAME_F)

        cumsum = np.cumsum(values, axis=frequency_axis)
        # cumsum =  self.variance_density.cumulative_integrate(coord=NAME_F)
        # return cumsum
        shape = list(cumsum.shape)
        shape[frequency_axis] = 1

        cumsum = np.concatenate((np.zeros(shape), cumsum), axis=frequency_axis)

        coords = {str(coor): self.coords()[coor].values for coor in self.coords()}
        coords[NAME_F] = integration_frequencies
        return xarray.DataArray(data=cumsum, dims=self.dims, coords=coords)

    def interpolate(
        self,
        coordinates: Dict[str, Union[xarray.DataArray, np.ndarray]],
        extrapolation_value: float = 0.0,
    ):
        dataset = self.__class__(interpolate_dataset_grid(coordinates, self.dataset))
        dataset.fillna(extrapolation_value)
        return dataset

    def extrapolate_tail(
        self,
        end_frequency,
        power=None,
        tail_energy=None,
        tail_bounds=None,
        tail_moments=None,
        tail_frequency=None,
    ) -&gt; &#34;FrequencySpectrum&#34;:
        &#34;&#34;&#34;
        Extrapolate the tail using the given power
        :param end_frequency: frequency to extrapolate to
        :param power: power to use. If None, a best fit -4 or -5 tail is used.
        :return:
        &#34;&#34;&#34;
        e = self.e
        a1 = self.a1
        b1 = self.b1
        a2 = self.a2
        b2 = self.b2

        frequency = self.frequency.values
        frequency_delta = frequency[-1] - frequency[-2]
        n = int((end_frequency - frequency[-1]) / frequency_delta) + 1

        fstart = frequency[-1] + frequency_delta
        fend = frequency[-1] + n * frequency_delta

        if tail_frequency is None:
            tail_frequency = np.linspace(fstart, fend, n, endpoint=True)

        tail_frequency = xarray.DataArray(
            data=tail_frequency, coords={&#34;frequency&#34;: tail_frequency}, dims=&#34;frequency&#34;
        )
        variance_density = xarray.concat(
            (e, e.isel(frequency=-1) * xarray.zeros_like(tail_frequency)),
            dim=&#34;frequency&#34;,
        )

        tail_a1 = a1.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;a1&#34;]
        tail_b1 = b1.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;b1&#34;]
        tail_a2 = a2.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;a2&#34;]
        tail_b2 = b2.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;b2&#34;]

        a1 = xarray.concat(
            (a1, tail_a1 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )
        b1 = xarray.concat(
            (b1, tail_b1 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )
        a2 = xarray.concat(
            (a2, tail_a2 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )
        b2 = xarray.concat(
            (b2, tail_b2 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )

        if tail_energy is not None:
            if isinstance(tail_energy, xarray.DataArray):
                tail_energy = tail_energy.values

            tail_information = (tail_bounds, tail_energy)
        else:
            tail_information = None

        variance_density = xarray.DataArray(
            data=numba_fill_zeros_or_nan_in_tail(
                variance_density.values,
                variance_density.frequency.values,
                power,
                tail_information=tail_information,
            ),
            dims=a1.dims,
            coords=a1.coords,
        )

        dataset = xarray.Dataset(
            {
                &#34;variance_density&#34;: variance_density,
                &#34;a1&#34;: a1,
                &#34;b1&#34;: b1,
                &#34;a2&#34;: a2,
                &#34;b2&#34;: b2,
            }
        )

        for name in self.dataset:
            if name in SPECTRAL_VARS:
                continue
            else:
                dataset = dataset.assign({name: self.dataset[name]})

        return FrequencySpectrum(dataset)

    def bandpass(self, fmin: float = 0, fmax: float = np.inf):
        dataset = xarray.Dataset()

        for name in self.dataset:
            if name in SPECTRAL_VARS:
                data = self.dataset[name].where(
                    (self.frequency &gt;= fmin) &amp; (self.frequency &lt; fmax), drop=True
                )
                dataset = dataset.assign({name: data})
            else:
                dataset = dataset.assign({name: self.dataset[name]})
        cls = type(self)
        return cls(dataset)

    def interpolate_frequency(
        self,
        new_frequencies: Union[xarray.DataArray, np.ndarray],
        extrapolation_value: float = 0.0,
    ):
        obj = self.__class__(
            interpolate_dataset_along_axis(
                new_frequencies, self.dataset, coordinate_name=&#34;frequency&#34;
            )
        )
        obj.fillna(extrapolation_value)
        return obj

    def _range(self, fmin=0.0, fmax=np.inf) -&gt; np.ndarray:
        return (self.dataset[NAME_F].values &gt;= fmin) &amp; (
            self.dataset[NAME_F].values &lt; fmax
        )

    def save_as_netcdf(self, path):
        self.dataset.to_netcdf(path)

    def multiply(
        self,
        array: np.ndarray,
        dimensions: Optional[List[str]] = None,
        inplace: bool = False,
    ):
        &#34;&#34;&#34;
        Multiply the variance density with the given np array. Broadcasting is
        performed automatically if dimensions are provided. If no dimensions are
        provided the array needs to have the exact same shape as the variance
        density array.

        :param array: Array to multiply with variance density
        :param dimension: Dimensions of the array
        :return: self
        &#34;&#34;&#34;
        if inplace:
            output = self
        else:
            output = self.copy()

        coords = {}
        shape = array.shape
        if dimensions is None:
            if shape != self.shape():
                raise ValueError(
                    &#34;If no dimensions are provided the array must have the exact same&#34;
                    &#34;shape as the variance density array.&#34;
                )

            output.dataset[NAME_E] = self.dataset[NAME_E] * array
            return output

        if len(shape) != len(dimensions):
            raise ValueError(
                &#34;The dimensions of the input array must match the number of&#34;
                &#34;dimension labels&#34;
            )

        for length, dimension in zip(shape, dimensions):
            if dimension not in self.dims:
                raise ValueError(
                    f&#34;Dimension {dimension} not a valid dimension of the&#34;
                    &#34;spectral object.&#34;
                )
            coords[dimension] = self.dataset[dimension].values

            if len(self.dataset[dimension].values) != length:
                raise ValueError(
                    f&#34;Array length along the dimension {dimension} does not match the&#34;
                    &#34; length of the coordinate of the same name in the spctral object.&#34;
                )

        data = xarray.DataArray(data=array, coords=coords, dims=dimensions)
        output.dataset[NAME_E] = self.dataset[NAME_E] * data
        return output


class FrequencyDirectionSpectrum(WaveSpectrum):
    def __init__(self, dataset: xarray.Dataset):
        super(FrequencyDirectionSpectrum, self).__init__(dataset)
        for name in NAMES_2D:
            if name not in dataset and name not in dataset.coords:
                raise ValueError(
                    f&#34;Required variable/coordinate {name} is&#34;
                    f&#34; not specified in the dataset&#34;
                )

    def __len__(self):
        return int(np.prod(self.spectral_values.shape[:-2]))

    @property
    def direction_step(self) -&gt; xarray.DataArray:
        difference = wrapped_difference(
            np.diff(self.direction.values, append=self.direction[0]), period=360
        )
        return xarray.DataArray(
            data=difference, coords={NAME_D: self.direction.values}, dims=[NAME_D]
        )

    @property
    def radian_direction(self) -&gt; xarray.DataArray:
        data_array = self.dataset[NAME_D] * np.pi / 180
        data_array.name = &#34;radian_direction&#34;
        return data_array

    def _directionally_integrate(
        self, data_array: xarray.DataArray
    ) -&gt; xarray.DataArray:
        return (data_array * self.direction_step).sum(NAME_D, skipna=True)

    @property
    def e(self) -&gt; xarray.DataArray:
        return self._directionally_integrate(self.dataset[NAME_E])

    @property
    def a1(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.cos(self.radian_direction)
            )
            / self.e
        )

    @property
    def b1(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.sin(self.radian_direction)
            )
            / self.e
        )

    @property
    def a2(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.cos(2 * self.radian_direction)
            )
            / self.e
        )

    @property
    def b2(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.sin(2 * self.radian_direction)
            )
            / self.e
        )

    @property
    def direction(self) -&gt; xarray.DataArray:
        return self.dataset[NAME_D]

    def as_frequency_spectrum(self):
        dataset = {
            &#34;a1&#34;: self.a1,
            &#34;b1&#34;: self.b1,
            &#34;a2&#34;: self.a2,
            &#34;b2&#34;: self.b2,
            &#34;variance_density&#34;: self.e,
        }
        for name in self.dataset:
            if name not in SPECTRAL_VARS:
                dataset[str(name)] = self.dataset[name]

        return FrequencySpectrum(xarray.Dataset(dataset))

    def spectrum_1d(self):
        &#34;&#34;&#34;
        Will be depricated
        :return:
        &#34;&#34;&#34;
        warn(
            &#39;spectrum_1d method will be removed, use &#34;as_frequency_spectrum&#34; instead&#39;,
            DeprecationWarning,
            stacklevel=2,
        )
        return self.as_frequency_spectrum()

    def differentiate(self, coordinate=None, **kwargs) -&gt; &#34;FrequencyDirectionSpectrum&#34;:
        if coordinate is None:
            coordinate = &#34;time&#34;

        if coordinate not in self.dataset:
            raise ValueError(f&#34;Coordinate {coordinate} does not exist in the dataset&#34;)

        data = {
            NAME_E: (
                self.dims,
                self.variance_density.differentiate(
                    coordinate, datetime_unit=&#34;s&#34;, **kwargs
                ).values,
            )
        }
        for x in self.dataset:
            if x in SPECTRAL_VARS:
                continue
            data[x] = (self.dims_space_time, self.dataset[x].values)

        return FrequencyDirectionSpectrum(
            xarray.Dataset(data_vars=data, coords=self.coords())
        )

    @property
    def number_of_directions(self) -&gt; int:
        return len(self.direction)


class FrequencySpectrum(WaveSpectrum):
    def __init__(self, dataset: xarray.Dataset):
        super(FrequencySpectrum, self).__init__(dataset)
        for name in NAMES_1D:
            if name not in dataset and name not in dataset.coords:
                raise ValueError(
                    f&#34;Required variable/coordinate {name} is&#34;
                    f&#34; not specified in the dataset&#34;
                )

    def __len__(self):
        return int(np.prod(self.spectral_values.shape[:-1]))

    def interpolate_frequency(
        self: &#34;FrequencySpectrum&#34;,
        new_frequencies: Union[xarray.DataArray, np.ndarray],
        extrapolation_value=0.0,
        method: Literal[&#34;nearest&#34;, &#34;linear&#34;, &#34;spline&#34;] = &#34;linear&#34;,
        **kwargs,
    ) -&gt; &#34;FrequencySpectrum&#34;:
        if isinstance(new_frequencies, xarray.DataArray):
            new_frequencies = new_frequencies.values

        if method == &#34;spline&#34;:
            self.fillna(0.0)
            frequency_axis = self.dims.index(NAME_F)
            interpolated_data = cumulative_frequency_interpolation_1d_variable(
                new_frequencies, self.dataset, frequency_axis=frequency_axis, **kwargs
            )
            object = FrequencySpectrum(interpolated_data)
            object.fillna(extrapolation_value)
            return object
        elif method == &#34;linear&#34;:
            return self.interpolate(
                {NAME_F: new_frequencies},
                extrapolation_value=extrapolation_value,
                nearest_neighbour=False,
            )
        elif method == &#34;nearest&#34;:
            return self.interpolate(
                {NAME_F: new_frequencies},
                extrapolation_value=extrapolation_value,
                nearest_neighbour=True,
            )
        else:
            raise ValueError(f&#34;Unknown interpolation method: {method}&#34;)

    def interpolate(
        self: &#34;FrequencySpectrum&#34;,
        coordinates,
        extrapolation_value=0.0,
        nearest_neighbour=False,
    ) -&gt; &#34;FrequencySpectrum&#34;:
        &#34;&#34;&#34;

        :param coordinates:
        :return:
        &#34;&#34;&#34;
        _dataset = xarray.Dataset()
        _moments = [NAME_a1, NAME_b1, NAME_a2, NAME_b2]

        # For physical reasons it is better to interpolate the scaled moments -
        # as opposed to the normalized moments. For the dataset we interpolate
        # we set a1: to A1 etc. Afterwards we scale the output back to the normalized
        # state.
        for name in self.dataset:
            _name = str(name)
            if _name in _moments:
                _dataset = _dataset.assign({_name: getattr(self, _name) * self.e})
            else:
                _dataset = _dataset.assign({_name: self.dataset[_name]})

        interpolated_data = interpolate_dataset_grid(
            coordinates, _dataset, nearest_neighbour
        )
        for name in _moments:
            interpolated_data[name] = (
                interpolated_data[name] / interpolated_data[NAME_E]
            )

        object = FrequencySpectrum(interpolated_data)
        object.fillna(extrapolation_value)
        return object

    def down_sample(self, frequencies):
        cdf = self.cdf()

        frequency_step = midpoint_rule_step(frequencies)
        sampling_frequencies = np.concatenate(([0], np.cumsum(frequency_step)))
        sampling_frequencies = (
            sampling_frequencies - frequency_step[0] / 2 + frequencies[0]
        )

        dims = self.dims
        sampled_cdf = cdf.sel({&#34;frequency&#34;: sampling_frequencies}, method=&#34;nearest&#34;)
        data = {
            NAME_E: (dims, sampled_cdf.diff(dim=&#34;frequency&#34;).values / frequency_step),
            NAME_a1: (
                dims,
                self.a1.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
            NAME_b1: (
                dims,
                self.b1.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
            NAME_a2: (
                dims,
                self.a2.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
            NAME_b2: (
                dims,
                self.b2.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
        }

        coords = {x: self.dataset[x].values for x in self.dims}
        coords[NAME_F] = frequencies

        for x in self.dataset:
            if x in SPECTRAL_VARS:
                continue
            data[x] = (self.dims_space_time, self.dataset[x].values)

        return FrequencySpectrum(xarray.Dataset(data_vars=data, coords=coords))

    def as_frequency_direction_spectrum(
        self,
        number_of_directions,
        method: Estimators = &#34;mem2&#34;,
        solution_method=&#34;scipy&#34;,
    ) -&gt; &#34;FrequencyDirectionSpectrum&#34;:
        direction = np.linspace(0, 360, number_of_directions, endpoint=False)

        output_array = (
            estimate_directional_distribution(
                self.a1.values,
                self.b1.values,
                self.a2.values,
                self.b2.values,
                direction,
                method=method,
                solution_method=solution_method,
            )
            * self.e.values[..., None]
        )

        dims = self.dims_space_time + [NAME_F, NAME_D]
        coords = {x: self.dataset[x].values for x in self.dims}
        coords[NAME_D] = direction

        data = {NAME_E: (dims, output_array)}
        for x in self.dataset:
            if x in SPECTRAL_VARS:
                continue
            data[x] = (self.dims_space_time, self.dataset[x].values)

        return FrequencyDirectionSpectrum(xarray.Dataset(data_vars=data, coords=coords))


def create_1d_spectrum(
    frequency: np.ndarray,
    variance_density: np.ndarray,
    time: Union[np.ndarray, float],
    latitude: Union[np.ndarray, float],
    longitude: Union[np.ndarray, float],
    a1: Optional[np.ndarray] = None,
    b1: Optional[np.ndarray] = None,
    a2: Optional[np.ndarray] = None,
    b2: Optional[np.ndarray] = None,
    depth: Union[np.ndarray, float] = np.inf,
    dims=(NAME_T, NAME_F),
) -&gt; FrequencySpectrum:
    if a1 is None:
        a1 = np.nan + np.ones_like(variance_density)
    if b1 is None:
        b1 = np.nan + np.ones_like(variance_density)
    if a2 is None:
        a2 = np.nan + np.ones_like(variance_density)
    if b2 is None:
        b2 = np.nan + np.ones_like(variance_density)

    variables = {
        NAME_T: np.atleast_1d(to_datetime64(time)),
        NAME_LAT: np.atleast_1d(latitude),
        NAME_LON: np.atleast_1d(longitude),
        NAME_DEPTH: np.atleast_1d(depth),
        NAME_F: frequency,
        NAME_E: variance_density,
        NAME_a1: a1,
        NAME_b1: b1,
        NAME_a2: a2,
        NAME_b2: b2,
    }

    return FrequencySpectrum(create_spectrum_dataset(dims, variables))


def create_2d_spectrum(
    frequency: np.ndarray,
    direction: np.ndarray,
    variance_density: np.ndarray,
    time,
    latitude: Union[np.ndarray, float, None],
    longitude: Union[np.ndarray, float, None],
    dims=(NAME_T, NAME_F, NAME_D),
    depth: Union[np.ndarray, float] = np.inf,
) -&gt; FrequencyDirectionSpectrum:
    &#34;&#34;&#34;
    :param frequency:
    :param direction:
    :param variance_density:
    :param time:
    :param latitude:
    :param longitude:
    :param dims:
    :param depth:
    :return:
    &#34;&#34;&#34;

    variables = {
        NAME_T: np.atleast_1d(to_datetime64(time)),
        NAME_LAT: np.atleast_1d(latitude),
        NAME_LON: np.atleast_1d(longitude),
        NAME_DEPTH: np.atleast_1d(depth),
        NAME_F: frequency,
        NAME_D: direction,
        NAME_E: variance_density,
    }
    return FrequencyDirectionSpectrum(create_spectrum_dataset(dims, variables))


def create_spectrum_dataset(dims, variables) -&gt; xarray.Dataset:
    independent_variables = []
    for dim in dims:
        if dim in variables:
            independent_variables.append(dim)

    dependent_variables = [x for x in variables if x not in independent_variables]

    spectral_coords = {k: variables[k] for k in independent_variables}
    spatial_coords = {
        k: variables[k] for k in independent_variables if k not in SPECTRAL_DIMS
    }

    dataset = xarray.Dataset()
    for variable in dependent_variables:
        if variable in SPECTRAL_VARS:
            coords = spectral_coords
        else:
            coords = spatial_coords
        dims = [k for k in coords]

        if dims:
            dataset = dataset.assign(
                {
                    variable: xarray.DataArray(
                        data=variables[variable], dims=dims, coords=coords
                    )
                }
            )

        else:
            if len(variables[variable]) == 1:
                # If no coordinate is known, and the variable has length 1, we add it
                # as a scalar.
                data = variables[variable][0]
            else:
                # otherwise we add without coordinate/dimension.
                data = xarray.DataArray(data=variables[variable])

            dataset = dataset.assign({variable: data})
    return dataset


def load_spectrum_from_netcdf(
    filename_or_obj,
) -&gt; Union[FrequencySpectrum, FrequencyDirectionSpectrum]:
    &#34;&#34;&#34;
    Load a spectrum from netcdf file
    :param filename_or_obj:
    :return:
    &#34;&#34;&#34;
    dataset = xarray.open_dataset(filename_or_obj=filename_or_obj)
    if NAME_D in dataset.coords:
        return FrequencyDirectionSpectrum(dataset=dataset)
    else:
        return FrequencySpectrum(dataset=dataset)


def fill_zeros_or_nan_in_tail(
    spectrum: WaveSpectrum,
    power=None,
    tail_energy=None,
    tail_bounds=None,
) -&gt; FrequencySpectrum:
    variance_density = spectrum.e
    a1 = spectrum.a1
    b1 = spectrum.b1
    a2 = spectrum.a2
    b2 = spectrum.b2

    if tail_energy is not None:
        if isinstance(tail_energy, xarray.DataArray):
            tail_energy = tail_energy.values

        tail_information = (tail_bounds, tail_energy)
    else:
        tail_information = None

    variance_density = xarray.DataArray(
        data=numba_fill_zeros_or_nan_in_tail(
            variance_density.values,
            variance_density.frequency.values,
            power,
            tail_information=tail_information,
        ),
        dims=a1.dims,
        coords=a1.coords,
    )

    dataset = xarray.Dataset(
        {
            &#34;variance_density&#34;: variance_density,
            &#34;a1&#34;: a1,
            &#34;b1&#34;: b1,
            &#34;a2&#34;: a2,
            &#34;b2&#34;: b2,
        }
    )

    for name in spectrum.dataset:
        if name in SPECTRAL_VARS:
            continue
        else:
            dataset = dataset.assign({name: spectrum.dataset[name]})

    return FrequencySpectrum(dataset)


def cumulative_frequency_interpolation_1d_variable(
    interpolation_frequency, dataset: xarray.Dataset, **kwargs
):
    &#34;&#34;&#34;
    To interpolate the spectrum we first calculate a cumulative density function from
    the spectrum (which is essentialya pdf). We then interpolate the CDF function with
    a spline and differentiate the result.

    :param interpolation_frequency:
    :param dataset:
    :return:
    &#34;&#34;&#34;

    _dataset = xarray.Dataset()

    # Copy over all non spectral vars
    for name in dataset:
        _name = str(name)
        if _name not in SPECTRAL_VARS:
            _dataset = _dataset.assign({_name: dataset[_name]})

    coords = {
        str(_coor_name): dataset[str(_coor_name)]
        for _coor_name in dataset[NAME_E].coords
    }
    coords[NAME_F] = interpolation_frequency
    dims = dataset[NAME_E].dims

    # Interpolate energy
    interpolated_cdf_spline = _cdf_interpolate_spline(
        dataset[NAME_F].values,
        dataset[NAME_E].values,
        monotone_interpolation=kwargs.get(&#34;monotone_interpolation&#34;, True),
        frequency_axis=kwargs.get(&#34;frequency_axis&#34;, -1),
    )
    interpolated_energy = interpolated_cdf_spline.derivative()(interpolation_frequency)

    _dataset = _dataset.assign(
        {
            NAME_E: xarray.DataArray(
                data=interpolated_energy,
                coords=coords,
                dims=dims,
            )
        }
    )

    msk = interpolated_energy &gt; 0

    for _name in SPECTRAL_MOMENTS:
        interpolated_densities_spline = _cdf_interpolate_spline(
            dataset[NAME_F].values,
            dataset[_name].values * dataset[NAME_E].values,
            monotone_interpolation=kwargs.get(&#34;monotone_interpolation_moments&#34;, False),
        )
        interpolated_densities = interpolated_densities_spline.derivative()(
            interpolation_frequency
        )
        # Avoid division by zero
        interpolated_densities[msk] = (
            interpolated_densities[msk] / interpolated_energy[msk]
        )

        _dataset = _dataset.assign(
            {
                _name: xarray.DataArray(
                    data=interpolated_densities,
                    coords=coords,
                    dims=dims,
                )
            }
        )

    return _dataset</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.create_1d_spectrum"><code class="name flex">
<span>def <span class="ident">create_1d_spectrum</span></span>(<span>frequency:numpy.ndarray, variance_density:numpy.ndarray, time:Union[numpy.ndarray,float], latitude:Union[numpy.ndarray,float], longitude:Union[numpy.ndarray,float], a1:Optional[numpy.ndarray]=None, b1:Optional[numpy.ndarray]=None, a2:Optional[numpy.ndarray]=None, b2:Optional[numpy.ndarray]=None, depth:Union[numpy.ndarray,float]=inf, dims=('time', 'frequency')) ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_1d_spectrum(
    frequency: np.ndarray,
    variance_density: np.ndarray,
    time: Union[np.ndarray, float],
    latitude: Union[np.ndarray, float],
    longitude: Union[np.ndarray, float],
    a1: Optional[np.ndarray] = None,
    b1: Optional[np.ndarray] = None,
    a2: Optional[np.ndarray] = None,
    b2: Optional[np.ndarray] = None,
    depth: Union[np.ndarray, float] = np.inf,
    dims=(NAME_T, NAME_F),
) -&gt; FrequencySpectrum:
    if a1 is None:
        a1 = np.nan + np.ones_like(variance_density)
    if b1 is None:
        b1 = np.nan + np.ones_like(variance_density)
    if a2 is None:
        a2 = np.nan + np.ones_like(variance_density)
    if b2 is None:
        b2 = np.nan + np.ones_like(variance_density)

    variables = {
        NAME_T: np.atleast_1d(to_datetime64(time)),
        NAME_LAT: np.atleast_1d(latitude),
        NAME_LON: np.atleast_1d(longitude),
        NAME_DEPTH: np.atleast_1d(depth),
        NAME_F: frequency,
        NAME_E: variance_density,
        NAME_a1: a1,
        NAME_b1: b1,
        NAME_a2: a2,
        NAME_b2: b2,
    }

    return FrequencySpectrum(create_spectrum_dataset(dims, variables))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.create_2d_spectrum"><code class="name flex">
<span>def <span class="ident">create_2d_spectrum</span></span>(<span>frequency:numpy.ndarray, direction:numpy.ndarray, variance_density:numpy.ndarray, time, latitude:Union[numpy.ndarray,float,ForwardRef(None)], longitude:Union[numpy.ndarray,float,ForwardRef(None)], dims=('time', 'frequency', 'direction'), depth:Union[numpy.ndarray,float]=inf) ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum">FrequencyDirectionSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param frequency:
:param direction:
:param variance_density:
:param time:
:param latitude:
:param longitude:
:param dims:
:param depth:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_2d_spectrum(
    frequency: np.ndarray,
    direction: np.ndarray,
    variance_density: np.ndarray,
    time,
    latitude: Union[np.ndarray, float, None],
    longitude: Union[np.ndarray, float, None],
    dims=(NAME_T, NAME_F, NAME_D),
    depth: Union[np.ndarray, float] = np.inf,
) -&gt; FrequencyDirectionSpectrum:
    &#34;&#34;&#34;
    :param frequency:
    :param direction:
    :param variance_density:
    :param time:
    :param latitude:
    :param longitude:
    :param dims:
    :param depth:
    :return:
    &#34;&#34;&#34;

    variables = {
        NAME_T: np.atleast_1d(to_datetime64(time)),
        NAME_LAT: np.atleast_1d(latitude),
        NAME_LON: np.atleast_1d(longitude),
        NAME_DEPTH: np.atleast_1d(depth),
        NAME_F: frequency,
        NAME_D: direction,
        NAME_E: variance_density,
    }
    return FrequencyDirectionSpectrum(create_spectrum_dataset(dims, variables))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.create_spectrum_dataset"><code class="name flex">
<span>def <span class="ident">create_spectrum_dataset</span></span>(<span>dims, variables) >xarray.core.dataset.Dataset</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_spectrum_dataset(dims, variables) -&gt; xarray.Dataset:
    independent_variables = []
    for dim in dims:
        if dim in variables:
            independent_variables.append(dim)

    dependent_variables = [x for x in variables if x not in independent_variables]

    spectral_coords = {k: variables[k] for k in independent_variables}
    spatial_coords = {
        k: variables[k] for k in independent_variables if k not in SPECTRAL_DIMS
    }

    dataset = xarray.Dataset()
    for variable in dependent_variables:
        if variable in SPECTRAL_VARS:
            coords = spectral_coords
        else:
            coords = spatial_coords
        dims = [k for k in coords]

        if dims:
            dataset = dataset.assign(
                {
                    variable: xarray.DataArray(
                        data=variables[variable], dims=dims, coords=coords
                    )
                }
            )

        else:
            if len(variables[variable]) == 1:
                # If no coordinate is known, and the variable has length 1, we add it
                # as a scalar.
                data = variables[variable][0]
            else:
                # otherwise we add without coordinate/dimension.
                data = xarray.DataArray(data=variables[variable])

            dataset = dataset.assign({variable: data})
    return dataset</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.cumulative_frequency_interpolation_1d_variable"><code class="name flex">
<span>def <span class="ident">cumulative_frequency_interpolation_1d_variable</span></span>(<span>interpolation_frequency, dataset:xarray.core.dataset.Dataset, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>To interpolate the spectrum we first calculate a cumulative density function from
the spectrum (which is essentialya pdf). We then interpolate the CDF function with
a spline and differentiate the result.</p>
<p>:param interpolation_frequency:
:param dataset:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cumulative_frequency_interpolation_1d_variable(
    interpolation_frequency, dataset: xarray.Dataset, **kwargs
):
    &#34;&#34;&#34;
    To interpolate the spectrum we first calculate a cumulative density function from
    the spectrum (which is essentialya pdf). We then interpolate the CDF function with
    a spline and differentiate the result.

    :param interpolation_frequency:
    :param dataset:
    :return:
    &#34;&#34;&#34;

    _dataset = xarray.Dataset()

    # Copy over all non spectral vars
    for name in dataset:
        _name = str(name)
        if _name not in SPECTRAL_VARS:
            _dataset = _dataset.assign({_name: dataset[_name]})

    coords = {
        str(_coor_name): dataset[str(_coor_name)]
        for _coor_name in dataset[NAME_E].coords
    }
    coords[NAME_F] = interpolation_frequency
    dims = dataset[NAME_E].dims

    # Interpolate energy
    interpolated_cdf_spline = _cdf_interpolate_spline(
        dataset[NAME_F].values,
        dataset[NAME_E].values,
        monotone_interpolation=kwargs.get(&#34;monotone_interpolation&#34;, True),
        frequency_axis=kwargs.get(&#34;frequency_axis&#34;, -1),
    )
    interpolated_energy = interpolated_cdf_spline.derivative()(interpolation_frequency)

    _dataset = _dataset.assign(
        {
            NAME_E: xarray.DataArray(
                data=interpolated_energy,
                coords=coords,
                dims=dims,
            )
        }
    )

    msk = interpolated_energy &gt; 0

    for _name in SPECTRAL_MOMENTS:
        interpolated_densities_spline = _cdf_interpolate_spline(
            dataset[NAME_F].values,
            dataset[_name].values * dataset[NAME_E].values,
            monotone_interpolation=kwargs.get(&#34;monotone_interpolation_moments&#34;, False),
        )
        interpolated_densities = interpolated_densities_spline.derivative()(
            interpolation_frequency
        )
        # Avoid division by zero
        interpolated_densities[msk] = (
            interpolated_densities[msk] / interpolated_energy[msk]
        )

        _dataset = _dataset.assign(
            {
                _name: xarray.DataArray(
                    data=interpolated_densities,
                    coords=coords,
                    dims=dims,
                )
            }
        )

    return _dataset</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.fill_zeros_or_nan_in_tail"><code class="name flex">
<span>def <span class="ident">fill_zeros_or_nan_in_tail</span></span>(<span>spectrum:<a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum">WaveSpectrum</a>, power=None, tail_energy=None, tail_bounds=None) ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_zeros_or_nan_in_tail(
    spectrum: WaveSpectrum,
    power=None,
    tail_energy=None,
    tail_bounds=None,
) -&gt; FrequencySpectrum:
    variance_density = spectrum.e
    a1 = spectrum.a1
    b1 = spectrum.b1
    a2 = spectrum.a2
    b2 = spectrum.b2

    if tail_energy is not None:
        if isinstance(tail_energy, xarray.DataArray):
            tail_energy = tail_energy.values

        tail_information = (tail_bounds, tail_energy)
    else:
        tail_information = None

    variance_density = xarray.DataArray(
        data=numba_fill_zeros_or_nan_in_tail(
            variance_density.values,
            variance_density.frequency.values,
            power,
            tail_information=tail_information,
        ),
        dims=a1.dims,
        coords=a1.coords,
    )

    dataset = xarray.Dataset(
        {
            &#34;variance_density&#34;: variance_density,
            &#34;a1&#34;: a1,
            &#34;b1&#34;: b1,
            &#34;a2&#34;: a2,
            &#34;b2&#34;: b2,
        }
    )

    for name in spectrum.dataset:
        if name in SPECTRAL_VARS:
            continue
        else:
            dataset = dataset.assign({name: spectrum.dataset[name]})

    return FrequencySpectrum(dataset)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.load_spectrum_from_netcdf"><code class="name flex">
<span>def <span class="ident">load_spectrum_from_netcdf</span></span>(<span>filename_or_obj) >Union[<a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a>,<a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum">FrequencyDirectionSpectrum</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Load a spectrum from netcdf file
:param filename_or_obj:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_spectrum_from_netcdf(
    filename_or_obj,
) -&gt; Union[FrequencySpectrum, FrequencyDirectionSpectrum]:
    &#34;&#34;&#34;
    Load a spectrum from netcdf file
    :param filename_or_obj:
    :return:
    &#34;&#34;&#34;
    dataset = xarray.open_dataset(filename_or_obj=filename_or_obj)
    if NAME_D in dataset.coords:
        return FrequencyDirectionSpectrum(dataset=dataset)
    else:
        return FrequencySpectrum(dataset=dataset)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper"><code class="flex name class">
<span>class <span class="ident">DatasetWrapper</span></span>
<span>(</span><span>dataset:xarray.core.dataset.Dataset)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps a dataset object and passes through some of its primary
functionality (get/set etc.). Used here mostly to make explicit what parts
of the Dataset interface we actually expose in frequency objects. Note that
we do not claim- or try to obtain completeness here. If full capabilities
of the dataset object are needed we can simple operate directly on the
dataset object itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatasetWrapper:
    &#34;&#34;&#34;
    A class that wraps a dataset object and passes through some of its primary
    functionality (get/set etc.). Used here mostly to make explicit what parts
    of the Dataset interface we actually expose in frequency objects. Note that
    we do not claim- or try to obtain completeness here. If full capabilities
    of the dataset object are needed we can simple operate directly on the
    dataset object itself.
    &#34;&#34;&#34;

    def __init__(self, dataset: xarray.Dataset):
        self.dataset = dataset

    def __getitem__(self, item) -&gt; xarray.DataArray:
        return self.dataset.__getitem__(item)

    def __setitem__(self, key, value) -&gt; None:
        return self.dataset.__setitem__(key, value)

    def __copy__(self):
        cls = self.__class__
        return cls(self.dataset.copy())

    def __len__(self) -&gt; int:
        return len(self.dataset)

    def copy(self, deep=True):
        if deep:
            return self.__deepcopy__({})
        else:
            return self.__copy__()

    def __deepcopy__(self, memodict):
        cls = self.__class__
        return cls(self.dataset.copy(deep=True))

    def coords(self) -&gt; xarray.core.coordinates.DatasetCoordinates:
        return self.dataset.coords

    def keys(self):
        return self.dataset.keys()

    def __contains__(self, key: object) -&gt; bool:
        return key in self.dataset

    def __iter__(self) -&gt; Iterator[Hashable]:
        return self.dataset.__iter__()

    def sel(self, *args, method=&#34;nearest&#34;):
        cls = type(self)
        dataset = xarray.Dataset()
        for var in self.dataset:
            dataset = dataset.assign({var: self.dataset[var].sel(*args, method=method)})
        return cls(dataset=dataset)

    def isel(self, *args, **kwargs):
        cls = type(self)
        dataset = xarray.Dataset()
        for var in self.dataset:
            dataset = dataset.assign({var: self.dataset[var].isel(*args, **kwargs)})
        return cls(dataset=dataset)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum">WaveSpectrum</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.coords"><code class="name flex">
<span>def <span class="ident">coords</span></span>(<span>self) >xarray.core.coordinates.DatasetCoordinates</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coords(self) -&gt; xarray.core.coordinates.DatasetCoordinates:
    return self.dataset.coords</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, deep=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, deep=True):
    if deep:
        return self.__deepcopy__({})
    else:
        return self.__copy__()</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.isel"><code class="name flex">
<span>def <span class="ident">isel</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isel(self, *args, **kwargs):
    cls = type(self)
    dataset = xarray.Dataset()
    for var in self.dataset:
        dataset = dataset.assign({var: self.dataset[var].isel(*args, **kwargs)})
    return cls(dataset=dataset)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    return self.dataset.keys()</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.sel"><code class="name flex">
<span>def <span class="ident">sel</span></span>(<span>self, *args, method='nearest')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sel(self, *args, method=&#34;nearest&#34;):
    cls = type(self)
    dataset = xarray.Dataset()
    for var in self.dataset:
        dataset = dataset.assign({var: self.dataset[var].sel(*args, method=method)})
    return cls(dataset=dataset)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum"><code class="flex name class">
<span>class <span class="ident">FrequencyDirectionSpectrum</span></span>
<span>(</span><span>dataset:xarray.core.dataset.Dataset)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps a dataset object and passes through some of its primary
functionality (get/set etc.). Used here mostly to make explicit what parts
of the Dataset interface we actually expose in frequency objects. Note that
we do not claim- or try to obtain completeness here. If full capabilities
of the dataset object are needed we can simple operate directly on the
dataset object itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrequencyDirectionSpectrum(WaveSpectrum):
    def __init__(self, dataset: xarray.Dataset):
        super(FrequencyDirectionSpectrum, self).__init__(dataset)
        for name in NAMES_2D:
            if name not in dataset and name not in dataset.coords:
                raise ValueError(
                    f&#34;Required variable/coordinate {name} is&#34;
                    f&#34; not specified in the dataset&#34;
                )

    def __len__(self):
        return int(np.prod(self.spectral_values.shape[:-2]))

    @property
    def direction_step(self) -&gt; xarray.DataArray:
        difference = wrapped_difference(
            np.diff(self.direction.values, append=self.direction[0]), period=360
        )
        return xarray.DataArray(
            data=difference, coords={NAME_D: self.direction.values}, dims=[NAME_D]
        )

    @property
    def radian_direction(self) -&gt; xarray.DataArray:
        data_array = self.dataset[NAME_D] * np.pi / 180
        data_array.name = &#34;radian_direction&#34;
        return data_array

    def _directionally_integrate(
        self, data_array: xarray.DataArray
    ) -&gt; xarray.DataArray:
        return (data_array * self.direction_step).sum(NAME_D, skipna=True)

    @property
    def e(self) -&gt; xarray.DataArray:
        return self._directionally_integrate(self.dataset[NAME_E])

    @property
    def a1(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.cos(self.radian_direction)
            )
            / self.e
        )

    @property
    def b1(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.sin(self.radian_direction)
            )
            / self.e
        )

    @property
    def a2(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.cos(2 * self.radian_direction)
            )
            / self.e
        )

    @property
    def b2(self) -&gt; xarray.DataArray:
        return (
            self._directionally_integrate(
                self.dataset[NAME_E] * np.sin(2 * self.radian_direction)
            )
            / self.e
        )

    @property
    def direction(self) -&gt; xarray.DataArray:
        return self.dataset[NAME_D]

    def as_frequency_spectrum(self):
        dataset = {
            &#34;a1&#34;: self.a1,
            &#34;b1&#34;: self.b1,
            &#34;a2&#34;: self.a2,
            &#34;b2&#34;: self.b2,
            &#34;variance_density&#34;: self.e,
        }
        for name in self.dataset:
            if name not in SPECTRAL_VARS:
                dataset[str(name)] = self.dataset[name]

        return FrequencySpectrum(xarray.Dataset(dataset))

    def spectrum_1d(self):
        &#34;&#34;&#34;
        Will be depricated
        :return:
        &#34;&#34;&#34;
        warn(
            &#39;spectrum_1d method will be removed, use &#34;as_frequency_spectrum&#34; instead&#39;,
            DeprecationWarning,
            stacklevel=2,
        )
        return self.as_frequency_spectrum()

    def differentiate(self, coordinate=None, **kwargs) -&gt; &#34;FrequencyDirectionSpectrum&#34;:
        if coordinate is None:
            coordinate = &#34;time&#34;

        if coordinate not in self.dataset:
            raise ValueError(f&#34;Coordinate {coordinate} does not exist in the dataset&#34;)

        data = {
            NAME_E: (
                self.dims,
                self.variance_density.differentiate(
                    coordinate, datetime_unit=&#34;s&#34;, **kwargs
                ).values,
            )
        }
        for x in self.dataset:
            if x in SPECTRAL_VARS:
                continue
            data[x] = (self.dims_space_time, self.dataset[x].values)

        return FrequencyDirectionSpectrum(
            xarray.Dataset(data_vars=data, coords=self.coords())
        )

    @property
    def number_of_directions(self) -&gt; int:
        return len(self.direction)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum">WaveSpectrum</a></li>
<li><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper">DatasetWrapper</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.direction"><code class="name">var <span class="ident">direction</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def direction(self) -&gt; xarray.DataArray:
    return self.dataset[NAME_D]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.direction_step"><code class="name">var <span class="ident">direction_step</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def direction_step(self) -&gt; xarray.DataArray:
    difference = wrapped_difference(
        np.diff(self.direction.values, append=self.direction[0]), period=360
    )
    return xarray.DataArray(
        data=difference, coords={NAME_D: self.direction.values}, dims=[NAME_D]
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.number_of_directions"><code class="name">var <span class="ident">number_of_directions</span> :int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_of_directions(self) -&gt; int:
    return len(self.direction)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.radian_direction"><code class="name">var <span class="ident">radian_direction</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radian_direction(self) -&gt; xarray.DataArray:
    data_array = self.dataset[NAME_D] * np.pi / 180
    data_array.name = &#34;radian_direction&#34;
    return data_array</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.as_frequency_spectrum"><code class="name flex">
<span>def <span class="ident">as_frequency_spectrum</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_frequency_spectrum(self):
    dataset = {
        &#34;a1&#34;: self.a1,
        &#34;b1&#34;: self.b1,
        &#34;a2&#34;: self.a2,
        &#34;b2&#34;: self.b2,
        &#34;variance_density&#34;: self.e,
    }
    for name in self.dataset:
        if name not in SPECTRAL_VARS:
            dataset[str(name)] = self.dataset[name]

    return FrequencySpectrum(xarray.Dataset(dataset))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.differentiate"><code class="name flex">
<span>def <span class="ident">differentiate</span></span>(<span>self, coordinate=None, **kwargs) ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum">FrequencyDirectionSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def differentiate(self, coordinate=None, **kwargs) -&gt; &#34;FrequencyDirectionSpectrum&#34;:
    if coordinate is None:
        coordinate = &#34;time&#34;

    if coordinate not in self.dataset:
        raise ValueError(f&#34;Coordinate {coordinate} does not exist in the dataset&#34;)

    data = {
        NAME_E: (
            self.dims,
            self.variance_density.differentiate(
                coordinate, datetime_unit=&#34;s&#34;, **kwargs
            ).values,
        )
    }
    for x in self.dataset:
        if x in SPECTRAL_VARS:
            continue
        data[x] = (self.dims_space_time, self.dataset[x].values)

    return FrequencyDirectionSpectrum(
        xarray.Dataset(data_vars=data, coords=self.coords())
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.spectrum_1d"><code class="name flex">
<span>def <span class="ident">spectrum_1d</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Will be depricated
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spectrum_1d(self):
    &#34;&#34;&#34;
    Will be depricated
    :return:
    &#34;&#34;&#34;
    warn(
        &#39;spectrum_1d method will be removed, use &#34;as_frequency_spectrum&#34; instead&#39;,
        DeprecationWarning,
        stacklevel=2,
    )
    return self.as_frequency_spectrum()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum">WaveSpectrum</a></b></code>:
<ul class="hlist">
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A1">A1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A2">A2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B1">B1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B2">B2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a1">a1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a2">a2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b1">b1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b2">b2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.cdf" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.cdf">cdf</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.e" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.e">e</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.extrapolate_tail" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.extrapolate_tail">extrapolate_tail</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.flatten" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.flatten">flatten</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency">frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_moment" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_moment">frequency_moment</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.hm0" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.hm0">hm0</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.latitude" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.latitude">latitude</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.longitude" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.longitude">longitude</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m0" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m0">m0</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m1">m1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m2">m2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean">mean</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.multiply" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.multiply">multiply</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_frequencies" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_frequencies">number_of_frequencies</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_angular_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_angular_frequency">peak_angular_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_frequency">peak_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_index" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_index">peak_index</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_period" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_period">peak_period</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.radian_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.radian_frequency">radian_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_values" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_values">spectral_values</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.std" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.std">std</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.sum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.sum">sum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.time" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.time">time</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm01" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm01">tm01</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm02" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm02">tm02</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.values" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.values">values</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.variance_density" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.variance_density">variance_density</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_speed" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_speed">wave_speed</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber">wavenumber</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum"><code class="flex name class">
<span>class <span class="ident">FrequencySpectrum</span></span>
<span>(</span><span>dataset:xarray.core.dataset.Dataset)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps a dataset object and passes through some of its primary
functionality (get/set etc.). Used here mostly to make explicit what parts
of the Dataset interface we actually expose in frequency objects. Note that
we do not claim- or try to obtain completeness here. If full capabilities
of the dataset object are needed we can simple operate directly on the
dataset object itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FrequencySpectrum(WaveSpectrum):
    def __init__(self, dataset: xarray.Dataset):
        super(FrequencySpectrum, self).__init__(dataset)
        for name in NAMES_1D:
            if name not in dataset and name not in dataset.coords:
                raise ValueError(
                    f&#34;Required variable/coordinate {name} is&#34;
                    f&#34; not specified in the dataset&#34;
                )

    def __len__(self):
        return int(np.prod(self.spectral_values.shape[:-1]))

    def interpolate_frequency(
        self: &#34;FrequencySpectrum&#34;,
        new_frequencies: Union[xarray.DataArray, np.ndarray],
        extrapolation_value=0.0,
        method: Literal[&#34;nearest&#34;, &#34;linear&#34;, &#34;spline&#34;] = &#34;linear&#34;,
        **kwargs,
    ) -&gt; &#34;FrequencySpectrum&#34;:
        if isinstance(new_frequencies, xarray.DataArray):
            new_frequencies = new_frequencies.values

        if method == &#34;spline&#34;:
            self.fillna(0.0)
            frequency_axis = self.dims.index(NAME_F)
            interpolated_data = cumulative_frequency_interpolation_1d_variable(
                new_frequencies, self.dataset, frequency_axis=frequency_axis, **kwargs
            )
            object = FrequencySpectrum(interpolated_data)
            object.fillna(extrapolation_value)
            return object
        elif method == &#34;linear&#34;:
            return self.interpolate(
                {NAME_F: new_frequencies},
                extrapolation_value=extrapolation_value,
                nearest_neighbour=False,
            )
        elif method == &#34;nearest&#34;:
            return self.interpolate(
                {NAME_F: new_frequencies},
                extrapolation_value=extrapolation_value,
                nearest_neighbour=True,
            )
        else:
            raise ValueError(f&#34;Unknown interpolation method: {method}&#34;)

    def interpolate(
        self: &#34;FrequencySpectrum&#34;,
        coordinates,
        extrapolation_value=0.0,
        nearest_neighbour=False,
    ) -&gt; &#34;FrequencySpectrum&#34;:
        &#34;&#34;&#34;

        :param coordinates:
        :return:
        &#34;&#34;&#34;
        _dataset = xarray.Dataset()
        _moments = [NAME_a1, NAME_b1, NAME_a2, NAME_b2]

        # For physical reasons it is better to interpolate the scaled moments -
        # as opposed to the normalized moments. For the dataset we interpolate
        # we set a1: to A1 etc. Afterwards we scale the output back to the normalized
        # state.
        for name in self.dataset:
            _name = str(name)
            if _name in _moments:
                _dataset = _dataset.assign({_name: getattr(self, _name) * self.e})
            else:
                _dataset = _dataset.assign({_name: self.dataset[_name]})

        interpolated_data = interpolate_dataset_grid(
            coordinates, _dataset, nearest_neighbour
        )
        for name in _moments:
            interpolated_data[name] = (
                interpolated_data[name] / interpolated_data[NAME_E]
            )

        object = FrequencySpectrum(interpolated_data)
        object.fillna(extrapolation_value)
        return object

    def down_sample(self, frequencies):
        cdf = self.cdf()

        frequency_step = midpoint_rule_step(frequencies)
        sampling_frequencies = np.concatenate(([0], np.cumsum(frequency_step)))
        sampling_frequencies = (
            sampling_frequencies - frequency_step[0] / 2 + frequencies[0]
        )

        dims = self.dims
        sampled_cdf = cdf.sel({&#34;frequency&#34;: sampling_frequencies}, method=&#34;nearest&#34;)
        data = {
            NAME_E: (dims, sampled_cdf.diff(dim=&#34;frequency&#34;).values / frequency_step),
            NAME_a1: (
                dims,
                self.a1.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
            NAME_b1: (
                dims,
                self.b1.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
            NAME_a2: (
                dims,
                self.a2.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
            NAME_b2: (
                dims,
                self.b2.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
            ),
        }

        coords = {x: self.dataset[x].values for x in self.dims}
        coords[NAME_F] = frequencies

        for x in self.dataset:
            if x in SPECTRAL_VARS:
                continue
            data[x] = (self.dims_space_time, self.dataset[x].values)

        return FrequencySpectrum(xarray.Dataset(data_vars=data, coords=coords))

    def as_frequency_direction_spectrum(
        self,
        number_of_directions,
        method: Estimators = &#34;mem2&#34;,
        solution_method=&#34;scipy&#34;,
    ) -&gt; &#34;FrequencyDirectionSpectrum&#34;:
        direction = np.linspace(0, 360, number_of_directions, endpoint=False)

        output_array = (
            estimate_directional_distribution(
                self.a1.values,
                self.b1.values,
                self.a2.values,
                self.b2.values,
                direction,
                method=method,
                solution_method=solution_method,
            )
            * self.e.values[..., None]
        )

        dims = self.dims_space_time + [NAME_F, NAME_D]
        coords = {x: self.dataset[x].values for x in self.dims}
        coords[NAME_D] = direction

        data = {NAME_E: (dims, output_array)}
        for x in self.dataset:
            if x in SPECTRAL_VARS:
                continue
            data[x] = (self.dims_space_time, self.dataset[x].values)

        return FrequencyDirectionSpectrum(xarray.Dataset(data_vars=data, coords=coords))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum">WaveSpectrum</a></li>
<li><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper">DatasetWrapper</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.as_frequency_direction_spectrum"><code class="name flex">
<span>def <span class="ident">as_frequency_direction_spectrum</span></span>(<span>self, number_of_directions, method:Literal['mem','mem2']='mem2', solution_method='scipy') ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum">FrequencyDirectionSpectrum</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_frequency_direction_spectrum(
    self,
    number_of_directions,
    method: Estimators = &#34;mem2&#34;,
    solution_method=&#34;scipy&#34;,
) -&gt; &#34;FrequencyDirectionSpectrum&#34;:
    direction = np.linspace(0, 360, number_of_directions, endpoint=False)

    output_array = (
        estimate_directional_distribution(
            self.a1.values,
            self.b1.values,
            self.a2.values,
            self.b2.values,
            direction,
            method=method,
            solution_method=solution_method,
        )
        * self.e.values[..., None]
    )

    dims = self.dims_space_time + [NAME_F, NAME_D]
    coords = {x: self.dataset[x].values for x in self.dims}
    coords[NAME_D] = direction

    data = {NAME_E: (dims, output_array)}
    for x in self.dataset:
        if x in SPECTRAL_VARS:
            continue
        data[x] = (self.dims_space_time, self.dataset[x].values)

    return FrequencyDirectionSpectrum(xarray.Dataset(data_vars=data, coords=coords))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.down_sample"><code class="name flex">
<span>def <span class="ident">down_sample</span></span>(<span>self, frequencies)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def down_sample(self, frequencies):
    cdf = self.cdf()

    frequency_step = midpoint_rule_step(frequencies)
    sampling_frequencies = np.concatenate(([0], np.cumsum(frequency_step)))
    sampling_frequencies = (
        sampling_frequencies - frequency_step[0] / 2 + frequencies[0]
    )

    dims = self.dims
    sampled_cdf = cdf.sel({&#34;frequency&#34;: sampling_frequencies}, method=&#34;nearest&#34;)
    data = {
        NAME_E: (dims, sampled_cdf.diff(dim=&#34;frequency&#34;).values / frequency_step),
        NAME_a1: (
            dims,
            self.a1.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
        ),
        NAME_b1: (
            dims,
            self.b1.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
        ),
        NAME_a2: (
            dims,
            self.a2.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
        ),
        NAME_b2: (
            dims,
            self.b2.sel({&#34;frequency&#34;: frequencies}, method=&#34;nearest&#34;).values,
        ),
    }

    coords = {x: self.dataset[x].values for x in self.dims}
    coords[NAME_F] = frequencies

    for x in self.dataset:
        if x in SPECTRAL_VARS:
            continue
        data[x] = (self.dims_space_time, self.dataset[x].values)

    return FrequencySpectrum(xarray.Dataset(data_vars=data, coords=coords))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self:<a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a>, coordinates, extrapolation_value=0.0, nearest_neighbour=False) ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>:param coordinates:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(
    self: &#34;FrequencySpectrum&#34;,
    coordinates,
    extrapolation_value=0.0,
    nearest_neighbour=False,
) -&gt; &#34;FrequencySpectrum&#34;:
    &#34;&#34;&#34;

    :param coordinates:
    :return:
    &#34;&#34;&#34;
    _dataset = xarray.Dataset()
    _moments = [NAME_a1, NAME_b1, NAME_a2, NAME_b2]

    # For physical reasons it is better to interpolate the scaled moments -
    # as opposed to the normalized moments. For the dataset we interpolate
    # we set a1: to A1 etc. Afterwards we scale the output back to the normalized
    # state.
    for name in self.dataset:
        _name = str(name)
        if _name in _moments:
            _dataset = _dataset.assign({_name: getattr(self, _name) * self.e})
        else:
            _dataset = _dataset.assign({_name: self.dataset[_name]})

    interpolated_data = interpolate_dataset_grid(
        coordinates, _dataset, nearest_neighbour
    )
    for name in _moments:
        interpolated_data[name] = (
            interpolated_data[name] / interpolated_data[NAME_E]
        )

    object = FrequencySpectrum(interpolated_data)
    object.fillna(extrapolation_value)
    return object</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.interpolate_frequency"><code class="name flex">
<span>def <span class="ident">interpolate_frequency</span></span>(<span>self:<a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a>, new_frequencies:Union[xarray.core.dataarray.DataArray,numpy.ndarray], extrapolation_value=0.0, method:Literal['nearest','linear','spline']='linear', **kwargs) ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_frequency(
    self: &#34;FrequencySpectrum&#34;,
    new_frequencies: Union[xarray.DataArray, np.ndarray],
    extrapolation_value=0.0,
    method: Literal[&#34;nearest&#34;, &#34;linear&#34;, &#34;spline&#34;] = &#34;linear&#34;,
    **kwargs,
) -&gt; &#34;FrequencySpectrum&#34;:
    if isinstance(new_frequencies, xarray.DataArray):
        new_frequencies = new_frequencies.values

    if method == &#34;spline&#34;:
        self.fillna(0.0)
        frequency_axis = self.dims.index(NAME_F)
        interpolated_data = cumulative_frequency_interpolation_1d_variable(
            new_frequencies, self.dataset, frequency_axis=frequency_axis, **kwargs
        )
        object = FrequencySpectrum(interpolated_data)
        object.fillna(extrapolation_value)
        return object
    elif method == &#34;linear&#34;:
        return self.interpolate(
            {NAME_F: new_frequencies},
            extrapolation_value=extrapolation_value,
            nearest_neighbour=False,
        )
    elif method == &#34;nearest&#34;:
        return self.interpolate(
            {NAME_F: new_frequencies},
            extrapolation_value=extrapolation_value,
            nearest_neighbour=True,
        )
    else:
        raise ValueError(f&#34;Unknown interpolation method: {method}&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum">WaveSpectrum</a></b></code>:
<ul class="hlist">
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A1">A1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A2">A2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B1">B1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B2">B2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a1">a1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a2">a2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b1">b1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b2">b2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.cdf" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.cdf">cdf</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.e" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.e">e</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.extrapolate_tail" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.extrapolate_tail">extrapolate_tail</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.flatten" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.flatten">flatten</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency">frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_moment" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_moment">frequency_moment</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.hm0" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.hm0">hm0</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.latitude" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.latitude">latitude</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.longitude" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.longitude">longitude</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m0" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m0">m0</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m1">m1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m2">m2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean">mean</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.multiply" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.multiply">multiply</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_frequencies" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_frequencies">number_of_frequencies</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_angular_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_angular_frequency">peak_angular_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_frequency">peak_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_index" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_index">peak_index</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_period" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_period">peak_period</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.radian_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.radian_frequency">radian_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_values" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_values">spectral_values</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.std" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.std">std</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.sum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.sum">sum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.time" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.time">time</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm01" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm01">tm01</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm02" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm02">tm02</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.values" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.values">values</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.variance_density" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.variance_density">variance_density</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_speed" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_speed">wave_speed</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber">wavenumber</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum"><code class="flex name class">
<span>class <span class="ident">WaveSpectrum</span></span>
<span>(</span><span>dataset:xarray.core.dataset.Dataset)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that wraps a dataset object and passes through some of its primary
functionality (get/set etc.). Used here mostly to make explicit what parts
of the Dataset interface we actually expose in frequency objects. Note that
we do not claim- or try to obtain completeness here. If full capabilities
of the dataset object are needed we can simple operate directly on the
dataset object itself.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WaveSpectrum(DatasetWrapper):
    frequency_units = &#34;Hertz&#34;
    angular_units = &#34;Degrees&#34;
    spectral_density_units = &#34;m**2/Hertz&#34;
    angular_convention = (
        &#34;Wave travel direction (going-to), measured anti-clockwise from East&#34;
    )
    bulk_properties = (
        &#34;m0&#34;,
        &#34;hm0&#34;,
        &#34;tm01&#34;,
        &#34;tm02&#34;,
        &#34;peak_period&#34;,
        &#34;peak_direction&#34;,
        &#34;peak_directional_spread&#34;,
        &#34;mean_direction&#34;,
        &#34;mean_directional_spread&#34;,
        &#34;peak_frequency&#34;,
        &#34;peak_wavenumber&#34;,
        &#34;latitude&#34;,
        &#34;longitude&#34;,
        &#34;time&#34;,
    )

    def __init__(self, dataset: xarray.Dataset):
        super(WaveSpectrum, self).__init__(dataset)

    def __add__(self, other):
        cls = type(self)
        spectrum = cls(self.copy(deep=True).dataset)
        spectrum.dataset[NAME_E] = spectrum.dataset[NAME_E] + other.dataset[NAME_E]
        return spectrum

    def __sub__(self, other):
        cls = type(self)
        spectrum = cls(self.copy(deep=True).dataset)
        spectrum.dataset[NAME_E] = spectrum.dataset[NAME_E] - other.dataset[NAME_E]
        return spectrum

    def __neg__(self):
        &#34;&#34;&#34;
        Negate self- that is -spectrum
        :return: spectrum with all spectral values taken to have the opposite
            sign.
        &#34;&#34;&#34;
        cls = type(self)
        spectrum = cls(self.copy(deep=True).dataset)
        spectrum.dataset[NAME_E] = -spectrum.dataset[NAME_E]
        return spectrum

    def __len__(self) -&gt; int:
        return self.number_of_spectra

    def __getitem__(self, item) -&gt; xarray.DataArray:
        if isinstance(item, tuple):
            if len(item) &lt; self.ndims:
                raise ValueError(
                    &#34;Indexing requires same number of inputs&#34;
                    f&#34;as dimensions: {self.ndims}&#34;
                )
            space_time_index = item[: -len(self.dims_spectral)]
        else:
            if not self.ndims == 1:
                raise ValueError(
                    &#34;Indexing requires same number of inputs&#34;
                    f&#34;as dimensions: {self.ndims}&#34;
                )
            space_time_index = []

        dataset = xarray.Dataset()
        for var in self.dataset:
            if var in SPECTRAL_VARS:
                dataset = dataset.assign({var: self.dataset[var].__getitem__(item)})
            else:
                if space_time_index:
                    # array
                    dataset = dataset.assign(
                        {var: self.dataset[var].__getitem__(space_time_index)}
                    )
                else:
                    # Scalar
                    dataset = dataset.assign({var: self.dataset[var]})

        for coor in dataset.coords:
            if coor not in dataset.dims:
                dataset = dataset.reset_coords(str(coor))

        cls = type(self)
        return cls(dataset)

    @property
    def ndims(self) -&gt; int:
        return len(self.dims)

    @property
    def frequency_step(self) -&gt; xarray.DataArray:
        prepend = 2 * self.frequency[0] - self.frequency[1]
        append = 2 * self.frequency[-1] - self.frequency[-2]
        diff = np.diff(self.frequency, append=append, prepend=prepend)
        return xarray.DataArray(
            data=(diff[0:-1] * 0.5 + diff[1:] * 0.5),
            dims=NAME_F,
            coords={NAME_F: self.frequency},
        )

    def fillna(self, value=0.0):
        for variable in SPECTRAL_VARS:
            if variable in self.dataset:
                self.dataset[variable] = self.dataset[variable].fillna(value)

    def is_invalid(self) -&gt; xarray.DataArray:
        return self.variance_density.isnull().all(dim=self.dims_spectral)

    def is_valid(self) -&gt; xarray.DataArray:
        return ~self.is_invalid()

    def drop_invalid(self):
        return self._apply_filter(self.is_valid())

    def where(self, condition: xarray.DataArray):
        return self._apply_filter(condition)

    def _apply_filter(self, boolean_mask: xarray.DataArray):
        dataset = xarray.Dataset()
        for var in self.dataset:
            data = self.dataset[var].where(
                boolean_mask.reindex_like(self.dataset[var]), drop=True
            )
            dataset = dataset.assign({var: data})

        cls = type(self)
        return cls(dataset)

    def mean(self, dim, skipna=False):
        &#34;&#34;&#34;
        Calculate the mean value of the spectrum along the given dimension.
        :param dim: dimension to average over
        :param skipna: whether or not to &#34;skip&#34; nan values; if
            True behaves as np.nanmean
        :return:
        &#34;&#34;&#34;
        if dim in SPECTRAL_DIMS:
            raise ValueError(&#34;Cannot calculate mean over spectral dimensions&#34;)

        cls = type(self)
        dataset = xarray.Dataset()
        # Todo: fix averaging over longitude for (prime/anti) meridian issues
        dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
        for x in self.dataset:
            dataset = dataset.assign({x: self.dataset[x].mean(dim=dim, skipna=skipna)})
        return cls(dataset)

    def flatten(self, flattened_coordinate=&#34;linear_index&#34;):
        &#34;&#34;&#34;
        Serialize the non-spectral dimensions creating a single leading dimension
        without a coordinate.
        &#34;&#34;&#34;

        # Get the current dimensions and shape
        dims = self.dims_space_time
        coords = self.coords_space_time
        shape = self.space_time_shape()
        if len(shape) == 0:
            length = 1
            shape = (1,)
        else:
            length = np.prod(shape)

        # Calculate the flattened shape
        new_shape = (length,)
        new_spectral_shape = (length, *self.spectral_shape())
        new_dims = [flattened_coordinate] + self.dims_spectral

        linear_index = xarray.DataArray(
            data=np.arange(0, length), dims=flattened_coordinate
        )
        indices = np.unravel_index(linear_index.values, shape)

        dataset = {}
        for index, dim in zip(indices, dims):
            dataset[dim] = xarray.DataArray(
                data=coords[dim].values[index], dims=flattened_coordinate
            )

        for name in self.dataset:
            if name in SPECTRAL_VARS:
                x = xarray.DataArray(
                    data=self.dataset[name].values.reshape(new_spectral_shape),
                    dims=new_dims,
                    coords=self.coords_spectral,
                )
            else:
                x = xarray.DataArray(
                    data=self.dataset[name].values.reshape(new_shape),
                    dims=flattened_coordinate,
                )
            dataset[str(name)] = x

        cls = type(self)
        return cls(xarray.Dataset(dataset))

    def sum(self, dim: str, skipna: bool = False):
        &#34;&#34;&#34;
        Calculate the sum value of the spectrum along the given dimension.
        :param dim: dimension to sum over
        :param skipna: whether or not to &#34;skip&#34; nan values; if True behaves as np.nansum
        :return:
        &#34;&#34;&#34;

        if dim in SPECTRAL_DIMS:
            raise ValueError(&#34;Cannot calculate sum over spectral dimensions&#34;)

        cls = type(self)
        dataset = xarray.Dataset()
        # we assign the average coordinate to the dimension we sum over
        dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
        for x in self.dataset:
            dataset = dataset.assign({x: self.dataset[x].sum(dim=dim, skipna=skipna)})
        return cls(dataset)

    def std(self, dim: str, skipna: bool = False):
        &#34;&#34;&#34;
        Calculate the standard deviation of the spectrum along the given dimension.
        :param dim: dimension to calculate standard deviation over
        :param skipna: whether or not to &#34;skip&#34; nan values; if True behaves as np.nanstd
        :return:
        &#34;&#34;&#34;
        if dim in SPECTRAL_DIMS:
            raise ValueError(
                &#34;Cannot calculate standard deviation over spectral dimensions&#34;
            )

        cls = type(self)
        dataset = xarray.Dataset()
        # we assign the average coordinate to the dimension we calculate the std over
        dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
        for x in self.dataset:
            dataset = dataset.assign({x: self.dataset[x].std(dim=dim, skipna=skipna)})
        return cls(dataset)

    def shape(self):
        return self.variance_density.shape

    def spectral_shape(self):
        number_of_spectral_dims = len(self.dims_spectral)
        return self.shape()[-number_of_spectral_dims:]

    def space_time_shape(self):
        number_of_spectral_dims = len(self.dims_spectral)
        return self.shape()[:-number_of_spectral_dims]

    def frequency_moment(self, power: int, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Calculate a &#34;frequency moment&#34; over the given range. A frequency moment
        here refers to the integral:

                    Integral-over-frequency-range[ e(f) * f**power ]

        :param power: power of the frequency
        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: frequency moment
        &#34;&#34;&#34;
        _range = self._range(fmin, fmax)

        # Integrate dataset over frequencies. Make sure to fill any NaN entries
        # with 0 before the integration.
        return (
            (self.e.isel({NAME_F: _range}) * self.frequency[_range] ** power)
            .fillna(0)
            .integrate(coord=NAME_F)
        )

    @property
    def number_of_frequencies(self) -&gt; int:
        &#34;&#34;&#34;
        :return: number of frequencies
        &#34;&#34;&#34;
        return len(self.frequency)

    @property
    def dims_space_time(self) -&gt; List[str]:
        return [str(x) for x in self.variance_density.dims if x not in (SPECTRAL_DIMS)]

    @property
    def coords_space_time(self) -&gt; Mapping[str, xarray.DataArray]:
        return {dim: self.dataset[dim] for dim in self.dims_space_time}

    @property
    def coords_spectral(self) -&gt; Mapping[str, xarray.DataArray]:
        return {dim: self.dataset[dim] for dim in self.dims_spectral}

    @property
    def dims_spectral(self) -&gt; List[str]:
        return [str(x) for x in self.variance_density.dims if x in (SPECTRAL_DIMS)]

    @property
    def dims(self) -&gt; List[str]:
        return [str(x) for x in self.variance_density.dims]

    @property
    def number_of_spectra(self):
        dims = self.dims_space_time
        if dims:
            shape = 1
            for d in dims:
                shape *= len(self.dataset[d])
            return shape
        else:
            return 1

    @property
    def spectral_values(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Spectral levels
        &#34;&#34;&#34;
        return self.dataset[NAME_E]

    @property
    def radian_frequency(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Radian frequency
        &#34;&#34;&#34;
        data_array = self.dataset[NAME_F] * 2 * np.pi
        data_array.name = &#34;radian_frequency&#34;
        return data_array

    @property
    def latitude(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: latitudes
        &#34;&#34;&#34;
        return self.dataset[NAME_LAT]

    @property
    def longitude(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: longitudes
        &#34;&#34;&#34;
        return self.dataset[NAME_LON]

    @property
    def time(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Time
        &#34;&#34;&#34;
        return self.dataset[NAME_T]

    @property
    def variance_density(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Time
        &#34;&#34;&#34;
        return self.dataset[NAME_E]

    @property
    def values(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Get the raw np representation of the wave spectrum
        :return: Numpy ndarray of the wave spectrum.
        &#34;&#34;&#34;
        return self.dataset[NAME_E].values

    @property
    def e(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: 1D spectral values (directionally integrated spectrum).
            Equivalent to self.spectral_values if this is a 1D spectrum.
        &#34;&#34;&#34;
        return self.dataset[NAME_E]

    @property
    def a1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment cos(theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_a1]

    @property
    def b1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment sin(theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_b1]

    @property
    def a2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment cos(2*theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_a2]

    @property
    def b2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: normalized Fourier moment sin(2*theta)
        &#34;&#34;&#34;
        return self.dataset[NAME_b2]

    @property
    def A1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment cos(theta)
        &#34;&#34;&#34;
        return self.a1 * self.e

    @property
    def B1(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment sin(theta)
        &#34;&#34;&#34;
        return self.b1 * self.e

    @property
    def A2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment cos(2*theta)
        &#34;&#34;&#34;
        return self.a2 * self.e

    @property
    def B2(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Fourier moment sin(2*theta)
        &#34;&#34;&#34;
        return self.b2 * self.e

    @property
    def frequency(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return: Frequencies (Hz)
        &#34;&#34;&#34;
        return self.dataset[NAME_F]

    def m0(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Zero order frequency moment. Also referred to as variance or energy.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: variance/energy
        &#34;&#34;&#34;
        return self.frequency_moment(0, fmin, fmax)

    def m1(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        First order frequency moment. Primarily used in calculating a mean
        period measure (Tm01)

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: first order frequency moment.
        &#34;&#34;&#34;
        return self.frequency_moment(1, fmin, fmax)

    def wave_speed(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        :return:
        &#34;&#34;&#34;
        # Note we multiply inverse wavenumber with frequency to force xarray to return
        # a number_of_points by by number of frequencies data structure.
        return (1 / self.wavenumber) * self.radian_frequency

    def wave_age(self, windspeed):
        return self.peak_wave_speed() / windspeed

    def peak_wave_speed(self) -&gt; xarray.DataArray:
        return 2 * np.pi * self.peak_frequency() / self.peak_wavenumber

    @property
    def wavenumber_density(self) -&gt; xarray.DataArray:
        return self.variance_density * self.group_velocity / (np.pi * 2)

    @property
    def saturation_spectrum(self) -&gt; xarray.DataArray:
        return self.wavenumber_density * self.wavenumber**3

    @property
    def slope_spectrum(self) -&gt; xarray.DataArray:
        return self.variance_density * self.wavenumber**2

    def mean_squared_slope(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        _range = self._range(fmin, fmax)

        # Integrate dataset over frequencies. Make sure to fill any NaN entries with
        # 0 before the integration.
        return (
            self.slope_spectrum.fillna(0).isel({NAME_F: _range}).integrate(coord=NAME_F)
        )

    def m2(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Second order frequency moment. Primarily used in calculating the zero
        crossing period (Tm02)

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Second order frequency moment.
        &#34;&#34;&#34;
        return self.frequency_moment(2, fmin, fmax)

    def hm0(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Significant wave height estimated from the spectrum, i.e. waveheight
        h estimated from variance m0. Common notation in literature.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Significant wave height
        &#34;&#34;&#34;
        return xarray.DataArray(4 * np.sqrt(self.m0(fmin, fmax)))

    def tm01(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Mean period, estimated as the inverse of the center of mass of the
        spectral curve under the 1d spectrum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Mean period
        &#34;&#34;&#34;
        return self.m0(fmin, fmax) / self.m1(fmin, fmax)

    def tm02(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Zero crossing period based on Rice&#39;s spectral estimate.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: Zero crossing period
        &#34;&#34;&#34;
        return xarray.DataArray(np.sqrt(self.m0(fmin, fmax) / self.m2(fmin, fmax)))

    def peak_index(self, fmin: float = 0, fmax: float = np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Index of the peak frequency of the 1d spectrum within the given range
        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: peak indices
        &#34;&#34;&#34;
        return self.e.where(self._range(fmin, fmax), 0).argmax(dim=NAME_F)

    def peak_frequency(
        self, fmin=0.0, fmax=np.inf, use_spline=False, **kwargs
    ) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Peak frequency of the spectrum, i.e. frequency at which the spectrum
        obtains its maximum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :param use_spline: Use a spline based interpolation and determine peak
            frequency from the spline. This
        allows for a continuous estimate of the peak frequency. WARNING: if True the
        fmin and fmax paramteres are IGNORED
        :return: peak frequency
        &#34;&#34;&#34;
        if use_spline:
            if not fmin == 0.0 or np.isfinite(fmax):
                warn(
                    &#34;The fmin and fmax parameters are ignored&#34;
                    &#34;if use_spline is set to True&#34;
                )

            data = spline_peak_frequency(self.frequency.values, self.e.values, **kwargs)
            if len(self.dims_space_time) == 0:
                data = data[0]

            return xarray.DataArray(
                data=data,
                coords=self.coords_space_time,
                dims=self.dims_space_time,
            )
        else:
            return self.dataset[NAME_F][self.peak_index(fmin, fmax)]

    def peak_angular_frequency(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Peak frequency of the spectrum, i.e. frequency at which the spectrum
        obtains its maximum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: peak frequency
        &#34;&#34;&#34;
        return self.peak_frequency(fmin, fmax) * np.pi * 2

    def peak_period(
        self, fmin=0, fmax=np.inf, use_spline=False, **kwargs
    ) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Peak period of the spectrum, i.e. period at which the spectrum
        obtains its maximum.

        :param fmin: minimum frequency
        :param fmax: maximum frequency
        :return: peak period
        &#34;&#34;&#34;
        peak_period = 1 / self.peak_frequency(
            fmin, fmax, use_spline=use_spline, **kwargs
        )
        peak_period.name = &#34;peak period&#34;
        try:
            peak_period = peak_period.drop(&#34;frequency&#34;)
        except Exception:
            pass
        return peak_period

    def peak_direction(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        index = self.peak_index(fmin, fmax)
        return self._mean_direction(
            self.a1.isel(**{NAME_F: index}), self.b1.isel(**{NAME_F: index})
        )

    def peak_directional_spread(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
        index = self.peak_index(fmin, fmax)
        a1 = self.a1.isel(**{NAME_F: index})
        b1 = self.b1.isel(**{NAME_F: index})
        return self._spread(a1, b1)

    @staticmethod
    def _mean_direction(a1: xarray.DataArray, b1: xarray.DataArray) -&gt; xarray.DataArray:
        return xarray.DataArray(np.arctan2(b1, a1) * 180 / np.pi)

    @staticmethod
    def _spread(a1: xarray.DataArray, b1: xarray.DataArray) -&gt; xarray.DataArray:
        return xarray.DataArray(
            np.sqrt(2 - 2 * np.sqrt(a1**2 + b1**2)) * 180 / np.pi
        )

    @property
    def mean_direction_per_frequency(self) -&gt; xarray.DataArray:
        return self._mean_direction(self.a1, self.b1)

    @property
    def mean_spread_per_frequency(self) -&gt; xarray.DataArray:
        return self._spread(self.a1, self.b1)

    def _spectral_weighted(self, property: xarray.DataArray, fmin=0, fmax=np.inf):
        range = {NAME_F: self._range(fmin, fmax)}

        property = property.fillna(0)
        return np.trapz(
            property.isel(**range) * self.e.isel(**range), self.frequency[range]
        ) / self.m0(fmin, fmax)

    def mean_direction(self, fmin=0, fmax=np.inf):
        return self._mean_direction(self.mean_a1(fmin, fmax), self.mean_b1(fmin, fmax))

    def mean_directional_spread(self, fmin=0, fmax=np.inf):
        return self._spread(self.mean_a1(fmin, fmax), self.mean_b1(fmin, fmax))

    def mean_a1(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.a1, fmin, fmax)

    def mean_b1(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.b1, fmin, fmax)

    def mean_a2(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.a2, fmin, fmax)

    def mean_b2(self, fmin=0, fmax=np.inf):
        return self._spectral_weighted(self.b2, fmin, fmax)

    @property
    def depth(self) -&gt; xarray.DataArray:
        depth = self.dataset[NAME_DEPTH]
        return xarray.where(depth.isnull(), np.inf, depth)

    @property
    def group_velocity(self) -&gt; xarray.DataArray:
        depth = self.depth.expand_dims(dim=NAME_F, axis=-1).values
        k = self.wavenumber.values
        depth = depth * np.ones(k.shape)

        # Construct the output coordinates and dimension of the data array
        return_dimensions = (*self.dims_space_time, NAME_F)
        coords = {}
        for dim in return_dimensions:
            coords[dim] = self.dataset[dim].values

        return xarray.DataArray(
            data=intrinsic_group_velocity(k, depth),
            dims=return_dimensions,
            coords=coords,
        )

    @property
    def wavenumber(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;
        Determine the wavenumbers for the frequencies in the spectrum. Note that since
        the dispersion relation depends on depth the returned wavenumber array has the
        dimensions associated with the depth array by the frequency dimension.

        :return: wavenumbers
        &#34;&#34;&#34;

        # For numba (used in the dispersion relation) we need raw np arrays of
        # the correct dimension
        depth = self.depth.expand_dims(dim=NAME_F, axis=-1).values
        radian_frequency = self.radian_frequency.expand_dims(dim=self.depth.dims).values

        # Broadcasting does not work inside the numba implementaiton, we explicitly
        # need to construct arrays of the correct input dimension.
        depth_shape = depth.shape
        radian_frequency_shape = radian_frequency.shape

        depth = depth * np.ones(radian_frequency_shape)
        radian_frequency = np.ones(depth_shape) * radian_frequency

        # Construct the output coordinates and dimension of the data array
        return_dimensions = (*self.dims_space_time, NAME_F)
        coords = {}
        for dim in return_dimensions:
            coords[dim] = self.dataset[dim].values

        return xarray.DataArray(
            data=inverse_intrinsic_dispersion_relation(radian_frequency, depth),
            dims=return_dimensions,
            coords=coords,
        )

    @property
    def wavelength(self) -&gt; xarray.DataArray:
        return 2 * np.pi / self.wavenumber

    @property
    def peak_wavenumber(self) -&gt; xarray.DataArray:
        index = self.peak_index()
        # Construct the output coordinates and dimension of the data array
        coords = {}
        for dim in self.dims_space_time:
            coords[dim] = self.dataset[dim].values

        return xarray.DataArray(
            data=inverse_intrinsic_dispersion_relation(
                self.radian_frequency[index].values, self.depth.values
            ),
            dims=self.dims_space_time,
            coords=coords,
        )

    def bulk_variables(self) -&gt; xarray.Dataset:
        dataset = xarray.Dataset()
        dataset[&#34;significant_waveheight&#34;] = self.significant_waveheight
        dataset[&#34;mean_period&#34;] = self.mean_period
        dataset[&#34;peak_period&#34;] = self.peak_period()
        dataset[&#34;peak_direction&#34;] = self.peak_direction()
        dataset[&#34;peak_directional_spread&#34;] = self.peak_directional_spread()
        dataset[&#34;mean_direction&#34;] = self.mean_direction()
        dataset[&#34;mean_directional_spread&#34;] = self.mean_directional_spread()
        dataset[&#34;peak_frequency&#34;] = self.peak_frequency()
        dataset[&#34;latitude&#34;] = self.latitude
        dataset[&#34;longitude&#34;] = self.longitude
        dataset[&#34;timestamp&#34;] = self.time
        return dataset

    @property
    def significant_waveheight(self) -&gt; xarray.DataArray:
        return self.hm0()

    @property
    def mean_period(self) -&gt; xarray.DataArray:
        return self.tm01()

    @property
    def zero_crossing_period(self) -&gt; xarray.DataArray:
        return self.tm02()

    def cdf(self) -&gt; xarray.DataArray:
        &#34;&#34;&#34;

        :return:
        &#34;&#34;&#34;
        frequency_step = self.frequency_step
        integration_frequencies = np.concatenate(
            ([0], np.cumsum(frequency_step.values))
        )
        integration_frequencies = (
            integration_frequencies
            - frequency_step.values[0] / 2
            + self.frequency.values[0]
        )
        values = (self.variance_density * frequency_step).values

        frequency_axis = self.dims.index(NAME_F)

        cumsum = np.cumsum(values, axis=frequency_axis)
        # cumsum =  self.variance_density.cumulative_integrate(coord=NAME_F)
        # return cumsum
        shape = list(cumsum.shape)
        shape[frequency_axis] = 1

        cumsum = np.concatenate((np.zeros(shape), cumsum), axis=frequency_axis)

        coords = {str(coor): self.coords()[coor].values for coor in self.coords()}
        coords[NAME_F] = integration_frequencies
        return xarray.DataArray(data=cumsum, dims=self.dims, coords=coords)

    def interpolate(
        self,
        coordinates: Dict[str, Union[xarray.DataArray, np.ndarray]],
        extrapolation_value: float = 0.0,
    ):
        dataset = self.__class__(interpolate_dataset_grid(coordinates, self.dataset))
        dataset.fillna(extrapolation_value)
        return dataset

    def extrapolate_tail(
        self,
        end_frequency,
        power=None,
        tail_energy=None,
        tail_bounds=None,
        tail_moments=None,
        tail_frequency=None,
    ) -&gt; &#34;FrequencySpectrum&#34;:
        &#34;&#34;&#34;
        Extrapolate the tail using the given power
        :param end_frequency: frequency to extrapolate to
        :param power: power to use. If None, a best fit -4 or -5 tail is used.
        :return:
        &#34;&#34;&#34;
        e = self.e
        a1 = self.a1
        b1 = self.b1
        a2 = self.a2
        b2 = self.b2

        frequency = self.frequency.values
        frequency_delta = frequency[-1] - frequency[-2]
        n = int((end_frequency - frequency[-1]) / frequency_delta) + 1

        fstart = frequency[-1] + frequency_delta
        fend = frequency[-1] + n * frequency_delta

        if tail_frequency is None:
            tail_frequency = np.linspace(fstart, fend, n, endpoint=True)

        tail_frequency = xarray.DataArray(
            data=tail_frequency, coords={&#34;frequency&#34;: tail_frequency}, dims=&#34;frequency&#34;
        )
        variance_density = xarray.concat(
            (e, e.isel(frequency=-1) * xarray.zeros_like(tail_frequency)),
            dim=&#34;frequency&#34;,
        )

        tail_a1 = a1.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;a1&#34;]
        tail_b1 = b1.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;b1&#34;]
        tail_a2 = a2.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;a2&#34;]
        tail_b2 = b2.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;b2&#34;]

        a1 = xarray.concat(
            (a1, tail_a1 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )
        b1 = xarray.concat(
            (b1, tail_b1 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )
        a2 = xarray.concat(
            (a2, tail_a2 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )
        b2 = xarray.concat(
            (b2, tail_b2 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
        )

        if tail_energy is not None:
            if isinstance(tail_energy, xarray.DataArray):
                tail_energy = tail_energy.values

            tail_information = (tail_bounds, tail_energy)
        else:
            tail_information = None

        variance_density = xarray.DataArray(
            data=numba_fill_zeros_or_nan_in_tail(
                variance_density.values,
                variance_density.frequency.values,
                power,
                tail_information=tail_information,
            ),
            dims=a1.dims,
            coords=a1.coords,
        )

        dataset = xarray.Dataset(
            {
                &#34;variance_density&#34;: variance_density,
                &#34;a1&#34;: a1,
                &#34;b1&#34;: b1,
                &#34;a2&#34;: a2,
                &#34;b2&#34;: b2,
            }
        )

        for name in self.dataset:
            if name in SPECTRAL_VARS:
                continue
            else:
                dataset = dataset.assign({name: self.dataset[name]})

        return FrequencySpectrum(dataset)

    def bandpass(self, fmin: float = 0, fmax: float = np.inf):
        dataset = xarray.Dataset()

        for name in self.dataset:
            if name in SPECTRAL_VARS:
                data = self.dataset[name].where(
                    (self.frequency &gt;= fmin) &amp; (self.frequency &lt; fmax), drop=True
                )
                dataset = dataset.assign({name: data})
            else:
                dataset = dataset.assign({name: self.dataset[name]})
        cls = type(self)
        return cls(dataset)

    def interpolate_frequency(
        self,
        new_frequencies: Union[xarray.DataArray, np.ndarray],
        extrapolation_value: float = 0.0,
    ):
        obj = self.__class__(
            interpolate_dataset_along_axis(
                new_frequencies, self.dataset, coordinate_name=&#34;frequency&#34;
            )
        )
        obj.fillna(extrapolation_value)
        return obj

    def _range(self, fmin=0.0, fmax=np.inf) -&gt; np.ndarray:
        return (self.dataset[NAME_F].values &gt;= fmin) &amp; (
            self.dataset[NAME_F].values &lt; fmax
        )

    def save_as_netcdf(self, path):
        self.dataset.to_netcdf(path)

    def multiply(
        self,
        array: np.ndarray,
        dimensions: Optional[List[str]] = None,
        inplace: bool = False,
    ):
        &#34;&#34;&#34;
        Multiply the variance density with the given np array. Broadcasting is
        performed automatically if dimensions are provided. If no dimensions are
        provided the array needs to have the exact same shape as the variance
        density array.

        :param array: Array to multiply with variance density
        :param dimension: Dimensions of the array
        :return: self
        &#34;&#34;&#34;
        if inplace:
            output = self
        else:
            output = self.copy()

        coords = {}
        shape = array.shape
        if dimensions is None:
            if shape != self.shape():
                raise ValueError(
                    &#34;If no dimensions are provided the array must have the exact same&#34;
                    &#34;shape as the variance density array.&#34;
                )

            output.dataset[NAME_E] = self.dataset[NAME_E] * array
            return output

        if len(shape) != len(dimensions):
            raise ValueError(
                &#34;The dimensions of the input array must match the number of&#34;
                &#34;dimension labels&#34;
            )

        for length, dimension in zip(shape, dimensions):
            if dimension not in self.dims:
                raise ValueError(
                    f&#34;Dimension {dimension} not a valid dimension of the&#34;
                    &#34;spectral object.&#34;
                )
            coords[dimension] = self.dataset[dimension].values

            if len(self.dataset[dimension].values) != length:
                raise ValueError(
                    f&#34;Array length along the dimension {dimension} does not match the&#34;
                    &#34; length of the coordinate of the same name in the spctral object.&#34;
                )

        data = xarray.DataArray(data=array, coords=coords, dims=dimensions)
        output.dataset[NAME_E] = self.dataset[NAME_E] * data
        return output</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper">DatasetWrapper</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum">FrequencyDirectionSpectrum</a></li>
<li><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.angular_convention"><code class="name">var <span class="ident">angular_convention</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.angular_units"><code class="name">var <span class="ident">angular_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bulk_properties"><code class="name">var <span class="ident">bulk_properties</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_units"><code class="name">var <span class="ident">frequency_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_density_units"><code class="name">var <span class="ident">spectral_density_units</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A1"><code class="name">var <span class="ident">A1</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Fourier moment cos(theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def A1(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Fourier moment cos(theta)
    &#34;&#34;&#34;
    return self.a1 * self.e</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A2"><code class="name">var <span class="ident">A2</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Fourier moment cos(2*theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def A2(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Fourier moment cos(2*theta)
    &#34;&#34;&#34;
    return self.a2 * self.e</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B1"><code class="name">var <span class="ident">B1</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Fourier moment sin(theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def B1(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Fourier moment sin(theta)
    &#34;&#34;&#34;
    return self.b1 * self.e</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B2"><code class="name">var <span class="ident">B2</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Fourier moment sin(2*theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def B2(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Fourier moment sin(2*theta)
    &#34;&#34;&#34;
    return self.b2 * self.e</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a1"><code class="name">var <span class="ident">a1</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: normalized Fourier moment cos(theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def a1(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: normalized Fourier moment cos(theta)
    &#34;&#34;&#34;
    return self.dataset[NAME_a1]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a2"><code class="name">var <span class="ident">a2</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: normalized Fourier moment cos(2*theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def a2(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: normalized Fourier moment cos(2*theta)
    &#34;&#34;&#34;
    return self.dataset[NAME_a2]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b1"><code class="name">var <span class="ident">b1</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: normalized Fourier moment sin(theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def b1(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: normalized Fourier moment sin(theta)
    &#34;&#34;&#34;
    return self.dataset[NAME_b1]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b2"><code class="name">var <span class="ident">b2</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: normalized Fourier moment sin(2*theta)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def b2(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: normalized Fourier moment sin(2*theta)
    &#34;&#34;&#34;
    return self.dataset[NAME_b2]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.coords_space_time"><code class="name">var <span class="ident">coords_space_time</span> :Mapping[str,xarray.core.dataarray.DataArray]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coords_space_time(self) -&gt; Mapping[str, xarray.DataArray]:
    return {dim: self.dataset[dim] for dim in self.dims_space_time}</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.coords_spectral"><code class="name">var <span class="ident">coords_spectral</span> :Mapping[str,xarray.core.dataarray.DataArray]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def coords_spectral(self) -&gt; Mapping[str, xarray.DataArray]:
    return {dim: self.dataset[dim] for dim in self.dims_spectral}</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.depth"><code class="name">var <span class="ident">depth</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def depth(self) -&gt; xarray.DataArray:
    depth = self.dataset[NAME_DEPTH]
    return xarray.where(depth.isnull(), np.inf, depth)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims"><code class="name">var <span class="ident">dims</span> :List[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dims(self) -&gt; List[str]:
    return [str(x) for x in self.variance_density.dims]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims_space_time"><code class="name">var <span class="ident">dims_space_time</span> :List[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dims_space_time(self) -&gt; List[str]:
    return [str(x) for x in self.variance_density.dims if x not in (SPECTRAL_DIMS)]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims_spectral"><code class="name">var <span class="ident">dims_spectral</span> :List[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dims_spectral(self) -&gt; List[str]:
    return [str(x) for x in self.variance_density.dims if x in (SPECTRAL_DIMS)]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.e"><code class="name">var <span class="ident">e</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: 1D spectral values (directionally integrated spectrum).
Equivalent to self.spectral_values if this is a 1D spectrum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def e(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: 1D spectral values (directionally integrated spectrum).
        Equivalent to self.spectral_values if this is a 1D spectrum.
    &#34;&#34;&#34;
    return self.dataset[NAME_E]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency"><code class="name">var <span class="ident">frequency</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Frequencies (Hz)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frequency(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Frequencies (Hz)
    &#34;&#34;&#34;
    return self.dataset[NAME_F]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_step"><code class="name">var <span class="ident">frequency_step</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def frequency_step(self) -&gt; xarray.DataArray:
    prepend = 2 * self.frequency[0] - self.frequency[1]
    append = 2 * self.frequency[-1] - self.frequency[-2]
    diff = np.diff(self.frequency, append=append, prepend=prepend)
    return xarray.DataArray(
        data=(diff[0:-1] * 0.5 + diff[1:] * 0.5),
        dims=NAME_F,
        coords={NAME_F: self.frequency},
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.group_velocity"><code class="name">var <span class="ident">group_velocity</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def group_velocity(self) -&gt; xarray.DataArray:
    depth = self.depth.expand_dims(dim=NAME_F, axis=-1).values
    k = self.wavenumber.values
    depth = depth * np.ones(k.shape)

    # Construct the output coordinates and dimension of the data array
    return_dimensions = (*self.dims_space_time, NAME_F)
    coords = {}
    for dim in return_dimensions:
        coords[dim] = self.dataset[dim].values

    return xarray.DataArray(
        data=intrinsic_group_velocity(k, depth),
        dims=return_dimensions,
        coords=coords,
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.latitude"><code class="name">var <span class="ident">latitude</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: latitudes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def latitude(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: latitudes
    &#34;&#34;&#34;
    return self.dataset[NAME_LAT]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.longitude"><code class="name">var <span class="ident">longitude</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: longitudes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def longitude(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: longitudes
    &#34;&#34;&#34;
    return self.dataset[NAME_LON]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_direction_per_frequency"><code class="name">var <span class="ident">mean_direction_per_frequency</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean_direction_per_frequency(self) -&gt; xarray.DataArray:
    return self._mean_direction(self.a1, self.b1)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_period"><code class="name">var <span class="ident">mean_period</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean_period(self) -&gt; xarray.DataArray:
    return self.tm01()</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_spread_per_frequency"><code class="name">var <span class="ident">mean_spread_per_frequency</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mean_spread_per_frequency(self) -&gt; xarray.DataArray:
    return self._spread(self.a1, self.b1)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.ndims"><code class="name">var <span class="ident">ndims</span> :int</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ndims(self) -&gt; int:
    return len(self.dims)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_frequencies"><code class="name">var <span class="ident">number_of_frequencies</span> :int</code></dt>
<dd>
<div class="desc"><p>:return: number of frequencies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_of_frequencies(self) -&gt; int:
    &#34;&#34;&#34;
    :return: number of frequencies
    &#34;&#34;&#34;
    return len(self.frequency)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_spectra"><code class="name">var <span class="ident">number_of_spectra</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def number_of_spectra(self):
    dims = self.dims_space_time
    if dims:
        shape = 1
        for d in dims:
            shape *= len(self.dataset[d])
        return shape
    else:
        return 1</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_wavenumber"><code class="name">var <span class="ident">peak_wavenumber</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def peak_wavenumber(self) -&gt; xarray.DataArray:
    index = self.peak_index()
    # Construct the output coordinates and dimension of the data array
    coords = {}
    for dim in self.dims_space_time:
        coords[dim] = self.dataset[dim].values

    return xarray.DataArray(
        data=inverse_intrinsic_dispersion_relation(
            self.radian_frequency[index].values, self.depth.values
        ),
        dims=self.dims_space_time,
        coords=coords,
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.radian_frequency"><code class="name">var <span class="ident">radian_frequency</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Radian frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def radian_frequency(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Radian frequency
    &#34;&#34;&#34;
    data_array = self.dataset[NAME_F] * 2 * np.pi
    data_array.name = &#34;radian_frequency&#34;
    return data_array</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.saturation_spectrum"><code class="name">var <span class="ident">saturation_spectrum</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def saturation_spectrum(self) -&gt; xarray.DataArray:
    return self.wavenumber_density * self.wavenumber**3</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.significant_waveheight"><code class="name">var <span class="ident">significant_waveheight</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def significant_waveheight(self) -&gt; xarray.DataArray:
    return self.hm0()</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.slope_spectrum"><code class="name">var <span class="ident">slope_spectrum</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slope_spectrum(self) -&gt; xarray.DataArray:
    return self.variance_density * self.wavenumber**2</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_values"><code class="name">var <span class="ident">spectral_values</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Spectral levels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spectral_values(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Spectral levels
    &#34;&#34;&#34;
    return self.dataset[NAME_E]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.time"><code class="name">var <span class="ident">time</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Time
    &#34;&#34;&#34;
    return self.dataset[NAME_T]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.values"><code class="name">var <span class="ident">values</span> :numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Get the raw np representation of the wave spectrum
:return: Numpy ndarray of the wave spectrum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def values(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Get the raw np representation of the wave spectrum
    :return: Numpy ndarray of the wave spectrum.
    &#34;&#34;&#34;
    return self.dataset[NAME_E].values</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.variance_density"><code class="name">var <span class="ident">variance_density</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>:return: Time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def variance_density(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return: Time
    &#34;&#34;&#34;
    return self.dataset[NAME_E]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavelength"><code class="name">var <span class="ident">wavelength</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def wavelength(self) -&gt; xarray.DataArray:
    return 2 * np.pi / self.wavenumber</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber"><code class="name">var <span class="ident">wavenumber</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"><p>Determine the wavenumbers for the frequencies in the spectrum. Note that since
the dispersion relation depends on depth the returned wavenumber array has the
dimensions associated with the depth array by the frequency dimension.</p>
<p>:return: wavenumbers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def wavenumber(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Determine the wavenumbers for the frequencies in the spectrum. Note that since
    the dispersion relation depends on depth the returned wavenumber array has the
    dimensions associated with the depth array by the frequency dimension.

    :return: wavenumbers
    &#34;&#34;&#34;

    # For numba (used in the dispersion relation) we need raw np arrays of
    # the correct dimension
    depth = self.depth.expand_dims(dim=NAME_F, axis=-1).values
    radian_frequency = self.radian_frequency.expand_dims(dim=self.depth.dims).values

    # Broadcasting does not work inside the numba implementaiton, we explicitly
    # need to construct arrays of the correct input dimension.
    depth_shape = depth.shape
    radian_frequency_shape = radian_frequency.shape

    depth = depth * np.ones(radian_frequency_shape)
    radian_frequency = np.ones(depth_shape) * radian_frequency

    # Construct the output coordinates and dimension of the data array
    return_dimensions = (*self.dims_space_time, NAME_F)
    coords = {}
    for dim in return_dimensions:
        coords[dim] = self.dataset[dim].values

    return xarray.DataArray(
        data=inverse_intrinsic_dispersion_relation(radian_frequency, depth),
        dims=return_dimensions,
        coords=coords,
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber_density"><code class="name">var <span class="ident">wavenumber_density</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def wavenumber_density(self) -&gt; xarray.DataArray:
    return self.variance_density * self.group_velocity / (np.pi * 2)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.zero_crossing_period"><code class="name">var <span class="ident">zero_crossing_period</span> :xarray.core.dataarray.DataArray</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def zero_crossing_period(self) -&gt; xarray.DataArray:
    return self.tm02()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bandpass"><code class="name flex">
<span>def <span class="ident">bandpass</span></span>(<span>self, fmin:float=0, fmax:float=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bandpass(self, fmin: float = 0, fmax: float = np.inf):
    dataset = xarray.Dataset()

    for name in self.dataset:
        if name in SPECTRAL_VARS:
            data = self.dataset[name].where(
                (self.frequency &gt;= fmin) &amp; (self.frequency &lt; fmax), drop=True
            )
            dataset = dataset.assign({name: data})
        else:
            dataset = dataset.assign({name: self.dataset[name]})
    cls = type(self)
    return cls(dataset)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bulk_variables"><code class="name flex">
<span>def <span class="ident">bulk_variables</span></span>(<span>self) >xarray.core.dataset.Dataset</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_variables(self) -&gt; xarray.Dataset:
    dataset = xarray.Dataset()
    dataset[&#34;significant_waveheight&#34;] = self.significant_waveheight
    dataset[&#34;mean_period&#34;] = self.mean_period
    dataset[&#34;peak_period&#34;] = self.peak_period()
    dataset[&#34;peak_direction&#34;] = self.peak_direction()
    dataset[&#34;peak_directional_spread&#34;] = self.peak_directional_spread()
    dataset[&#34;mean_direction&#34;] = self.mean_direction()
    dataset[&#34;mean_directional_spread&#34;] = self.mean_directional_spread()
    dataset[&#34;peak_frequency&#34;] = self.peak_frequency()
    dataset[&#34;latitude&#34;] = self.latitude
    dataset[&#34;longitude&#34;] = self.longitude
    dataset[&#34;timestamp&#34;] = self.time
    return dataset</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.cdf"><code class="name flex">
<span>def <span class="ident">cdf</span></span>(<span>self) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cdf(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;

    :return:
    &#34;&#34;&#34;
    frequency_step = self.frequency_step
    integration_frequencies = np.concatenate(
        ([0], np.cumsum(frequency_step.values))
    )
    integration_frequencies = (
        integration_frequencies
        - frequency_step.values[0] / 2
        + self.frequency.values[0]
    )
    values = (self.variance_density * frequency_step).values

    frequency_axis = self.dims.index(NAME_F)

    cumsum = np.cumsum(values, axis=frequency_axis)
    # cumsum =  self.variance_density.cumulative_integrate(coord=NAME_F)
    # return cumsum
    shape = list(cumsum.shape)
    shape[frequency_axis] = 1

    cumsum = np.concatenate((np.zeros(shape), cumsum), axis=frequency_axis)

    coords = {str(coor): self.coords()[coor].values for coor in self.coords()}
    coords[NAME_F] = integration_frequencies
    return xarray.DataArray(data=cumsum, dims=self.dims, coords=coords)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.drop_invalid"><code class="name flex">
<span>def <span class="ident">drop_invalid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drop_invalid(self):
    return self._apply_filter(self.is_valid())</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.extrapolate_tail"><code class="name flex">
<span>def <span class="ident">extrapolate_tail</span></span>(<span>self, end_frequency, power=None, tail_energy=None, tail_bounds=None, tail_moments=None, tail_frequency=None) ><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extrapolate the tail using the given power
:param end_frequency: frequency to extrapolate to
:param power: power to use. If None, a best fit -4 or -5 tail is used.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extrapolate_tail(
    self,
    end_frequency,
    power=None,
    tail_energy=None,
    tail_bounds=None,
    tail_moments=None,
    tail_frequency=None,
) -&gt; &#34;FrequencySpectrum&#34;:
    &#34;&#34;&#34;
    Extrapolate the tail using the given power
    :param end_frequency: frequency to extrapolate to
    :param power: power to use. If None, a best fit -4 or -5 tail is used.
    :return:
    &#34;&#34;&#34;
    e = self.e
    a1 = self.a1
    b1 = self.b1
    a2 = self.a2
    b2 = self.b2

    frequency = self.frequency.values
    frequency_delta = frequency[-1] - frequency[-2]
    n = int((end_frequency - frequency[-1]) / frequency_delta) + 1

    fstart = frequency[-1] + frequency_delta
    fend = frequency[-1] + n * frequency_delta

    if tail_frequency is None:
        tail_frequency = np.linspace(fstart, fend, n, endpoint=True)

    tail_frequency = xarray.DataArray(
        data=tail_frequency, coords={&#34;frequency&#34;: tail_frequency}, dims=&#34;frequency&#34;
    )
    variance_density = xarray.concat(
        (e, e.isel(frequency=-1) * xarray.zeros_like(tail_frequency)),
        dim=&#34;frequency&#34;,
    )

    tail_a1 = a1.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;a1&#34;]
    tail_b1 = b1.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;b1&#34;]
    tail_a2 = a2.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;a2&#34;]
    tail_b2 = b2.isel(frequency=-1) if tail_moments is None else tail_moments[&#34;b2&#34;]

    a1 = xarray.concat(
        (a1, tail_a1 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
    )
    b1 = xarray.concat(
        (b1, tail_b1 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
    )
    a2 = xarray.concat(
        (a2, tail_a2 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
    )
    b2 = xarray.concat(
        (b2, tail_b2 * xarray.ones_like(tail_frequency)), dim=&#34;frequency&#34;
    )

    if tail_energy is not None:
        if isinstance(tail_energy, xarray.DataArray):
            tail_energy = tail_energy.values

        tail_information = (tail_bounds, tail_energy)
    else:
        tail_information = None

    variance_density = xarray.DataArray(
        data=numba_fill_zeros_or_nan_in_tail(
            variance_density.values,
            variance_density.frequency.values,
            power,
            tail_information=tail_information,
        ),
        dims=a1.dims,
        coords=a1.coords,
    )

    dataset = xarray.Dataset(
        {
            &#34;variance_density&#34;: variance_density,
            &#34;a1&#34;: a1,
            &#34;b1&#34;: b1,
            &#34;a2&#34;: a2,
            &#34;b2&#34;: b2,
        }
    )

    for name in self.dataset:
        if name in SPECTRAL_VARS:
            continue
        else:
            dataset = dataset.assign({name: self.dataset[name]})

    return FrequencySpectrum(dataset)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.fillna"><code class="name flex">
<span>def <span class="ident">fillna</span></span>(<span>self, value=0.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fillna(self, value=0.0):
    for variable in SPECTRAL_VARS:
        if variable in self.dataset:
            self.dataset[variable] = self.dataset[variable].fillna(value)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.flatten"><code class="name flex">
<span>def <span class="ident">flatten</span></span>(<span>self, flattened_coordinate='linear_index')</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize the non-spectral dimensions creating a single leading dimension
without a coordinate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flatten(self, flattened_coordinate=&#34;linear_index&#34;):
    &#34;&#34;&#34;
    Serialize the non-spectral dimensions creating a single leading dimension
    without a coordinate.
    &#34;&#34;&#34;

    # Get the current dimensions and shape
    dims = self.dims_space_time
    coords = self.coords_space_time
    shape = self.space_time_shape()
    if len(shape) == 0:
        length = 1
        shape = (1,)
    else:
        length = np.prod(shape)

    # Calculate the flattened shape
    new_shape = (length,)
    new_spectral_shape = (length, *self.spectral_shape())
    new_dims = [flattened_coordinate] + self.dims_spectral

    linear_index = xarray.DataArray(
        data=np.arange(0, length), dims=flattened_coordinate
    )
    indices = np.unravel_index(linear_index.values, shape)

    dataset = {}
    for index, dim in zip(indices, dims):
        dataset[dim] = xarray.DataArray(
            data=coords[dim].values[index], dims=flattened_coordinate
        )

    for name in self.dataset:
        if name in SPECTRAL_VARS:
            x = xarray.DataArray(
                data=self.dataset[name].values.reshape(new_spectral_shape),
                dims=new_dims,
                coords=self.coords_spectral,
            )
        else:
            x = xarray.DataArray(
                data=self.dataset[name].values.reshape(new_shape),
                dims=flattened_coordinate,
            )
        dataset[str(name)] = x

    cls = type(self)
    return cls(xarray.Dataset(dataset))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_moment"><code class="name flex">
<span>def <span class="ident">frequency_moment</span></span>(<span>self, power:int, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a "frequency moment" over the given range. A frequency moment
here refers to the integral:</p>
<pre><code>        Integral-over-frequency-range[ e(f) * f**power ]
</code></pre>
<p>:param power: power of the frequency
:param fmin: minimum frequency
:param fmax: maximum frequency
:return: frequency moment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def frequency_moment(self, power: int, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Calculate a &#34;frequency moment&#34; over the given range. A frequency moment
    here refers to the integral:

                Integral-over-frequency-range[ e(f) * f**power ]

    :param power: power of the frequency
    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: frequency moment
    &#34;&#34;&#34;
    _range = self._range(fmin, fmax)

    # Integrate dataset over frequencies. Make sure to fill any NaN entries
    # with 0 before the integration.
    return (
        (self.e.isel({NAME_F: _range}) * self.frequency[_range] ** power)
        .fillna(0)
        .integrate(coord=NAME_F)
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.hm0"><code class="name flex">
<span>def <span class="ident">hm0</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Significant wave height estimated from the spectrum, i.e. waveheight
h estimated from variance m0. Common notation in literature.</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: Significant wave height</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hm0(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Significant wave height estimated from the spectrum, i.e. waveheight
    h estimated from variance m0. Common notation in literature.

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: Significant wave height
    &#34;&#34;&#34;
    return xarray.DataArray(4 * np.sqrt(self.m0(fmin, fmax)))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>self, coordinates:Dict[str,Union[xarray.core.dataarray.DataArray,numpy.ndarray]], extrapolation_value:float=0.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(
    self,
    coordinates: Dict[str, Union[xarray.DataArray, np.ndarray]],
    extrapolation_value: float = 0.0,
):
    dataset = self.__class__(interpolate_dataset_grid(coordinates, self.dataset))
    dataset.fillna(extrapolation_value)
    return dataset</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.interpolate_frequency"><code class="name flex">
<span>def <span class="ident">interpolate_frequency</span></span>(<span>self, new_frequencies:Union[xarray.core.dataarray.DataArray,numpy.ndarray], extrapolation_value:float=0.0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate_frequency(
    self,
    new_frequencies: Union[xarray.DataArray, np.ndarray],
    extrapolation_value: float = 0.0,
):
    obj = self.__class__(
        interpolate_dataset_along_axis(
            new_frequencies, self.dataset, coordinate_name=&#34;frequency&#34;
        )
    )
    obj.fillna(extrapolation_value)
    return obj</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.is_invalid"><code class="name flex">
<span>def <span class="ident">is_invalid</span></span>(<span>self) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_invalid(self) -&gt; xarray.DataArray:
    return self.variance_density.isnull().all(dim=self.dims_spectral)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.is_valid"><code class="name flex">
<span>def <span class="ident">is_valid</span></span>(<span>self) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid(self) -&gt; xarray.DataArray:
    return ~self.is_invalid()</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m0"><code class="name flex">
<span>def <span class="ident">m0</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Zero order frequency moment. Also referred to as variance or energy.</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: variance/energy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def m0(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Zero order frequency moment. Also referred to as variance or energy.

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: variance/energy
    &#34;&#34;&#34;
    return self.frequency_moment(0, fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m1"><code class="name flex">
<span>def <span class="ident">m1</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>First order frequency moment. Primarily used in calculating a mean
period measure (Tm01)</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: first order frequency moment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def m1(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    First order frequency moment. Primarily used in calculating a mean
    period measure (Tm01)

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: first order frequency moment.
    &#34;&#34;&#34;
    return self.frequency_moment(1, fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m2"><code class="name flex">
<span>def <span class="ident">m2</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Second order frequency moment. Primarily used in calculating the zero
crossing period (Tm02)</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: Second order frequency moment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def m2(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Second order frequency moment. Primarily used in calculating the zero
    crossing period (Tm02)

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: Second order frequency moment.
    &#34;&#34;&#34;
    return self.frequency_moment(2, fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean"><code class="name flex">
<span>def <span class="ident">mean</span></span>(<span>self, dim, skipna=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the mean value of the spectrum along the given dimension.
:param dim: dimension to average over
:param skipna: whether or not to "skip" nan values; if
True behaves as np.nanmean
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean(self, dim, skipna=False):
    &#34;&#34;&#34;
    Calculate the mean value of the spectrum along the given dimension.
    :param dim: dimension to average over
    :param skipna: whether or not to &#34;skip&#34; nan values; if
        True behaves as np.nanmean
    :return:
    &#34;&#34;&#34;
    if dim in SPECTRAL_DIMS:
        raise ValueError(&#34;Cannot calculate mean over spectral dimensions&#34;)

    cls = type(self)
    dataset = xarray.Dataset()
    # Todo: fix averaging over longitude for (prime/anti) meridian issues
    dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
    for x in self.dataset:
        dataset = dataset.assign({x: self.dataset[x].mean(dim=dim, skipna=skipna)})
    return cls(dataset)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_a1"><code class="name flex">
<span>def <span class="ident">mean_a1</span></span>(<span>self, fmin=0, fmax=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_a1(self, fmin=0, fmax=np.inf):
    return self._spectral_weighted(self.a1, fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_a2"><code class="name flex">
<span>def <span class="ident">mean_a2</span></span>(<span>self, fmin=0, fmax=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_a2(self, fmin=0, fmax=np.inf):
    return self._spectral_weighted(self.a2, fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_b1"><code class="name flex">
<span>def <span class="ident">mean_b1</span></span>(<span>self, fmin=0, fmax=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_b1(self, fmin=0, fmax=np.inf):
    return self._spectral_weighted(self.b1, fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_b2"><code class="name flex">
<span>def <span class="ident">mean_b2</span></span>(<span>self, fmin=0, fmax=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_b2(self, fmin=0, fmax=np.inf):
    return self._spectral_weighted(self.b2, fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_direction"><code class="name flex">
<span>def <span class="ident">mean_direction</span></span>(<span>self, fmin=0, fmax=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_direction(self, fmin=0, fmax=np.inf):
    return self._mean_direction(self.mean_a1(fmin, fmax), self.mean_b1(fmin, fmax))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_directional_spread"><code class="name flex">
<span>def <span class="ident">mean_directional_spread</span></span>(<span>self, fmin=0, fmax=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_directional_spread(self, fmin=0, fmax=np.inf):
    return self._spread(self.mean_a1(fmin, fmax), self.mean_b1(fmin, fmax))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_squared_slope"><code class="name flex">
<span>def <span class="ident">mean_squared_slope</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mean_squared_slope(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    _range = self._range(fmin, fmax)

    # Integrate dataset over frequencies. Make sure to fill any NaN entries with
    # 0 before the integration.
    return (
        self.slope_spectrum.fillna(0).isel({NAME_F: _range}).integrate(coord=NAME_F)
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.multiply"><code class="name flex">
<span>def <span class="ident">multiply</span></span>(<span>self, array:numpy.ndarray, dimensions:Optional[List[str]]=None, inplace:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the variance density with the given np array. Broadcasting is
performed automatically if dimensions are provided. If no dimensions are
provided the array needs to have the exact same shape as the variance
density array.</p>
<p>:param array: Array to multiply with variance density
:param dimension: Dimensions of the array
:return: self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply(
    self,
    array: np.ndarray,
    dimensions: Optional[List[str]] = None,
    inplace: bool = False,
):
    &#34;&#34;&#34;
    Multiply the variance density with the given np array. Broadcasting is
    performed automatically if dimensions are provided. If no dimensions are
    provided the array needs to have the exact same shape as the variance
    density array.

    :param array: Array to multiply with variance density
    :param dimension: Dimensions of the array
    :return: self
    &#34;&#34;&#34;
    if inplace:
        output = self
    else:
        output = self.copy()

    coords = {}
    shape = array.shape
    if dimensions is None:
        if shape != self.shape():
            raise ValueError(
                &#34;If no dimensions are provided the array must have the exact same&#34;
                &#34;shape as the variance density array.&#34;
            )

        output.dataset[NAME_E] = self.dataset[NAME_E] * array
        return output

    if len(shape) != len(dimensions):
        raise ValueError(
            &#34;The dimensions of the input array must match the number of&#34;
            &#34;dimension labels&#34;
        )

    for length, dimension in zip(shape, dimensions):
        if dimension not in self.dims:
            raise ValueError(
                f&#34;Dimension {dimension} not a valid dimension of the&#34;
                &#34;spectral object.&#34;
            )
        coords[dimension] = self.dataset[dimension].values

        if len(self.dataset[dimension].values) != length:
            raise ValueError(
                f&#34;Array length along the dimension {dimension} does not match the&#34;
                &#34; length of the coordinate of the same name in the spctral object.&#34;
            )

    data = xarray.DataArray(data=array, coords=coords, dims=dimensions)
    output.dataset[NAME_E] = self.dataset[NAME_E] * data
    return output</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_angular_frequency"><code class="name flex">
<span>def <span class="ident">peak_angular_frequency</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Peak frequency of the spectrum, i.e. frequency at which the spectrum
obtains its maximum.</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: peak frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_angular_frequency(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Peak frequency of the spectrum, i.e. frequency at which the spectrum
    obtains its maximum.

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: peak frequency
    &#34;&#34;&#34;
    return self.peak_frequency(fmin, fmax) * np.pi * 2</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_direction"><code class="name flex">
<span>def <span class="ident">peak_direction</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_direction(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    index = self.peak_index(fmin, fmax)
    return self._mean_direction(
        self.a1.isel(**{NAME_F: index}), self.b1.isel(**{NAME_F: index})
    )</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_directional_spread"><code class="name flex">
<span>def <span class="ident">peak_directional_spread</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_directional_spread(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    index = self.peak_index(fmin, fmax)
    a1 = self.a1.isel(**{NAME_F: index})
    b1 = self.b1.isel(**{NAME_F: index})
    return self._spread(a1, b1)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_frequency"><code class="name flex">
<span>def <span class="ident">peak_frequency</span></span>(<span>self, fmin=0.0, fmax=inf, use_spline=False, **kwargs) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Peak frequency of the spectrum, i.e. frequency at which the spectrum
obtains its maximum.</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:param use_spline: Use a spline based interpolation and determine peak
frequency from the spline. This
allows for a continuous estimate of the peak frequency. WARNING: if True the
fmin and fmax paramteres are IGNORED
:return: peak frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_frequency(
    self, fmin=0.0, fmax=np.inf, use_spline=False, **kwargs
) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Peak frequency of the spectrum, i.e. frequency at which the spectrum
    obtains its maximum.

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :param use_spline: Use a spline based interpolation and determine peak
        frequency from the spline. This
    allows for a continuous estimate of the peak frequency. WARNING: if True the
    fmin and fmax paramteres are IGNORED
    :return: peak frequency
    &#34;&#34;&#34;
    if use_spline:
        if not fmin == 0.0 or np.isfinite(fmax):
            warn(
                &#34;The fmin and fmax parameters are ignored&#34;
                &#34;if use_spline is set to True&#34;
            )

        data = spline_peak_frequency(self.frequency.values, self.e.values, **kwargs)
        if len(self.dims_space_time) == 0:
            data = data[0]

        return xarray.DataArray(
            data=data,
            coords=self.coords_space_time,
            dims=self.dims_space_time,
        )
    else:
        return self.dataset[NAME_F][self.peak_index(fmin, fmax)]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_index"><code class="name flex">
<span>def <span class="ident">peak_index</span></span>(<span>self, fmin:float=0, fmax:float=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Index of the peak frequency of the 1d spectrum within the given range
:param fmin: minimum frequency
:param fmax: maximum frequency
:return: peak indices</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_index(self, fmin: float = 0, fmax: float = np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Index of the peak frequency of the 1d spectrum within the given range
    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: peak indices
    &#34;&#34;&#34;
    return self.e.where(self._range(fmin, fmax), 0).argmax(dim=NAME_F)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_period"><code class="name flex">
<span>def <span class="ident">peak_period</span></span>(<span>self, fmin=0, fmax=inf, use_spline=False, **kwargs) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Peak period of the spectrum, i.e. period at which the spectrum
obtains its maximum.</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: peak period</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_period(
    self, fmin=0, fmax=np.inf, use_spline=False, **kwargs
) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Peak period of the spectrum, i.e. period at which the spectrum
    obtains its maximum.

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: peak period
    &#34;&#34;&#34;
    peak_period = 1 / self.peak_frequency(
        fmin, fmax, use_spline=use_spline, **kwargs
    )
    peak_period.name = &#34;peak period&#34;
    try:
        peak_period = peak_period.drop(&#34;frequency&#34;)
    except Exception:
        pass
    return peak_period</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_wave_speed"><code class="name flex">
<span>def <span class="ident">peak_wave_speed</span></span>(<span>self) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def peak_wave_speed(self) -&gt; xarray.DataArray:
    return 2 * np.pi * self.peak_frequency() / self.peak_wavenumber</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.save_as_netcdf"><code class="name flex">
<span>def <span class="ident">save_as_netcdf</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_as_netcdf(self, path):
    self.dataset.to_netcdf(path)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shape(self):
    return self.variance_density.shape</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.space_time_shape"><code class="name flex">
<span>def <span class="ident">space_time_shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def space_time_shape(self):
    number_of_spectral_dims = len(self.dims_spectral)
    return self.shape()[:-number_of_spectral_dims]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_shape"><code class="name flex">
<span>def <span class="ident">spectral_shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spectral_shape(self):
    number_of_spectral_dims = len(self.dims_spectral)
    return self.shape()[-number_of_spectral_dims:]</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.std"><code class="name flex">
<span>def <span class="ident">std</span></span>(<span>self, dim:str, skipna:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the standard deviation of the spectrum along the given dimension.
:param dim: dimension to calculate standard deviation over
:param skipna: whether or not to "skip" nan values; if True behaves as np.nanstd
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def std(self, dim: str, skipna: bool = False):
    &#34;&#34;&#34;
    Calculate the standard deviation of the spectrum along the given dimension.
    :param dim: dimension to calculate standard deviation over
    :param skipna: whether or not to &#34;skip&#34; nan values; if True behaves as np.nanstd
    :return:
    &#34;&#34;&#34;
    if dim in SPECTRAL_DIMS:
        raise ValueError(
            &#34;Cannot calculate standard deviation over spectral dimensions&#34;
        )

    cls = type(self)
    dataset = xarray.Dataset()
    # we assign the average coordinate to the dimension we calculate the std over
    dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
    for x in self.dataset:
        dataset = dataset.assign({x: self.dataset[x].std(dim=dim, skipna=skipna)})
    return cls(dataset)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>self, dim:str, skipna:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the sum value of the spectrum along the given dimension.
:param dim: dimension to sum over
:param skipna: whether or not to "skip" nan values; if True behaves as np.nansum
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(self, dim: str, skipna: bool = False):
    &#34;&#34;&#34;
    Calculate the sum value of the spectrum along the given dimension.
    :param dim: dimension to sum over
    :param skipna: whether or not to &#34;skip&#34; nan values; if True behaves as np.nansum
    :return:
    &#34;&#34;&#34;

    if dim in SPECTRAL_DIMS:
        raise ValueError(&#34;Cannot calculate sum over spectral dimensions&#34;)

    cls = type(self)
    dataset = xarray.Dataset()
    # we assign the average coordinate to the dimension we sum over
    dataset = dataset.assign({dim: self.dataset[dim].mean(dim=dim, skipna=skipna)})
    for x in self.dataset:
        dataset = dataset.assign({x: self.dataset[x].sum(dim=dim, skipna=skipna)})
    return cls(dataset)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm01"><code class="name flex">
<span>def <span class="ident">tm01</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Mean period, estimated as the inverse of the center of mass of the
spectral curve under the 1d spectrum.</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: Mean period</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm01(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Mean period, estimated as the inverse of the center of mass of the
    spectral curve under the 1d spectrum.

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: Mean period
    &#34;&#34;&#34;
    return self.m0(fmin, fmax) / self.m1(fmin, fmax)</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm02"><code class="name flex">
<span>def <span class="ident">tm02</span></span>(<span>self, fmin=0, fmax=inf) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Zero crossing period based on Rice's spectral estimate.</p>
<p>:param fmin: minimum frequency
:param fmax: maximum frequency
:return: Zero crossing period</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tm02(self, fmin=0, fmax=np.inf) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    Zero crossing period based on Rice&#39;s spectral estimate.

    :param fmin: minimum frequency
    :param fmax: maximum frequency
    :return: Zero crossing period
    &#34;&#34;&#34;
    return xarray.DataArray(np.sqrt(self.m0(fmin, fmax) / self.m2(fmin, fmax)))</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_age"><code class="name flex">
<span>def <span class="ident">wave_age</span></span>(<span>self, windspeed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wave_age(self, windspeed):
    return self.peak_wave_speed() / windspeed</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_speed"><code class="name flex">
<span>def <span class="ident">wave_speed</span></span>(<span>self) >xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wave_speed(self) -&gt; xarray.DataArray:
    &#34;&#34;&#34;
    :return:
    &#34;&#34;&#34;
    # Note we multiply inverse wavenumber with frequency to force xarray to return
    # a number_of_points by by number of frequencies data structure.
    return (1 / self.wavenumber) * self.radian_frequency</code></pre>
</details>
</dd>
<dt id="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>self, condition:xarray.core.dataarray.DataArray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(self, condition: xarray.DataArray):
    return self._apply_filter(condition)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ocean_science_utilities.wavespectra" href="index.html">ocean_science_utilities.wavespectra</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.create_1d_spectrum" href="#ocean_science_utilities.wavespectra.spectrum.create_1d_spectrum">create_1d_spectrum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.create_2d_spectrum" href="#ocean_science_utilities.wavespectra.spectrum.create_2d_spectrum">create_2d_spectrum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.create_spectrum_dataset" href="#ocean_science_utilities.wavespectra.spectrum.create_spectrum_dataset">create_spectrum_dataset</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.cumulative_frequency_interpolation_1d_variable" href="#ocean_science_utilities.wavespectra.spectrum.cumulative_frequency_interpolation_1d_variable">cumulative_frequency_interpolation_1d_variable</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.fill_zeros_or_nan_in_tail" href="#ocean_science_utilities.wavespectra.spectrum.fill_zeros_or_nan_in_tail">fill_zeros_or_nan_in_tail</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.load_spectrum_from_netcdf" href="#ocean_science_utilities.wavespectra.spectrum.load_spectrum_from_netcdf">load_spectrum_from_netcdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper">DatasetWrapper</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.coords" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.coords">coords</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.copy" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.copy">copy</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.isel" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.isel">isel</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.keys" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.keys">keys</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.sel" href="#ocean_science_utilities.wavespectra.spectrum.DatasetWrapper.sel">sel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum">FrequencyDirectionSpectrum</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.as_frequency_spectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.as_frequency_spectrum">as_frequency_spectrum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.differentiate" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.differentiate">differentiate</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.direction" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.direction">direction</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.direction_step" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.direction_step">direction_step</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.number_of_directions" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.number_of_directions">number_of_directions</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.radian_direction" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.radian_direction">radian_direction</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.spectrum_1d" href="#ocean_science_utilities.wavespectra.spectrum.FrequencyDirectionSpectrum.spectrum_1d">spectrum_1d</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum">FrequencySpectrum</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.as_frequency_direction_spectrum" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.as_frequency_direction_spectrum">as_frequency_direction_spectrum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.down_sample" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.down_sample">down_sample</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.interpolate" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.interpolate">interpolate</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.interpolate_frequency" href="#ocean_science_utilities.wavespectra.spectrum.FrequencySpectrum.interpolate_frequency">interpolate_frequency</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum">WaveSpectrum</a></code></h4>
<ul class="">
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A1">A1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.A2">A2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B1">B1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.B2">B2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a1">a1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.a2">a2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.angular_convention" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.angular_convention">angular_convention</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.angular_units" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.angular_units">angular_units</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b1">b1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.b2">b2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bandpass" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bandpass">bandpass</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bulk_properties" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bulk_properties">bulk_properties</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bulk_variables" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.bulk_variables">bulk_variables</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.cdf" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.cdf">cdf</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.coords_space_time" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.coords_space_time">coords_space_time</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.coords_spectral" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.coords_spectral">coords_spectral</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.depth" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.depth">depth</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims">dims</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims_space_time" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims_space_time">dims_space_time</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims_spectral" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.dims_spectral">dims_spectral</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.drop_invalid" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.drop_invalid">drop_invalid</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.e" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.e">e</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.extrapolate_tail" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.extrapolate_tail">extrapolate_tail</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.fillna" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.fillna">fillna</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.flatten" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.flatten">flatten</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency">frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_moment" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_moment">frequency_moment</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_step" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_step">frequency_step</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_units" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.frequency_units">frequency_units</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.group_velocity" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.group_velocity">group_velocity</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.hm0" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.hm0">hm0</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.interpolate" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.interpolate">interpolate</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.interpolate_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.interpolate_frequency">interpolate_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.is_invalid" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.is_invalid">is_invalid</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.is_valid" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.is_valid">is_valid</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.latitude" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.latitude">latitude</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.longitude" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.longitude">longitude</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m0" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m0">m0</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m1">m1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.m2">m2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean">mean</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_a1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_a1">mean_a1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_a2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_a2">mean_a2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_b1" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_b1">mean_b1</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_b2" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_b2">mean_b2</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_direction" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_direction">mean_direction</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_direction_per_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_direction_per_frequency">mean_direction_per_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_directional_spread" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_directional_spread">mean_directional_spread</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_period" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_period">mean_period</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_spread_per_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_spread_per_frequency">mean_spread_per_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_squared_slope" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.mean_squared_slope">mean_squared_slope</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.multiply" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.multiply">multiply</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.ndims" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.ndims">ndims</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_frequencies" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_frequencies">number_of_frequencies</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_spectra" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.number_of_spectra">number_of_spectra</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_angular_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_angular_frequency">peak_angular_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_direction" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_direction">peak_direction</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_directional_spread" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_directional_spread">peak_directional_spread</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_frequency">peak_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_index" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_index">peak_index</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_period" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_period">peak_period</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_wave_speed" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_wave_speed">peak_wave_speed</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_wavenumber" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.peak_wavenumber">peak_wavenumber</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.radian_frequency" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.radian_frequency">radian_frequency</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.saturation_spectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.saturation_spectrum">saturation_spectrum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.save_as_netcdf" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.save_as_netcdf">save_as_netcdf</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.shape" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.shape">shape</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.significant_waveheight" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.significant_waveheight">significant_waveheight</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.slope_spectrum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.slope_spectrum">slope_spectrum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.space_time_shape" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.space_time_shape">space_time_shape</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_density_units" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_density_units">spectral_density_units</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_shape" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_shape">spectral_shape</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_values" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.spectral_values">spectral_values</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.std" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.std">std</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.sum" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.sum">sum</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.time" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.time">time</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm01" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm01">tm01</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm02" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.tm02">tm02</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.values" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.values">values</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.variance_density" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.variance_density">variance_density</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_age" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_age">wave_age</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_speed" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wave_speed">wave_speed</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavelength" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavelength">wavelength</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber">wavenumber</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber_density" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.wavenumber_density">wavenumber_density</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.where" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.where">where</a></code></li>
<li><code><a title="ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.zero_crossing_period" href="#ocean_science_utilities.wavespectra.spectrum.WaveSpectrum.zero_crossing_period">zero_crossing_period</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
